/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 16);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calcNewScale = exports.calcScale = exports.getTouchCenter = exports.getCurrentPinchCenter = exports.scaleFactor = exports.getInitialScale = exports.getParentY = exports.getParentX = exports.addOffset = exports.isWithin = undefined;

var _handleEvent = __webpack_require__(1);

var sum = function sum(acc, next) {
  return acc + next;
};

/**
 * Calculates the average of multiple vectors (x, y values)
 */


var getVectorAvg = function getVectorAvg(vectors) {
  return {
    x: vectors.map(function (v) {
      return v.x;
    }).reduce(sum) / vectors.length,
    y: vectors.map(function (v) {
      return v.y;
    }).reduce(sum) / vectors.length
  };
};

var getParentElement = function getParentElement(type) {
  return function (el) {
    return el instanceof HTMLImageElement && el.parentElement instanceof HTMLDivElement ? el.parentElement[type] : 1;
  };
};

/**
 * isWithin - Check if value is between two values
 *
 * @param { Number } scale current scale value
 * @param { Object } minPinch, maxPinh
 * @return { Boolean }
 **/
var isWithin = exports.isWithin = function isWithin(scale, opts) {
  var maxScale = opts.maxScale,
      minScale = opts.minScale;

  return scale >= minScale && scale <= maxScale;
};

/**
 * addOffset - Combine current offset with old offset and returns a new offset
 *
 * @param { Object } lastOffset last offset
 * @param { Object } offset, new offset
 * @return { Object }
 **/
var addOffset = exports.addOffset = function addOffset(lastOffset, offset) {
  return {
    x: lastOffset.x + offset.x,
    y: lastOffset.y + offset.y
  };
};

var getParentX = exports.getParentX = getParentElement('offsetWidth');
var getParentY = exports.getParentY = getParentElement('offsetHeight');

/**
 * getScale - Check if value is between two values
 *
 * @param { Node } el current scale value
 * @return { Number }
 **/
var getInitialScale = exports.getInitialScale = function getInitialScale(el) {
  return el instanceof HTMLImageElement ? getParentX(el) / el.offsetWidth : 1;
};

/**
 * Scales the zoom factor relative to current state
 *
 * @param scale
 * @return the actual scale (can differ because of max min zoom factor)
 */
var scaleFactor = exports.scaleFactor = function scaleFactor(scale, factor, opts) {
  var originalFactor = factor;
  var zoomFactor = factor * scale;
  var maxScaleTimes = opts.maxScaleTimes,
      minScaleTimes = opts.minScaleTimes;

  zoomFactor = Math.min(maxScaleTimes, Math.max(zoomFactor, minScaleTimes));
  return {
    zoomFactor: zoomFactor,
    scale: zoomFactor / originalFactor
  };
};

/**
 * Calculates the virtual zoom center for the current offset and zoom factor
 * (used for reverse zoom)
 * @return {Object} the current zoom center
 */
var getCurrentPinchCenter = exports.getCurrentPinchCenter = function getCurrentPinchCenter(el, zoomFactor, offset) {
  var length = getParentX(el) * zoomFactor;
  var offsetLeft = offset.x;
  var offsetRight = length - offsetLeft - getParentX(el);
  var widthOffsetRatio = offsetLeft / offsetRight;
  var centerX = widthOffsetRatio * getParentX(el) / (widthOffsetRatio + 1);

  // the same for the zoomcenter y
  var height = getParentY(el) * zoomFactor;
  var offsetTop = offset.y;
  var offsetBottom = height - offsetTop - getParentY(el);
  var heightOffsetRatio = offsetTop / offsetBottom;
  var centerY = heightOffsetRatio * getParentY(el) / (heightOffsetRatio + 1);

  // prevents division by zero
  if (offsetRight === 0) {
    centerX = getParentX(el);
  }
  if (offsetBottom === 0) {
    centerY = getParentY(el);
  }

  return {
    x: centerX,
    y: centerY
  };
};

var getTouchCenter = exports.getTouchCenter = function getTouchCenter(touches) {
  return getVectorAvg(touches);
};

/**
 * calcScale - Calculate the distance between where we start our pinch
 * to where we end it
 *
 * @param { Array } startTouch The starting point of our touch
 * @param { Array } endTouch The current point of our touch
 * @return { Number }
 */
var calcScale = exports.calcScale = function calcScale(el, startTouch, endTouch) {
  return (0, _handleEvent.getDistance)((0, _handleEvent.getTouches)(el, endTouch)) / (0, _handleEvent.getDistance)((0, _handleEvent.getTouches)(el, startTouch));
};

var calcNewScale = exports.calcNewScale = function calcNewScale(to) {
  var lastScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return to / lastScale;
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var lastTouchStart = 0;

/**
 * cancelEvent - Cancel Events so we dont bubble up our events to the document
 *
 * @param { Object } event
 * @return { Void }
 **/
var cancelEvent = exports.cancelEvent = function cancelEvent(e) {
  e.stopPropagation();
  e.preventDefault();
};

/**
 * detectDoubleTap - Check if we are double tapping
 *
 * @param { Object } event
 * @return { Boolean }
 **/
var detectDoubleTap = exports.detectDoubleTap = function detectDoubleTap(e) {
  var time = new Date().getTime();

  if (e.touches.length > 1) {
    lastTouchStart = 0;
  }

  if (time - lastTouchStart < 300) {
    cancelEvent(event);
    return true;
  }

  if (e.touches.length === 1) {
    lastTouchStart = time;
  }
  return false;
};

/**
 * Returns the touches of an event relative to the container offset
 *
 * @param event
 * @return array touches
 */
var getTouches = exports.getTouches = function getTouches(el, touches) {
  var position = el.parentElement.getBoundingClientRect();
  return touches.map(function (touch) {
    return {
      x: touch.pageX - (position.left + document.body.scrollLeft),
      y: touch.pageY - (position.top + document.body.scrollTop)
    };
  });
};

/**
 * getDistance - Calculate the distance between our fingers
 *
 * @param { Array } touches touches passas an array from TouchList
 * @return { Number } the calcualted distance between the fingers
 **/
var getDistance = exports.getDistance = function getDistance(touches) {
  var _touches = _slicedToArray(touches, 2),
      first = _touches[0],
      second = _touches[1];

  return Math.sqrt((first.x - second.x) * (first.x - second.x) + (first.y - second.y) * (first.y - second.y));
};

/***/ }),
/* 2 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (target) {
  return function (e) {
    var newSpan = document.createElement('span');
    var time = new Date();
    time = time.getHours() + ':' + time.getMinutes() + ':' + time.getSeconds() + ',' + time.getMilliseconds();
    var newContent = document.createTextNode('[' + time + '] Event dispatched: "' + e.type + '"');
    newSpan.appendChild(newContent);
    target.appendChild(newSpan);
  };
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pinchIt = __webpack_require__(8);

var _pinchIt2 = _interopRequireDefault(_pinchIt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _pinchIt2.default;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/* **********************************************
     Begin prism-core.js
********************************************** */

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function(){

// Private helper vars
var lang = /\blang(?:uage)?-(\w+)\b/i;
var uniqueId = 0;

var _ = _self.Prism = {
	util: {
		encode: function (tokens) {
			if (tokens instanceof Token) {
				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
			} else if (_.util.type(tokens) === 'Array') {
				return tokens.map(_.util.encode);
			} else {
				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
			}
		},

		type: function (o) {
			return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
		},

		objId: function (obj) {
			if (!obj['__id']) {
				Object.defineProperty(obj, '__id', { value: ++uniqueId });
			}
			return obj['__id'];
		},

		// Deep clone a language definition (e.g. to extend it)
		clone: function (o) {
			var type = _.util.type(o);

			switch (type) {
				case 'Object':
					var clone = {};

					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = _.util.clone(o[key]);
						}
					}

					return clone;

				case 'Array':
					// Check for existence for IE8
					return o.map && o.map(function(v) { return _.util.clone(v); });
			}

			return o;
		}
	},

	languages: {
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);

			for (var key in redef) {
				lang[key] = redef[key];
			}

			return lang;
		},

		/**
		 * Insert a token before another token in a language literal
		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
		 * we cannot just provide an object, we need anobject and a key.
		 * @param inside The key (or language id) of the parent
		 * @param before The key to insert before. If not provided, the function appends instead.
		 * @param insert Object with the key/value pairs to insert
		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
		 */
		insertBefore: function (inside, before, insert, root) {
			root = root || _.languages;
			var grammar = root[inside];

			if (arguments.length == 2) {
				insert = arguments[1];

				for (var newToken in insert) {
					if (insert.hasOwnProperty(newToken)) {
						grammar[newToken] = insert[newToken];
					}
				}

				return grammar;
			}

			var ret = {};

			for (var token in grammar) {

				if (grammar.hasOwnProperty(token)) {

					if (token == before) {

						for (var newToken in insert) {

							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}

					ret[token] = grammar[token];
				}
			}

			// Update references in other language definitions
			_.languages.DFS(_.languages, function(key, value) {
				if (value === root[inside] && key != inside) {
					this[key] = ret;
				}
			});

			return root[inside] = ret;
		},

		// Traverse a language definition with Depth First Search
		DFS: function(o, callback, type, visited) {
			visited = visited || {};
			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					callback.call(o, i, o[i], type || i);

					if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, null, visited);
					}
					else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, i, visited);
					}
				}
			}
		}
	},
	plugins: {},

	highlightAll: function(async, callback) {
		var env = {
			callback: callback,
			selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
		};

		_.hooks.run("before-highlightall", env);

		var elements = env.elements || document.querySelectorAll(env.selector);

		for (var i=0, element; element = elements[i++];) {
			_.highlightElement(element, async === true, env.callback);
		}
	},

	highlightElement: function(element, async, callback) {
		// Find language
		var language, grammar, parent = element;

		while (parent && !lang.test(parent.className)) {
			parent = parent.parentNode;
		}

		if (parent) {
			language = (parent.className.match(lang) || [,''])[1].toLowerCase();
			grammar = _.languages[language];
		}

		// Set language on the element, if not present
		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

		// Set language on the parent, for styling
		parent = element.parentNode;

		if (/pre/i.test(parent.nodeName)) {
			parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
		}

		var code = element.textContent;

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};

		_.hooks.run('before-sanity-check', env);

		if (!env.code || !env.grammar) {
			if (env.code) {
				env.element.textContent = env.code;
			}
			_.hooks.run('complete', env);
			return;
		}

		_.hooks.run('before-highlight', env);

		if (async && _self.Worker) {
			var worker = new Worker(_.filename);

			worker.onmessage = function(evt) {
				env.highlightedCode = evt.data;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				callback && callback.call(env.element);
				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			};

			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code,
				immediateClose: true
			}));
		}
		else {
			env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

			_.hooks.run('before-insert', env);

			env.element.innerHTML = env.highlightedCode;

			callback && callback.call(element);

			_.hooks.run('after-highlight', env);
			_.hooks.run('complete', env);
		}
	},

	highlight: function (text, grammar, language) {
		var tokens = _.tokenize(text, grammar);
		return Token.stringify(_.util.encode(tokens), language);
	},

	tokenize: function(text, grammar, language) {
		var Token = _.Token;

		var strarr = [text];

		var rest = grammar.rest;

		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}

			delete grammar.rest;
		}

		tokenloop: for (var token in grammar) {
			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				var pattern = patterns[j],
					inside = pattern.inside,
					lookbehind = !!pattern.lookbehind,
					greedy = !!pattern.greedy,
					lookbehindLength = 0,
					alias = pattern.alias;

				if (greedy && !pattern.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
					pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
				}

				pattern = pattern.pattern || pattern;

				// Don’t cache length as it changes during the loop
				for (var i=0, pos = 0; i<strarr.length; pos += strarr[i].length, ++i) {

					var str = strarr[i];

					if (strarr.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						break tokenloop;
					}

					if (str instanceof Token) {
						continue;
					}

					pattern.lastIndex = 0;

					var match = pattern.exec(str),
					    delNum = 1;

					// Greedy patterns can override/remove up to two previously matched tokens
					if (!match && greedy && i != strarr.length - 1) {
						pattern.lastIndex = pos;
						match = pattern.exec(text);
						if (!match) {
							break;
						}

						var from = match.index + (lookbehind ? match[1].length : 0),
						    to = match.index + match[0].length,
						    k = i,
						    p = pos;

						for (var len = strarr.length; k < len && p < to; ++k) {
							p += strarr[k].length;
							// Move the index i to the element in strarr that is closest to from
							if (from >= p) {
								++i;
								pos = p;
							}
						}

						/*
						 * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
						 * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
						 */
						if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
							continue;
						}

						// Number of tokens to delete and replace with the new match
						delNum = k - i;
						str = text.slice(pos, p);
						match.index -= pos;
					}

					if (!match) {
						continue;
					}

					if(lookbehind) {
						lookbehindLength = match[1].length;
					}

					var from = match.index + lookbehindLength,
					    match = match[0].slice(lookbehindLength),
					    to = from + match.length,
					    before = str.slice(0, from),
					    after = str.slice(to);

					var args = [i, delNum];

					if (before) {
						args.push(before);
					}

					var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

					args.push(wrapped);

					if (after) {
						args.push(after);
					}

					Array.prototype.splice.apply(strarr, args);
				}
			}
		}

		return strarr;
	},

	hooks: {
		all: {},

		add: function (name, callback) {
			var hooks = _.hooks.all;

			hooks[name] = hooks[name] || [];

			hooks[name].push(callback);
		},

		run: function (name, env) {
			var callbacks = _.hooks.all[name];

			if (!callbacks || !callbacks.length) {
				return;
			}

			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	}
};

var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
	this.type = type;
	this.content = content;
	this.alias = alias;
	// Copy of the full string this token was created from
	this.length = (matchedStr || "").length|0;
	this.greedy = !!greedy;
};

Token.stringify = function(o, language, parent) {
	if (typeof o == 'string') {
		return o;
	}

	if (_.util.type(o) === 'Array') {
		return o.map(function(element) {
			return Token.stringify(element, language, o);
		}).join('');
	}

	var env = {
		type: o.type,
		content: Token.stringify(o.content, language, parent),
		tag: 'span',
		classes: ['token', o.type],
		attributes: {},
		language: language,
		parent: parent
	};

	if (env.type == 'comment') {
		env.attributes['spellcheck'] = 'true';
	}

	if (o.alias) {
		var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
		Array.prototype.push.apply(env.classes, aliases);
	}

	_.hooks.run('wrap', env);

	var attributes = Object.keys(env.attributes).map(function(name) {
		return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
	}).join(' ');

	return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';

};

if (!_self.document) {
	if (!_self.addEventListener) {
		// in Node.js
		return _self.Prism;
	}
 	// In worker
	_self.addEventListener('message', function(evt) {
		var message = JSON.parse(evt.data),
		    lang = message.language,
		    code = message.code,
		    immediateClose = message.immediateClose;

		_self.postMessage(_.highlight(code, _.languages[lang], lang));
		if (immediateClose) {
			_self.close();
		}
	}, false);

	return _self.Prism;
}

//Get current script and highlight
var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

if (script) {
	_.filename = script.src;

	if (document.addEventListener && !script.hasAttribute('data-manual')) {
		if(document.readyState !== "loading") {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(_.highlightAll);
			} else {
				window.setTimeout(_.highlightAll, 16);
			}
		}
		else {
			document.addEventListener('DOMContentLoaded', _.highlightAll);
		}
	}
}

return _self.Prism;

})();

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== 'undefined') {
	global.Prism = Prism;
}


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': /<!--[\w\W]*?-->/,
	'prolog': /<\?[\w\W]+?\?>/,
	'doctype': /<!DOCTYPE[\w\W]+?>/i,
	'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/i,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'attr-value': {
				pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
				inside: {
					'punctuation': /[=>"']/
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': /&#?[\da-z]{1,8};/i
};

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function(env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;


/* **********************************************
     Begin prism-css.js
********************************************** */

Prism.languages.css = {
	'comment': /\/\*[\w\W]*?\*\//,
	'atrule': {
		pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
		inside: {
			'rule': /@[\w-]+/
			// See rest below
		}
	},
	'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
	'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
	'string': {
		pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'property': /(\b|\B)[\w-]+(?=\s*:)/i,
	'important': /\B!important\b/i,
	'function': /[-a-z0-9]+(?=\()/i,
	'punctuation': /[(){};:]/
};

Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'style': {
			pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
			lookbehind: true,
			inside: Prism.languages.css,
			alias: 'language-css'
		}
	});
	
	Prism.languages.insertBefore('inside', 'attr-value', {
		'style-attr': {
			pattern: /\s*style=("|').*?\1/i,
			inside: {
				'attr-name': {
					pattern: /^\s*style/i,
					inside: Prism.languages.markup.tag.inside
				},
				'punctuation': /^\s*=\s*['"]|['"]\s*$/,
				'attr-value': {
					pattern: /.+/i,
					inside: Prism.languages.css
				}
			},
			alias: 'language-css'
		}
	}, Prism.languages.markup.tag);
}

/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
			lookbehind: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true
		}
	],
	'string': {
		pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
		lookbehind: true,
		inside: {
			punctuation: /(\.|\\)/
		}
	},
	'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(true|false)\b/,
	'function': /[a-z0-9_]+(?=\()/i,
	'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
	'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
});

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
		lookbehind: true,
		greedy: true
	}
});

Prism.languages.insertBefore('javascript', 'string', {
	'template-string': {
		pattern: /`(?:\\\\|\\?[^\\])*?`/,
		greedy: true,
		inside: {
			'interpolation': {
				pattern: /\$\{[^}]+\}/,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'script': {
			pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript,
			alias: 'language-javascript'
		}
	});
}

Prism.languages.js = Prism.languages.javascript;

/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
	if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
		return;
	}

	self.Prism.fileHighlight = function() {

		var Extensions = {
			'js': 'javascript',
			'py': 'python',
			'rb': 'ruby',
			'ps1': 'powershell',
			'psm1': 'powershell',
			'sh': 'bash',
			'bat': 'batch',
			'h': 'c',
			'tex': 'latex'
		};

		if(Array.prototype.forEach) { // Check to prevent error in IE8
			Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
				var src = pre.getAttribute('data-src');

				var language, parent = pre;
				var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
				while (parent && !lang.test(parent.className)) {
					parent = parent.parentNode;
				}

				if (parent) {
					language = (pre.className.match(lang) || [, ''])[1];
				}

				if (!language) {
					var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
					language = Extensions[extension] || extension;
				}

				var code = document.createElement('code');
				code.className = 'language-' + language;

				pre.textContent = '';

				code.textContent = 'Loading…';

				pre.appendChild(code);

				var xhr = new XMLHttpRequest();

				xhr.open('GET', src, true);

				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {

						if (xhr.status < 400 && xhr.responseText) {
							code.textContent = xhr.responseText;

							Prism.highlightElement(code);
						}
						else if (xhr.status >= 400) {
							code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
						}
						else {
							code.textContent = '✖ Error: File does not exist or is empty';
						}
					}
				};

				xhr.send(null);
			});
		}

	};

	document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(13);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(15)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!./../../css-loader/index.js!./prism.css", function() {
			var newContent = require("!!./../../css-loader/index.js!./prism.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {

  /**
   * default scale that will be set on element
   * @maxPinch {Number}
   */
  baseScale: 1,

  /**
   * max scale a node can reach
   * @maxPinch {Number}
   */
  maxScale: 3,

  /**
   * max scale a node can reach before bouncing back to maxScale
   * @maxScaleTimes {Number}
   */
  maxScaleTimes: 4,

  /**
   * min scale a node can reach
   * @minPinch {Number}
   */
  minScale: 1,

  /**
   * min scale a node can reach before bouncing back to minScale
   * @minScaleTimes {Number}
   */
  minScaleTimes: 0.8,

  /**
   * time for the snapBack of the pinch if the node has reach above
   * or below its pinch value
   * @snapBackSpeed {Number}
   */
  snapBackSpeed: 200,

  /**
   * Basic easing functions: https://developer.mozilla.org/de/docs/Web/CSS/transition-timing-function
   * cubic bezier easing functions: http://easings.net/de
   * @ease {String}
   */
  ease: 'ease'
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
//


var _dispatchEvent = __webpack_require__(10);

var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

var _handleEvent = __webpack_require__(1);

var _handleElement = __webpack_require__(12);

var _handleElement2 = _interopRequireDefault(_handleElement);

var _handlePinch = __webpack_require__(0);

var _handleDrag = __webpack_require__(11);

var _defaults = __webpack_require__(7);

var _defaults2 = _interopRequireDefault(_defaults);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var first = function first(items) {
  return items[0];
};

var pinchIt = function pinchIt(targets) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // private variable cache
  var elements = void 0;

  var scaling = void 0;
  var lastScale = 1;
  var startTouches = void 0;

  var zoomFactor = 1;

  var offset = { x: 0, y: 0 };
  var lastZoomCenter = false;
  var lastDragPosition = false;

  var _eventDispatcher = (0, _dispatchEvent2.default)(),
      on = _eventDispatcher.on,
      dispatch = _eventDispatcher.dispatch;

  /**
   *  dispatchPinchEvent - Shorthand method for creating events
   *
   *  @param { String } phase
   *  @param { String } type
   *  @param { Object } details
   *  @return { Void }
   **/


  var dispatchPinchEvent = function dispatchPinchEvent(eventName, phase) {
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    dispatch(eventName, Object.assign(data, {
      phase: phase
    }));
  };

  var resetGlobals = function resetGlobals() {
    scaling = false;
    lastScale = 1;
    startTouches = null;
    zoomFactor = 1;
    lastZoomCenter = false;

    lastDragPosition = false;
    offset = { x: 0, y: 0 };
  };

  // event handling
  /**
   * Set scaling if we are using more then one finger
   * and captures our first punch point
   *
   * private
   * @param { Object } e the event from our eventlistener
   */
  var onTouchstart = function onTouchstart(opts) {
    return function (e) {
      dispatchPinchEvent('touchstart', 'before', e);

      scaling = e.touches.length === 2;
      startTouches = Array.from(e.touches);
      lastScale = 1;

      if ((0, _handleEvent.detectDoubleTap)(e)) {
        (0, _handleElement2.default)(e.target, 1, { x: 0, y: 0 }, opts.snapBackSpeed, opts.ease);
        resetGlobals();
      }

      dispatchPinchEvent('touchstart', 'after', e);
    };
  };

  var onTouchmove = function onTouchmove(opts) {
    return function (e) {
      dispatchPinchEvent('touchmove', 'before', e);

      if ((!scaling || !startTouches) && zoomFactor > 1) {
        (0, _handleEvent.cancelEvent)(e);

        var touch = first((0, _handleEvent.getTouches)(e.target, Array.from(e.touches)));
        var dragOffset = (0, _handleDrag.drag)(touch, lastDragPosition, offset, zoomFactor);

        offset = (0, _handleDrag.sanitizeOffset)(e.target, dragOffset, zoomFactor);
        lastDragPosition = touch;
      } else if (scaling && startTouches) {
        (0, _handleEvent.cancelEvent)(e);

        // a relative scale factor is used
        var touchCenter = (0, _handlePinch.getTouchCenter)((0, _handleEvent.getTouches)(e.target, Array.from(e.touches)));
        var newScale = (0, _handlePinch.calcScale)(e.target, startTouches, Array.from(e.touches));
        var scale = (0, _handlePinch.calcNewScale)(newScale, lastScale);

        var factor = (0, _handlePinch.scaleFactor)(scale, zoomFactor, opts);

        offset = (0, _handlePinch.addOffset)(offset, {
          x: (factor.scale - 1) * (touchCenter.x + offset.x),
          y: (factor.scale - 1) * (touchCenter.y + offset.y)
        });

        zoomFactor = factor.zoomFactor;
        lastScale = newScale;
        offset = (0, _handleDrag.drag)(touchCenter, lastZoomCenter, offset, zoomFactor);
        lastZoomCenter = touchCenter;
      }

      (0, _handleElement2.default)(e.target, zoomFactor, offset, 0, opts.ease);

      dispatchPinchEvent('touchmove', 'after', e);
    };
  };

  var onTouchend = function onTouchend(opts) {
    return function (e) {
      dispatchPinchEvent('touchend', 'before', e);

      lastDragPosition = false;
      lastZoomCenter = false;
      lastScale = 1;
      if (zoomFactor) {
        if (!(0, _handlePinch.isWithin)(zoomFactor, opts)) {
          var isLessThan = (0, _handlePinch.getInitialScale)(e.target) * zoomFactor < opts.minScale;
          zoomFactor = isLessThan ? opts.minScale : opts.maxScale;
          offset = (0, _handleDrag.sanitizeOffset)(e.target, offset, zoomFactor);
          (0, _handleElement2.default)(e.target, zoomFactor, offset, opts.snapBackSpeed, opts.ease);
        }
      }

      dispatchPinchEvent('touchend', 'after', e);
    };
  };

  var attachEvents = function attachEvents(opts) {
    return function (el) {
      el.addEventListener('touchstart', onTouchstart(opts));
      el.addEventListener('touchmove', onTouchmove(opts));
      el.addEventListener('touchend', onTouchend(opts));
    };
  };

  var detachhEvents = function detachhEvents(el) {
    el.removeEventListener('touchstart', onTouchstart);
    el.removeEventListener('touchmove', onTouchmove);
    el.removeEventListener('touchend', onTouchend);
  };

  /**
   * public
   * reset function:
   * @param { Number } duration
   * @param { String } easing
   * @return { Void }
   */
  var reset = function reset(opt) {
    return function (item) {
      var _defaults$opt = _extends({}, _defaults2.default, opt),
          snapBackSpeed = _defaults$opt.snapBackSpeed,
          easing = _defaults$opt.easing;

      if (item && !isNaN(item) && elements[item]) {
        (0, _handleElement2.default)(elements[item], 1, { x: 0, y: 0 }, snapBackSpeed, easing);
      } else {
        Array.from(elements).forEach(function (el) {
          return (0, _handleElement2.default)(el, 1, { x: 0, y: 0 }, snapBackSpeed, easing);
        });
      }

      resetGlobals();
    };
  };

  /**
   * public
   * destroy function: called to gracefully destroy the lory instance
   * @return { Void }
   */
  var destroy = function destroy() {
    dispatchPinchEvent('destroy', 'before', {});
    // remove event listeners
    Array.from(elements).forEach(detachhEvents);
    dispatchPinchEvent('destroy', 'after', {});
  };

  /**
   * setup - Init function
   *
   * @param { String, Object }
   * @return { Void }
   **/

  var setup = function setup(target, opt) {
    if (elements) destroy();
    dispatchPinchEvent('init', 'before', {});

    // Base configuration for the pinch instance
    var opts = _extends({}, _defaults2.default, opt);

    // resolve target
    // pinchit allows for both a node or a string to be passed
    switch (typeof target === 'undefined' ? 'undefined' : _typeof(target)) {
      case 'object':
        elements = Array.isArray(target) ? target : [target];
        break;
      case 'string':
        elements = document.querySelectorAll(target);
        break;
      default:
        elements = [];
        console.warn('missing target, either pass an node or a string');
    }

    Array.from(elements).forEach(attachEvents(opts));

    dispatchPinchEvent('init', 'after', {});
  };

  // trigger initial setup
  setup(targets, options);

  return {
    setup: setup,
    reset: reset(options),
    destroy: destroy,
    elements: elements,
    on: on
  };
};

exports.default = pinchIt;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Detecting prefixes for saving time and bytes
 */
exports.default = function () {
  var transform = void 0;
  var transition = void 0;
  var transitionEnd = void 0;
  var hasScale3d = void 0;

  (function () {
    var el = document.createElement('_');
    var style = el.style;

    if (style.webkitTransition === '') {
      transitionEnd = 'webkitTransitionEnd';
      transition = 'webkitTransition';
    }

    if (style.transition === '') {
      transitionEnd = 'transitionend';
      transition = 'transition';
    }

    if (style.webkitTransform === '') {
      transform = 'webkitTransform';
    }

    if (style.msTransform === '') {
      transform = 'msTransform';
    }

    if (style.transform === '') {
      transform = 'transform';
    }

    document.body.insertBefore(el, null);
    style[transform] = 'translate3d(0, 0, 0)';
    hasScale3d = !!global.getComputedStyle(el).getPropertyValue(transform);
    document.body.removeChild(el);
  })();

  return {
    transform: transform,
    transition: transition,
    transitionEnd: transitionEnd,
    hasScale3d: hasScale3d
  };
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});


/**
 * dispatch custom events
 */

var eventDispatcher = function eventDispatcher() {
  var events = {};

  /**
   * Register a handler for event, to be fired
   * for every event.
   */
  var on = function on(eventName, handler) {
    events[eventName] = events[eventName] || [];
    events[eventName].push(handler);
    return undefined;
  };

  /**
   * Deregister a handler for event.
   */
  var off = function off(eventName, handler) {
    if (events[eventName]) {
      for (var i = 0; i < events[eventName].length; i += 1) {
        if (events[eventName][i] === handler) {
          events[eventName].splice(i, 1);
          break;
        }
      }
    }
  };

  var dispatch = function dispatch(eventName, data) {
    if (events[eventName]) {
      events[eventName].forEach(function (fn) {
        fn(data);
      });
    }
  };

  return {
    on: on,
    off: off,
    dispatch: dispatch
  };
};

exports.default = eventDispatcher;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drag = exports.sanitizeOffset = undefined;

var _handlePinch = __webpack_require__(0);

var calcMax = function calcMax(el, differ, zoomFactor) {
  return {
    maxX: (zoomFactor - differ) * (0, _handlePinch.getParentX)(el),
    maxY: (zoomFactor - differ) * (0, _handlePinch.getParentY)(el)
  };
};

var sanitizeOffset = exports.sanitizeOffset = function sanitizeOffset(el, offset, zoomFactor) {
  var _calcMax = calcMax(el, 1, zoomFactor),
      maxX = _calcMax.maxX,
      maxY = _calcMax.maxY;

  var maxOffsetX = Math.max(maxX, 0);
  var maxOffsetY = Math.max(maxY, 0);
  var minOffsetX = Math.min(maxX, 0);
  var minOffsetY = Math.min(maxY, 0);

  return {
    x: Math.min(Math.max(offset.x, minOffsetX), maxOffsetX),
    y: Math.min(Math.max(offset.y, minOffsetY), maxOffsetY)
  };
};

var drag = exports.drag = function drag(center, lastCenter, lastOffset, zoomFactor) {
  return Object.prototype.hasOwnProperty.call(lastCenter, 'x') ? (0, _handlePinch.addOffset)(lastOffset, {
    x: -((center.x - lastCenter.x) * zoomFactor / zoomFactor),
    y: -((center.y - lastCenter.y) * zoomFactor / zoomFactor)
  }) : lastOffset;
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _detectPrefixes = __webpack_require__(9);

var _detectPrefixes2 = _interopRequireDefault(_detectPrefixes);

var _handlePinch = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var prefixes = (0, _detectPrefixes2.default)();

var handleAnimation = function handleAnimation(el, transition, duration, ease) {
  var style = el.style;

  style.transformOrigin = '0% 0%';
  style[transition + 'TimingFunction'] = ease;
  style[transition + 'Duration'] = duration + 'ms';
};

/**
 * scaleElement -transdorms to a given position in a given time in milliseconds
 *
 * @param { Object } el element from the events
 * @param { Number } pinch number where to scale to
 * @param { Object } coords object where to translate to
 * @param { Number } duration time in milliseconds for the transistion
 * @param { String } ease easing css property
 * @return { Void }
 */

exports.default = function (el, pinch, coords, duration, ease) {
  var transition = prefixes.transition,
      transform = prefixes.transform,
      hasScale3d = prefixes.hasScale3d;
  var style = el.style;


  var zoomFactor = (0, _handlePinch.getInitialScale)(el) * pinch;

  var offsetX = -coords.x;
  var offsetY = -coords.y;

  handleAnimation(el, transition, duration, ease);
  var scaleProp = hasScale3d ? 'scale3d(' + zoomFactor + ', ' + zoomFactor + ', 1)' : 'scale(' + zoomFactor + ', ' + zoomFactor + ')';
  var translateProp = 'translate(' + offsetX + 'px, ' + offsetY + 'px)';

  style[transform] = translateProp + ' ' + scaleProp;
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(14)();
// imports


// module
exports.push([module.i, "/**\n * prism.js default theme for JavaScript, CSS and HTML\n * Based on dabblet (http://dabblet.com)\n * @author Lea Verou\n */\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n\tcolor: black;\n\tbackground: none;\n\ttext-shadow: 0 1px white;\n\tfont-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;\n\ttext-align: left;\n\twhite-space: pre;\n\tword-spacing: normal;\n\tword-break: normal;\n\tword-wrap: normal;\n\tline-height: 1.5;\n\n\t-moz-tab-size: 4;\n\t-o-tab-size: 4;\n\ttab-size: 4;\n\n\t-webkit-hyphens: none;\n\t-moz-hyphens: none;\n\t-ms-hyphens: none;\n\thyphens: none;\n}\n\npre[class*=\"language-\"]::-moz-selection, pre[class*=\"language-\"] ::-moz-selection,\ncode[class*=\"language-\"]::-moz-selection, code[class*=\"language-\"] ::-moz-selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\npre[class*=\"language-\"]::selection, pre[class*=\"language-\"] ::selection,\ncode[class*=\"language-\"]::selection, code[class*=\"language-\"] ::selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\n@media print {\n\tcode[class*=\"language-\"],\n\tpre[class*=\"language-\"] {\n\t\ttext-shadow: none;\n\t}\n}\n\n/* Code blocks */\npre[class*=\"language-\"] {\n\tpadding: 1em;\n\tmargin: .5em 0;\n\toverflow: auto;\n}\n\n:not(pre) > code[class*=\"language-\"],\npre[class*=\"language-\"] {\n\tbackground: #f5f2f0;\n}\n\n/* Inline code */\n:not(pre) > code[class*=\"language-\"] {\n\tpadding: .1em;\n\tborder-radius: .3em;\n\twhite-space: normal;\n}\n\n.token.comment,\n.token.prolog,\n.token.doctype,\n.token.cdata {\n\tcolor: slategray;\n}\n\n.token.punctuation {\n\tcolor: #999;\n}\n\n.namespace {\n\topacity: .7;\n}\n\n.token.property,\n.token.tag,\n.token.boolean,\n.token.number,\n.token.constant,\n.token.symbol,\n.token.deleted {\n\tcolor: #905;\n}\n\n.token.selector,\n.token.attr-name,\n.token.string,\n.token.char,\n.token.builtin,\n.token.inserted {\n\tcolor: #690;\n}\n\n.token.operator,\n.token.entity,\n.token.url,\n.language-css .token.string,\n.style .token.string {\n\tcolor: #a67f59;\n\tbackground: hsla(0, 0%, 100%, .5);\n}\n\n.token.atrule,\n.token.attr-value,\n.token.keyword {\n\tcolor: #07a;\n}\n\n.token.function {\n\tcolor: #DD4A68;\n}\n\n.token.regex,\n.token.important,\n.token.variable {\n\tcolor: #e90;\n}\n\n.token.important,\n.token.bold {\n\tfont-weight: bold;\n}\n.token.italic {\n\tfont-style: italic;\n}\n\n.token.entity {\n\tcursor: help;\n}\n", ""]);

// exports


/***/ }),
/* 14 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function() {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		var result = [];
		for(var i = 0; i < this.length; i++) {
			var item = this[i];
			if(item[2]) {
				result.push("@media " + item[2] + "{" + item[1] + "}");
			} else {
				result.push(item[1]);
			}
		}
		return result.join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
	}),
	getHeadElement = memoize(function () {
		return document.head || document.getElementsByTagName("head")[0];
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [];

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the bottom of <head>.
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
}

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var head = getHeadElement();
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			head.insertBefore(styleElement, head.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			head.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		head.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	styleElement.type = "text/css";
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	linkElement.rel = "stylesheet";
	insertStyleElement(options, linkElement);
	return linkElement;
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _prismjs = __webpack_require__(5);

var _prismjs2 = _interopRequireDefault(_prismjs);

__webpack_require__(6);

var _handleEvent = __webpack_require__(3);

var _handleEvent2 = _interopRequireDefault(_handleEvent);

var _src = __webpack_require__(4);

var _src2 = _interopRequireDefault(_src);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _src2.default)('.example-one img');
(0, _src2.default)('.example-two img');
(0, _src2.default)('.example-tree img', {
  maxScale: 4,
  minScale: 0.5,
  snapBackSpeed: 500
});

var pinchImage = (0, _src2.default)('.example-four img', {
  snapBackSpeed: 1000
});

document.querySelector('.reset-button').addEventListener('click', function () {
  pinchImage.reset();
});

var target = document.querySelector('.event-target');
var handleEventExample = (0, _handleEvent2.default)(target);
var pinchEvent = (0, _src2.default)('.example-five img', {
  snapBackSpeed: 1000
});

pinchEvent.on('touchstart', handleEventExample);
pinchEvent.on('touchmove', handleEventExample);

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYmQwYzZhNjZlNWIzMWViOTM1ZmQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2hhbmRsZS1waW5jaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvaGFuZGxlLWV2ZW50LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vZG9jcy9oYW5kbGUtZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcHJpc21qcy9wcmlzbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaXNtanMvdGhlbWVzL3ByaXNtLmNzcz82ODBkIiwid2VicGFjazovLy8uL3NyYy9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGluY2gtaXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2RldGVjdC1wcmVmaXhlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvZGlzcGF0Y2gtZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2hhbmRsZS1kcmFnLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9oYW5kbGUtZWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaXNtanMvdGhlbWVzL3ByaXNtLmNzcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9kb2NzL2FwcC5qcyJdLCJuYW1lcyI6WyJzdW0iLCJhY2MiLCJuZXh0IiwiZ2V0VmVjdG9yQXZnIiwidmVjdG9ycyIsIngiLCJtYXAiLCJ2IiwicmVkdWNlIiwibGVuZ3RoIiwieSIsImdldFBhcmVudEVsZW1lbnQiLCJ0eXBlIiwiZWwiLCJIVE1MSW1hZ2VFbGVtZW50IiwicGFyZW50RWxlbWVudCIsIkhUTUxEaXZFbGVtZW50IiwiaXNXaXRoaW4iLCJzY2FsZSIsIm9wdHMiLCJtYXhTY2FsZSIsIm1pblNjYWxlIiwiYWRkT2Zmc2V0IiwibGFzdE9mZnNldCIsIm9mZnNldCIsImdldFBhcmVudFgiLCJnZXRQYXJlbnRZIiwiZ2V0SW5pdGlhbFNjYWxlIiwib2Zmc2V0V2lkdGgiLCJzY2FsZUZhY3RvciIsImZhY3RvciIsIm9yaWdpbmFsRmFjdG9yIiwiem9vbUZhY3RvciIsIm1heFNjYWxlVGltZXMiLCJtaW5TY2FsZVRpbWVzIiwiTWF0aCIsIm1pbiIsIm1heCIsImdldEN1cnJlbnRQaW5jaENlbnRlciIsIm9mZnNldExlZnQiLCJvZmZzZXRSaWdodCIsIndpZHRoT2Zmc2V0UmF0aW8iLCJjZW50ZXJYIiwiaGVpZ2h0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0Qm90dG9tIiwiaGVpZ2h0T2Zmc2V0UmF0aW8iLCJjZW50ZXJZIiwiZ2V0VG91Y2hDZW50ZXIiLCJ0b3VjaGVzIiwiY2FsY1NjYWxlIiwic3RhcnRUb3VjaCIsImVuZFRvdWNoIiwiY2FsY05ld1NjYWxlIiwidG8iLCJsYXN0U2NhbGUiLCJsYXN0VG91Y2hTdGFydCIsImNhbmNlbEV2ZW50IiwiZSIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiZGV0ZWN0RG91YmxlVGFwIiwidGltZSIsIkRhdGUiLCJnZXRUaW1lIiwiZXZlbnQiLCJnZXRUb3VjaGVzIiwicG9zaXRpb24iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3VjaCIsInBhZ2VYIiwibGVmdCIsImRvY3VtZW50IiwiYm9keSIsInNjcm9sbExlZnQiLCJwYWdlWSIsInRvcCIsInNjcm9sbFRvcCIsImdldERpc3RhbmNlIiwiZmlyc3QiLCJzZWNvbmQiLCJzcXJ0IiwibmV3U3BhbiIsImNyZWF0ZUVsZW1lbnQiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwibmV3Q29udGVudCIsImNyZWF0ZVRleHROb2RlIiwiYXBwZW5kQ2hpbGQiLCJ0YXJnZXQiLCJiYXNlU2NhbGUiLCJzbmFwQmFja1NwZWVkIiwiZWFzZSIsIml0ZW1zIiwicGluY2hJdCIsInRhcmdldHMiLCJvcHRpb25zIiwiZWxlbWVudHMiLCJzY2FsaW5nIiwic3RhcnRUb3VjaGVzIiwibGFzdFpvb21DZW50ZXIiLCJsYXN0RHJhZ1Bvc2l0aW9uIiwib24iLCJkaXNwYXRjaCIsImRpc3BhdGNoUGluY2hFdmVudCIsImV2ZW50TmFtZSIsInBoYXNlIiwiZGF0YSIsIk9iamVjdCIsImFzc2lnbiIsInJlc2V0R2xvYmFscyIsIm9uVG91Y2hzdGFydCIsIkFycmF5IiwiZnJvbSIsIm9uVG91Y2htb3ZlIiwiZHJhZ09mZnNldCIsInRvdWNoQ2VudGVyIiwibmV3U2NhbGUiLCJvblRvdWNoZW5kIiwiaXNMZXNzVGhhbiIsImF0dGFjaEV2ZW50cyIsImFkZEV2ZW50TGlzdGVuZXIiLCJkZXRhY2hoRXZlbnRzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlc2V0Iiwib3B0IiwiaXRlbSIsImVhc2luZyIsImlzTmFOIiwiZm9yRWFjaCIsImRlc3Ryb3kiLCJzZXR1cCIsImlzQXJyYXkiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY29uc29sZSIsIndhcm4iLCJ0cmFuc2Zvcm0iLCJ0cmFuc2l0aW9uIiwidHJhbnNpdGlvbkVuZCIsImhhc1NjYWxlM2QiLCJzdHlsZSIsIndlYmtpdFRyYW5zaXRpb24iLCJ3ZWJraXRUcmFuc2Zvcm0iLCJtc1RyYW5zZm9ybSIsImluc2VydEJlZm9yZSIsImdsb2JhbCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicmVtb3ZlQ2hpbGQiLCJldmVudERpc3BhdGNoZXIiLCJldmVudHMiLCJoYW5kbGVyIiwicHVzaCIsIm9mZiIsImkiLCJzcGxpY2UiLCJmbiIsImNhbGNNYXgiLCJkaWZmZXIiLCJtYXhYIiwibWF4WSIsInNhbml0aXplT2Zmc2V0IiwibWF4T2Zmc2V0WCIsIm1heE9mZnNldFkiLCJtaW5PZmZzZXRYIiwibWluT2Zmc2V0WSIsImRyYWciLCJjZW50ZXIiLCJsYXN0Q2VudGVyIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwicHJlZml4ZXMiLCJoYW5kbGVBbmltYXRpb24iLCJkdXJhdGlvbiIsInRyYW5zZm9ybU9yaWdpbiIsInBpbmNoIiwiY29vcmRzIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJzY2FsZVByb3AiLCJ0cmFuc2xhdGVQcm9wIiwicGluY2hJbWFnZSIsInF1ZXJ5U2VsZWN0b3IiLCJoYW5kbGVFdmVudEV4YW1wbGUiLCJwaW5jaEV2ZW50Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDOURBOztBQUVBLElBQU1BLE1BQU0sU0FBTkEsR0FBTSxDQUFDQyxHQUFELEVBQU1DLElBQU47QUFBQSxTQUFlRCxNQUFNQyxJQUFyQjtBQUFBLENBQVo7O0FBRUE7Ozs7O0FBR0EsSUFBTUMsZUFBZSxTQUFmQSxZQUFlLENBQUNDLE9BQUQ7QUFBQSxTQUFxQztBQUN4REMsT0FBR0QsUUFBUUUsR0FBUixDQUFZO0FBQUEsYUFBTUMsRUFBRUYsQ0FBUjtBQUFBLEtBQVosRUFBd0JHLE1BQXhCLENBQStCUixHQUEvQixJQUFzQ0ksUUFBUUssTUFETztBQUV4REMsT0FBR04sUUFBUUUsR0FBUixDQUFZO0FBQUEs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QTtBQUNBLHdDQUF3Qyx3QkFBd0IsRUFBRTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNB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QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDclBBOzs7O0FBQ0E7O0FBRUE7Ozs7QUFDQTs7Ozs7O0FBRUEsbUJBQVEsa0JBQVI7QUFDQSxtQkFBUSxrQkFBUjtBQUNBLG1CQUFRLG1CQUFSLEVBQTZCO0FBQzNCbEssWUFBVSxDQURpQjtBQUUzQkMsWUFBVSxHQUZpQjtBQUczQndFLGlCQUFlO0FBSFksQ0FBN0I7O0FBTUEsSUFBTTJGLGFBQWEsbUJBQVEsbUJBQVIsRUFBNkI7QUFDOUMzRixpQkFBZTtBQUQrQixDQUE3QixDQUFuQjs7QUFJQXJCLFNBQ0dpSCxhQURILENBQ2lCLGVBRGpCLEVBRUc5RCxnQkFGSCxDQUVvQixPQUZwQixFQUU2QixZQUFNO0FBQy9CNkQsYUFBVzFELEtBQVg7QUFDRCxDQUpIOztBQU1BLElBQU1uQyxTQUFTbkIsU0FBU2lILGFBQVQsQ0FBdUIsZUFBdkIsQ0FBZjtBQUNBLElBQU1DLHFCQUFxQiwyQkFBWS9GLE1BQVosQ0FBM0I7QUFDQSxJQUFNZ0csYUFBYSxtQkFBUSxtQkFBUixFQUE2QjtBQUM5QzlGLGlCQUFlO0FBRCtCLENBQTdCLENBQW5COztBQUlBOEYsV0FBV25GLEVBQVgsQ0FBYyxZQUFkLEVBQTRCa0Ysa0JBQTVCO0FBQ0FDLFdBQVduRixFQUFYLENBQWMsV0FBZCxFQUEyQmtGLGtCQUEzQixFIiwiZmlsZSI6ImJ1bmRsZS5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvanMvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTYpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGJkMGM2YTY2ZTViMzFlYjkzNWZkIiwiLy8gQGZsb3dcblxuaW1wb3J0IHsgZ2V0RGlzdGFuY2UsIGdldFRvdWNoZXMgfSBmcm9tICcuL2hhbmRsZS1ldmVudCc7XG5cbmNvbnN0IHN1bSA9IChhY2MsIG5leHQpID0+IGFjYyArIG5leHQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYXZlcmFnZSBvZiBtdWx0aXBsZSB2ZWN0b3JzICh4LCB5IHZhbHVlcylcbiAqL1xuY29uc3QgZ2V0VmVjdG9yQXZnID0gKHZlY3RvcnM6IEFycmF5PE9iamVjdD4pOiBPYmplY3QgPT4gKHtcbiAgeDogdmVjdG9ycy5tYXAodiA9PiAodi54KSkucmVkdWNlKHN1bSkgLyB2ZWN0b3JzLmxlbmd0aCxcbiAgeTogdmVjdG9ycy5tYXAodiA9PiAodi55KSkucmVkdWNlKHN1bSkgLyB2ZWN0b3JzLmxlbmd0aCxcbn0pO1xuXG5jb25zdCBnZXRQYXJlbnRFbGVtZW50ID0gKHR5cGU6IHN0cmluZykgPT4gKGVsOiBFdmVudFRhcmdldCk6IG51bWJlciA9PiAoXG4gIChlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgJiYgZWwucGFyZW50RWxlbWVudCBpbnN0YW5jZW9mIEhUTUxEaXZFbGVtZW50KVxuICA/IGVsLnBhcmVudEVsZW1lbnRbdHlwZV1cbiAgOiAxXG4pO1xuXG4vKipcbiAqIGlzV2l0aGluIC0gQ2hlY2sgaWYgdmFsdWUgaXMgYmV0d2VlbiB0d28gdmFsdWVzXG4gKlxuICogQHBhcmFtIHsgTnVtYmVyIH0gc2NhbGUgY3VycmVudCBzY2FsZSB2YWx1ZVxuICogQHBhcmFtIHsgT2JqZWN0IH0gbWluUGluY2gsIG1heFBpbmhcbiAqIEByZXR1cm4geyBCb29sZWFuIH1cbiAqKi9cbmV4cG9ydCBjb25zdCBpc1dpdGhpbiA9IChzY2FsZTogbnVtYmVyLCBvcHRzOiBPYmplY3QpOiBib29sZWFuID0+IHtcbiAgY29uc3QgeyBtYXhTY2FsZSwgbWluU2NhbGUgfSA9IG9wdHM7XG4gIHJldHVybiAoc2NhbGUgPj0gbWluU2NhbGUpICYmIChzY2FsZSA8PSBtYXhTY2FsZSk7XG59O1xuXG4vKipcbiAqIGFkZE9mZnNldCAtIENvbWJpbmUgY3VycmVudCBvZmZzZXQgd2l0aCBvbGQgb2Zmc2V0IGFuZCByZXR1cm5zIGEgbmV3IG9mZnNldFxuICpcbiAqIEBwYXJhbSB7IE9iamVjdCB9IGxhc3RPZmZzZXQgbGFzdCBvZmZzZXRcbiAqIEBwYXJhbSB7IE9iamVjdCB9IG9mZnNldCwgbmV3IG9mZnNldFxuICogQHJldHVybiB7IE9iamVjdCB9XG4gKiovXG5leHBvcnQgY29uc3QgYWRkT2Zmc2V0ID0gKGxhc3RPZmZzZXQ6IE9iamVjdCwgb2Zmc2V0OiBPYmplY3QpOiBPYmplY3QgPT4gKHtcbiAgeDogbGFzdE9mZnNldC54ICsgb2Zmc2V0LngsXG4gIHk6IGxhc3RPZmZzZXQueSArIG9mZnNldC55LFxufSk7XG5cbmV4cG9ydCBjb25zdCBnZXRQYXJlbnRYID0gZ2V0UGFyZW50RWxlbWVudCgnb2Zmc2V0V2lkdGgnKTtcbmV4cG9ydCBjb25zdCBnZXRQYXJlbnRZID0gZ2V0UGFyZW50RWxlbWVudCgnb2Zmc2V0SGVpZ2h0Jyk7XG5cbi8qKlxuICogZ2V0U2NhbGUgLSBDaGVjayBpZiB2YWx1ZSBpcyBiZXR3ZWVuIHR3byB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0geyBOb2RlIH0gZWwgY3VycmVudCBzY2FsZSB2YWx1ZVxuICogQHJldHVybiB7IE51bWJlciB9XG4gKiovXG5leHBvcnQgY29uc3QgZ2V0SW5pdGlhbFNjYWxlID0gKGVsOiBFdmVudFRhcmdldCk6IG51bWJlciA9PiAoXG4gIChlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpXG4gID8gZ2V0UGFyZW50WChlbCkgLyBlbC5vZmZzZXRXaWR0aFxuICA6IDFcbik7XG5cbi8qKlxuICogU2NhbGVzIHRoZSB6b29tIGZhY3RvciByZWxhdGl2ZSB0byBjdXJyZW50IHN0YXRlXG4gKlxuICogQHBhcmFtIHNjYWxlXG4gKiBAcmV0dXJuIHRoZSBhY3R1YWwgc2NhbGUgKGNhbiBkaWZmZXIgYmVjYXVzZSBvZiBtYXggbWluIHpvb20gZmFjdG9yKVxuICovXG5leHBvcnQgY29uc3Qgc2NhbGVGYWN0b3IgPSAoc2NhbGU6IG51bWJlciwgZmFjdG9yOiBudW1iZXIsIG9wdHM6IE9iamVjdCk6IE9iamVjdCA9PiB7XG4gIGNvbnN0IG9yaWdpbmFsRmFjdG9yID0gZmFjdG9yO1xuICBsZXQgem9vbUZhY3RvciA9IGZhY3RvciAqIHNjYWxlO1xuICBjb25zdCB7IG1heFNjYWxlVGltZXMsIG1pblNjYWxlVGltZXMgfSA9IG9wdHM7XG4gIHpvb21GYWN0b3IgPSBNYXRoLm1pbihtYXhTY2FsZVRpbWVzLCBNYXRoLm1heCh6b29tRmFjdG9yLCBtaW5TY2FsZVRpbWVzKSk7XG4gIHJldHVybiB7XG4gICAgem9vbUZhY3RvcixcbiAgICBzY2FsZTogem9vbUZhY3RvciAvIG9yaWdpbmFsRmFjdG9yLFxuICB9O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB2aXJ0dWFsIHpvb20gY2VudGVyIGZvciB0aGUgY3VycmVudCBvZmZzZXQgYW5kIHpvb20gZmFjdG9yXG4gKiAodXNlZCBmb3IgcmV2ZXJzZSB6b29tKVxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY3VycmVudCB6b29tIGNlbnRlclxuICovXG5leHBvcnQgY29uc3QgZ2V0Q3VycmVudFBpbmNoQ2VudGVyID0gKGVsOiBFdmVudFRhcmdldCwgem9vbUZhY3RvcjogbnVtYmVyLCBvZmZzZXQ6IE9iamVjdCk6IE9iamVjdCA9PiB7XG4gIGNvbnN0IGxlbmd0aCA9IGdldFBhcmVudFgoZWwpICogem9vbUZhY3RvcjtcbiAgY29uc3Qgb2Zmc2V0TGVmdCA9IG9mZnNldC54O1xuICBjb25zdCBvZmZzZXRSaWdodCA9IGxlbmd0aCAtIG9mZnNldExlZnQgLSBnZXRQYXJlbnRYKGVsKTtcbiAgY29uc3Qgd2lkdGhPZmZzZXRSYXRpbyA9IG9mZnNldExlZnQgLyBvZmZzZXRSaWdodDtcbiAgbGV0IGNlbnRlclggPSAod2lkdGhPZmZzZXRSYXRpbyAqIGdldFBhcmVudFgoZWwpKSAvICh3aWR0aE9mZnNldFJhdGlvICsgMSk7XG5cbiAgLy8gdGhlIHNhbWUgZm9yIHRoZSB6b29tY2VudGVyIHlcbiAgY29uc3QgaGVpZ2h0ID0gZ2V0UGFyZW50WShlbCkgKiB6b29tRmFjdG9yO1xuICBjb25zdCBvZmZzZXRUb3AgPSBvZmZzZXQueTtcbiAgY29uc3Qgb2Zmc2V0Qm90dG9tID0gaGVpZ2h0IC0gb2Zmc2V0VG9wIC0gZ2V0UGFyZW50WShlbCk7XG4gIGNvbnN0IGhlaWdodE9mZnNldFJhdGlvID0gb2Zmc2V0VG9wIC8gb2Zmc2V0Qm90dG9tO1xuICBsZXQgY2VudGVyWSA9IChoZWlnaHRPZmZzZXRSYXRpbyAqIGdldFBhcmVudFkoZWwpKSAvIChoZWlnaHRPZmZzZXRSYXRpbyArIDEpO1xuXG4gIC8vIHByZXZlbnRzIGRpdmlzaW9uIGJ5IHplcm9cbiAgaWYgKG9mZnNldFJpZ2h0ID09PSAwKSB7IGNlbnRlclggPSBnZXRQYXJlbnRYKGVsKTsgfVxuICBpZiAob2Zmc2V0Qm90dG9tID09PSAwKSB7IGNlbnRlclkgPSBnZXRQYXJlbnRZKGVsKTsgfVxuXG4gIHJldHVybiB7XG4gICAgeDogY2VudGVyWCxcbiAgICB5OiBjZW50ZXJZLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFRvdWNoQ2VudGVyID0gKHRvdWNoZXM6IEFycmF5PE9iamVjdD4pID0+IGdldFZlY3RvckF2Zyh0b3VjaGVzKTtcblxuLyoqXG4gKiBjYWxjU2NhbGUgLSBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gd2hlcmUgd2Ugc3RhcnQgb3VyIHBpbmNoXG4gKiB0byB3aGVyZSB3ZSBlbmQgaXRcbiAqXG4gKiBAcGFyYW0geyBBcnJheSB9IHN0YXJ0VG91Y2ggVGhlIHN0YXJ0aW5nIHBvaW50IG9mIG91ciB0b3VjaFxuICogQHBhcmFtIHsgQXJyYXkgfSBlbmRUb3VjaCBUaGUgY3VycmVudCBwb2ludCBvZiBvdXIgdG91Y2hcbiAqIEByZXR1cm4geyBOdW1iZXIgfVxuICovXG5leHBvcnQgY29uc3QgY2FsY1NjYWxlID0gKGVsOiBFdmVudFRhcmdldCwgc3RhcnRUb3VjaDogQXJyYXk8T2JqZWN0PiwgZW5kVG91Y2g6IEFycmF5PE9iamVjdD4pOiBudW1iZXIgPT4gKFxuICBnZXREaXN0YW5jZShnZXRUb3VjaGVzKGVsLCBlbmRUb3VjaCkpIC8gZ2V0RGlzdGFuY2UoZ2V0VG91Y2hlcyhlbCwgc3RhcnRUb3VjaCkpXG4pO1xuXG5leHBvcnQgY29uc3QgY2FsY05ld1NjYWxlID0gKHRvOiBudW1iZXIsIGxhc3RTY2FsZTogbnVtYmVyID0gMSk6IG51bWJlciA9PiAoXG4gIHRvIC8gbGFzdFNjYWxlXG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL2hhbmRsZS1waW5jaC5qcyIsIi8vIEBmbG93XG5sZXQgbGFzdFRvdWNoU3RhcnQgPSAwO1xuXG50eXBlIFRvY2hQYWdlID0ge1xuICBwYWdlWDogbnVtYmVyO1xuICBwYWdlWTogbnVtYmVyO1xufVxuXG50eXBlIFRvdWNoID0ge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbn07XG5cbi8qKlxuICogY2FuY2VsRXZlbnQgLSBDYW5jZWwgRXZlbnRzIHNvIHdlIGRvbnQgYnViYmxlIHVwIG91ciBldmVudHMgdG8gdGhlIGRvY3VtZW50XG4gKlxuICogQHBhcmFtIHsgT2JqZWN0IH0gZXZlbnRcbiAqIEByZXR1cm4geyBWb2lkIH1cbiAqKi9cbmV4cG9ydCBjb25zdCBjYW5jZWxFdmVudCA9IChlOiBFdmVudCk6IHZvaWQgPT4ge1xuICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG59O1xuXG4vKipcbiAqIGRldGVjdERvdWJsZVRhcCAtIENoZWNrIGlmIHdlIGFyZSBkb3VibGUgdGFwcGluZ1xuICpcbiAqIEBwYXJhbSB7IE9iamVjdCB9IGV2ZW50XG4gKiBAcmV0dXJuIHsgQm9vbGVhbiB9XG4gKiovXG5leHBvcnQgY29uc3QgZGV0ZWN0RG91YmxlVGFwID0gKGU6IFRvdWNoRXZlbnQpOiBib29sZWFuID0+IHtcbiAgY29uc3QgdGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgbGFzdFRvdWNoU3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHRpbWUgLSBsYXN0VG91Y2hTdGFydCA8IDMwMCkge1xuICAgIGNhbmNlbEV2ZW50KGV2ZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgbGFzdFRvdWNoU3RhcnQgPSB0aW1lO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdG91Y2hlcyBvZiBhbiBldmVudCByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIG9mZnNldFxuICpcbiAqIEBwYXJhbSBldmVudFxuICogQHJldHVybiBhcnJheSB0b3VjaGVzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUb3VjaGVzID0gKGVsOiBFdmVudFRhcmdldCwgdG91Y2hlczogQXJyYXk8VG9jaFBhZ2U+KTogQXJyYXk8VG91Y2g+ID0+IHtcbiAgY29uc3QgcG9zaXRpb24gPSBlbC5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gdG91Y2hlcy5tYXAodG91Y2ggPT4gKHtcbiAgICB4OiB0b3VjaC5wYWdlWCAtIChwb3NpdGlvbi5sZWZ0ICsgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KSxcbiAgICB5OiB0b3VjaC5wYWdlWSAtIChwb3NpdGlvbi50b3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCksXG4gIH0pKTtcbn07XG5cbi8qKlxuICogZ2V0RGlzdGFuY2UgLSBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gb3VyIGZpbmdlcnNcbiAqXG4gKiBAcGFyYW0geyBBcnJheSB9IHRvdWNoZXMgdG91Y2hlcyBwYXNzYXMgYW4gYXJyYXkgZnJvbSBUb3VjaExpc3RcbiAqIEByZXR1cm4geyBOdW1iZXIgfSB0aGUgY2FsY3VhbHRlZCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBmaW5nZXJzXG4gKiovXG5leHBvcnQgY29uc3QgZ2V0RGlzdGFuY2UgPSAodG91Y2hlczogQXJyYXk8VG91Y2g+KTogbnVtYmVyID0+IHtcbiAgY29uc3QgW2ZpcnN0LCBzZWNvbmRdID0gdG91Y2hlcztcbiAgcmV0dXJuIE1hdGguc3FydChcbiAgICAoKGZpcnN0LnggLSBzZWNvbmQueCkgKiAoZmlyc3QueCAtIHNlY29uZC54KSkgK1xuICAgICgoZmlyc3QueSAtIHNlY29uZC55KSAqIChmaXJzdC55IC0gc2Vjb25kLnkpKVxuICApO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9oYW5kbGUtZXZlbnQuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGRlZmF1bHQgdGFyZ2V0ID0+IChlKSA9PiB7XG4gIGNvbnN0IG5ld1NwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGxldCB0aW1lID0gbmV3IERhdGUoKTtcbiAgdGltZSA9IHRpbWUuZ2V0SG91cnMoKSArICc6JyArIHRpbWUuZ2V0TWludXRlcygpICsgJzonICsgdGltZS5nZXRTZWNvbmRzKCkgKyAnLCcgKyB0aW1lLmdldE1pbGxpc2Vjb25kcygpO1xuICBjb25zdCBuZXdDb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1snICsgdGltZSArICddIEV2ZW50IGRpc3BhdGNoZWQ6IFwiJyArIGUudHlwZSArICdcIicpO1xuICBuZXdTcGFuLmFwcGVuZENoaWxkKG5ld0NvbnRlbnQpO1xuICB0YXJnZXQuYXBwZW5kQ2hpbGQobmV3U3Bhbik7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy9oYW5kbGUtZXZlbnQuanMiLCJpbXBvcnQgcGluY2hJdCBmcm9tICcuL3BpbmNoLWl0JztcblxuZXhwb3J0IGRlZmF1bHQgcGluY2hJdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyIsIlxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jb3JlLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbnZhciBfc2VsZiA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcblx0PyB3aW5kb3cgICAvLyBpZiBpbiBicm93c2VyXG5cdDogKFxuXHRcdCh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSlcblx0XHQ/IHNlbGYgLy8gaWYgaW4gd29ya2VyXG5cdFx0OiB7fSAgIC8vIGlmIGluIG5vZGUganNcblx0KTtcblxuLyoqXG4gKiBQcmlzbTogTGlnaHR3ZWlnaHQsIHJvYnVzdCwgZWxlZ2FudCBzeW50YXggaGlnaGxpZ2h0aW5nXG4gKiBNSVQgbGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC9cbiAqIEBhdXRob3IgTGVhIFZlcm91IGh0dHA6Ly9sZWEudmVyb3UubWVcbiAqL1xuXG52YXIgUHJpc20gPSAoZnVuY3Rpb24oKXtcblxuLy8gUHJpdmF0ZSBoZWxwZXIgdmFyc1xudmFyIGxhbmcgPSAvXFxibGFuZyg/OnVhZ2UpPy0oXFx3KylcXGIvaTtcbnZhciB1bmlxdWVJZCA9IDA7XG5cbnZhciBfID0gX3NlbGYuUHJpc20gPSB7XG5cdHV0aWw6IHtcblx0XHRlbmNvZGU6IGZ1bmN0aW9uICh0b2tlbnMpIHtcblx0XHRcdGlmICh0b2tlbnMgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFRva2VuKHRva2Vucy50eXBlLCBfLnV0aWwuZW5jb2RlKHRva2Vucy5jb250ZW50KSwgdG9rZW5zLmFsaWFzKTtcblx0XHRcdH0gZWxzZSBpZiAoXy51dGlsLnR5cGUodG9rZW5zKSA9PT0gJ0FycmF5Jykge1xuXHRcdFx0XHRyZXR1cm4gdG9rZW5zLm1hcChfLnV0aWwuZW5jb2RlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0b2tlbnMucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR0eXBlOiBmdW5jdGlvbiAobykge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5tYXRjaCgvXFxbb2JqZWN0IChcXHcrKVxcXS8pWzFdO1xuXHRcdH0sXG5cblx0XHRvYmpJZDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0aWYgKCFvYmpbJ19faWQnXSkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAnX19pZCcsIHsgdmFsdWU6ICsrdW5pcXVlSWQgfSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqWydfX2lkJ107XG5cdFx0fSxcblxuXHRcdC8vIERlZXAgY2xvbmUgYSBsYW5ndWFnZSBkZWZpbml0aW9uIChlLmcuIHRvIGV4dGVuZCBpdClcblx0XHRjbG9uZTogZnVuY3Rpb24gKG8pIHtcblx0XHRcdHZhciB0eXBlID0gXy51dGlsLnR5cGUobyk7XG5cblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0XHRcdHZhciBjbG9uZSA9IHt9O1xuXG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG8pIHtcblx0XHRcdFx0XHRcdGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdFx0Y2xvbmVba2V5XSA9IF8udXRpbC5jbG9uZShvW2tleV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBjbG9uZTtcblxuXHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGV4aXN0ZW5jZSBmb3IgSUU4XG5cdFx0XHRcdFx0cmV0dXJuIG8ubWFwICYmIG8ubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIF8udXRpbC5jbG9uZSh2KTsgfSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvO1xuXHRcdH1cblx0fSxcblxuXHRsYW5ndWFnZXM6IHtcblx0XHRleHRlbmQ6IGZ1bmN0aW9uIChpZCwgcmVkZWYpIHtcblx0XHRcdHZhciBsYW5nID0gXy51dGlsLmNsb25lKF8ubGFuZ3VhZ2VzW2lkXSk7XG5cblx0XHRcdGZvciAodmFyIGtleSBpbiByZWRlZikge1xuXHRcdFx0XHRsYW5nW2tleV0gPSByZWRlZltrZXldO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGFuZztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW5zZXJ0IGEgdG9rZW4gYmVmb3JlIGFub3RoZXIgdG9rZW4gaW4gYSBsYW5ndWFnZSBsaXRlcmFsXG5cdFx0ICogQXMgdGhpcyBuZWVkcyB0byByZWNyZWF0ZSB0aGUgb2JqZWN0ICh3ZSBjYW5ub3QgYWN0dWFsbHkgaW5zZXJ0IGJlZm9yZSBrZXlzIGluIG9iamVjdCBsaXRlcmFscyksXG5cdFx0ICogd2UgY2Fubm90IGp1c3QgcHJvdmlkZSBhbiBvYmplY3QsIHdlIG5lZWQgYW5vYmplY3QgYW5kIGEga2V5LlxuXHRcdCAqIEBwYXJhbSBpbnNpZGUgVGhlIGtleSAob3IgbGFuZ3VhZ2UgaWQpIG9mIHRoZSBwYXJlbnRcblx0XHQgKiBAcGFyYW0gYmVmb3JlIFRoZSBrZXkgdG8gaW5zZXJ0IGJlZm9yZS4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZnVuY3Rpb24gYXBwZW5kcyBpbnN0ZWFkLlxuXHRcdCAqIEBwYXJhbSBpbnNlcnQgT2JqZWN0IHdpdGggdGhlIGtleS92YWx1ZSBwYWlycyB0byBpbnNlcnRcblx0XHQgKiBAcGFyYW0gcm9vdCBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgYGluc2lkZWAuIElmIGVxdWFsIHRvIFByaXNtLmxhbmd1YWdlcywgaXQgY2FuIGJlIG9taXR0ZWQuXG5cdFx0ICovXG5cdFx0aW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAoaW5zaWRlLCBiZWZvcmUsIGluc2VydCwgcm9vdCkge1xuXHRcdFx0cm9vdCA9IHJvb3QgfHwgXy5sYW5ndWFnZXM7XG5cdFx0XHR2YXIgZ3JhbW1hciA9IHJvb3RbaW5zaWRlXTtcblxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuXHRcdFx0XHRpbnNlcnQgPSBhcmd1bWVudHNbMV07XG5cblx0XHRcdFx0Zm9yICh2YXIgbmV3VG9rZW4gaW4gaW5zZXJ0KSB7XG5cdFx0XHRcdFx0aWYgKGluc2VydC5oYXNPd25Qcm9wZXJ0eShuZXdUb2tlbikpIHtcblx0XHRcdFx0XHRcdGdyYW1tYXJbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZ3JhbW1hcjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJldCA9IHt9O1xuXG5cdFx0XHRmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG5cblx0XHRcdFx0aWYgKGdyYW1tYXIuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG5cblx0XHRcdFx0XHRpZiAodG9rZW4gPT0gYmVmb3JlKSB7XG5cblx0XHRcdFx0XHRcdGZvciAodmFyIG5ld1Rva2VuIGluIGluc2VydCkge1xuXG5cdFx0XHRcdFx0XHRcdGlmIChpbnNlcnQuaGFzT3duUHJvcGVydHkobmV3VG9rZW4pKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0W25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXRbdG9rZW5dID0gZ3JhbW1hclt0b2tlbl07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIHJlZmVyZW5jZXMgaW4gb3RoZXIgbGFuZ3VhZ2UgZGVmaW5pdGlvbnNcblx0XHRcdF8ubGFuZ3VhZ2VzLkRGUyhfLmxhbmd1YWdlcywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IHJvb3RbaW5zaWRlXSAmJiBrZXkgIT0gaW5zaWRlKSB7XG5cdFx0XHRcdFx0dGhpc1trZXldID0gcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHJvb3RbaW5zaWRlXSA9IHJldDtcblx0XHR9LFxuXG5cdFx0Ly8gVHJhdmVyc2UgYSBsYW5ndWFnZSBkZWZpbml0aW9uIHdpdGggRGVwdGggRmlyc3QgU2VhcmNoXG5cdFx0REZTOiBmdW5jdGlvbihvLCBjYWxsYmFjaywgdHlwZSwgdmlzaXRlZCkge1xuXHRcdFx0dmlzaXRlZCA9IHZpc2l0ZWQgfHwge307XG5cdFx0XHRmb3IgKHZhciBpIGluIG8pIHtcblx0XHRcdFx0aWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKG8sIGksIG9baV0sIHR5cGUgfHwgaSk7XG5cblx0XHRcdFx0XHRpZiAoXy51dGlsLnR5cGUob1tpXSkgPT09ICdPYmplY3QnICYmICF2aXNpdGVkW18udXRpbC5vYmpJZChvW2ldKV0pIHtcblx0XHRcdFx0XHRcdHZpc2l0ZWRbXy51dGlsLm9iaklkKG9baV0pXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRfLmxhbmd1YWdlcy5ERlMob1tpXSwgY2FsbGJhY2ssIG51bGwsIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChfLnV0aWwudHlwZShvW2ldKSA9PT0gJ0FycmF5JyAmJiAhdmlzaXRlZFtfLnV0aWwub2JqSWQob1tpXSldKSB7XG5cdFx0XHRcdFx0XHR2aXNpdGVkW18udXRpbC5vYmpJZChvW2ldKV0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0Xy5sYW5ndWFnZXMuREZTKG9baV0sIGNhbGxiYWNrLCBpLCB2aXNpdGVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdHBsdWdpbnM6IHt9LFxuXG5cdGhpZ2hsaWdodEFsbDogZnVuY3Rpb24oYXN5bmMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGVudiA9IHtcblx0XHRcdGNhbGxiYWNrOiBjYWxsYmFjayxcblx0XHRcdHNlbGVjdG9yOiAnY29kZVtjbGFzcyo9XCJsYW5ndWFnZS1cIl0sIFtjbGFzcyo9XCJsYW5ndWFnZS1cIl0gY29kZSwgY29kZVtjbGFzcyo9XCJsYW5nLVwiXSwgW2NsYXNzKj1cImxhbmctXCJdIGNvZGUnXG5cdFx0fTtcblxuXHRcdF8uaG9va3MucnVuKFwiYmVmb3JlLWhpZ2hsaWdodGFsbFwiLCBlbnYpO1xuXG5cdFx0dmFyIGVsZW1lbnRzID0gZW52LmVsZW1lbnRzIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZW52LnNlbGVjdG9yKTtcblxuXHRcdGZvciAodmFyIGk9MCwgZWxlbWVudDsgZWxlbWVudCA9IGVsZW1lbnRzW2krK107KSB7XG5cdFx0XHRfLmhpZ2hsaWdodEVsZW1lbnQoZWxlbWVudCwgYXN5bmMgPT09IHRydWUsIGVudi5jYWxsYmFjayk7XG5cdFx0fVxuXHR9LFxuXG5cdGhpZ2hsaWdodEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGFzeW5jLCBjYWxsYmFjaykge1xuXHRcdC8vIEZpbmQgbGFuZ3VhZ2Vcblx0XHR2YXIgbGFuZ3VhZ2UsIGdyYW1tYXIsIHBhcmVudCA9IGVsZW1lbnQ7XG5cblx0XHR3aGlsZSAocGFyZW50ICYmICFsYW5nLnRlc3QocGFyZW50LmNsYXNzTmFtZSkpIHtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdGxhbmd1YWdlID0gKHBhcmVudC5jbGFzc05hbWUubWF0Y2gobGFuZykgfHwgWywnJ10pWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRncmFtbWFyID0gXy5sYW5ndWFnZXNbbGFuZ3VhZ2VdO1xuXHRcdH1cblxuXHRcdC8vIFNldCBsYW5ndWFnZSBvbiB0aGUgZWxlbWVudCwgaWYgbm90IHByZXNlbnRcblx0XHRlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UobGFuZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKSArICcgbGFuZ3VhZ2UtJyArIGxhbmd1YWdlO1xuXG5cdFx0Ly8gU2V0IGxhbmd1YWdlIG9uIHRoZSBwYXJlbnQsIGZvciBzdHlsaW5nXG5cdFx0cGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXG5cdFx0aWYgKC9wcmUvaS50ZXN0KHBhcmVudC5ub2RlTmFtZSkpIHtcblx0XHRcdHBhcmVudC5jbGFzc05hbWUgPSBwYXJlbnQuY2xhc3NOYW1lLnJlcGxhY2UobGFuZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKSArICcgbGFuZ3VhZ2UtJyArIGxhbmd1YWdlO1xuXHRcdH1cblxuXHRcdHZhciBjb2RlID0gZWxlbWVudC50ZXh0Q29udGVudDtcblxuXHRcdHZhciBlbnYgPSB7XG5cdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuXHRcdFx0bGFuZ3VhZ2U6IGxhbmd1YWdlLFxuXHRcdFx0Z3JhbW1hcjogZ3JhbW1hcixcblx0XHRcdGNvZGU6IGNvZGVcblx0XHR9O1xuXG5cdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1zYW5pdHktY2hlY2snLCBlbnYpO1xuXG5cdFx0aWYgKCFlbnYuY29kZSB8fCAhZW52LmdyYW1tYXIpIHtcblx0XHRcdGlmIChlbnYuY29kZSkge1xuXHRcdFx0XHRlbnYuZWxlbWVudC50ZXh0Q29udGVudCA9IGVudi5jb2RlO1xuXHRcdFx0fVxuXHRcdFx0Xy5ob29rcy5ydW4oJ2NvbXBsZXRlJywgZW52KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWhpZ2hsaWdodCcsIGVudik7XG5cblx0XHRpZiAoYXN5bmMgJiYgX3NlbGYuV29ya2VyKSB7XG5cdFx0XHR2YXIgd29ya2VyID0gbmV3IFdvcmtlcihfLmZpbGVuYW1lKTtcblxuXHRcdFx0d29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2dCkge1xuXHRcdFx0XHRlbnYuaGlnaGxpZ2h0ZWRDb2RlID0gZXZ0LmRhdGE7XG5cblx0XHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1pbnNlcnQnLCBlbnYpO1xuXG5cdFx0XHRcdGVudi5lbGVtZW50LmlubmVySFRNTCA9IGVudi5oaWdobGlnaHRlZENvZGU7XG5cblx0XHRcdFx0Y2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChlbnYuZWxlbWVudCk7XG5cdFx0XHRcdF8uaG9va3MucnVuKCdhZnRlci1oaWdobGlnaHQnLCBlbnYpO1xuXHRcdFx0XHRfLmhvb2tzLnJ1bignY29tcGxldGUnLCBlbnYpO1xuXHRcdFx0fTtcblxuXHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdFx0bGFuZ3VhZ2U6IGVudi5sYW5ndWFnZSxcblx0XHRcdFx0Y29kZTogZW52LmNvZGUsXG5cdFx0XHRcdGltbWVkaWF0ZUNsb3NlOiB0cnVlXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZW52LmhpZ2hsaWdodGVkQ29kZSA9IF8uaGlnaGxpZ2h0KGVudi5jb2RlLCBlbnYuZ3JhbW1hciwgZW52Lmxhbmd1YWdlKTtcblxuXHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1pbnNlcnQnLCBlbnYpO1xuXG5cdFx0XHRlbnYuZWxlbWVudC5pbm5lckhUTUwgPSBlbnYuaGlnaGxpZ2h0ZWRDb2RlO1xuXG5cdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVsZW1lbnQpO1xuXG5cdFx0XHRfLmhvb2tzLnJ1bignYWZ0ZXItaGlnaGxpZ2h0JywgZW52KTtcblx0XHRcdF8uaG9va3MucnVuKCdjb21wbGV0ZScsIGVudik7XG5cdFx0fVxuXHR9LFxuXG5cdGhpZ2hsaWdodDogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG5cdFx0dmFyIHRva2VucyA9IF8udG9rZW5pemUodGV4dCwgZ3JhbW1hcik7XG5cdFx0cmV0dXJuIFRva2VuLnN0cmluZ2lmeShfLnV0aWwuZW5jb2RlKHRva2VucyksIGxhbmd1YWdlKTtcblx0fSxcblxuXHR0b2tlbml6ZTogZnVuY3Rpb24odGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcblx0XHR2YXIgVG9rZW4gPSBfLlRva2VuO1xuXG5cdFx0dmFyIHN0cmFyciA9IFt0ZXh0XTtcblxuXHRcdHZhciByZXN0ID0gZ3JhbW1hci5yZXN0O1xuXG5cdFx0aWYgKHJlc3QpIHtcblx0XHRcdGZvciAodmFyIHRva2VuIGluIHJlc3QpIHtcblx0XHRcdFx0Z3JhbW1hclt0b2tlbl0gPSByZXN0W3Rva2VuXTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsZXRlIGdyYW1tYXIucmVzdDtcblx0XHR9XG5cblx0XHR0b2tlbmxvb3A6IGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcblx0XHRcdGlmKCFncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSB8fCAhZ3JhbW1hclt0b2tlbl0pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwYXR0ZXJucyA9IGdyYW1tYXJbdG9rZW5dO1xuXHRcdFx0cGF0dGVybnMgPSAoXy51dGlsLnR5cGUocGF0dGVybnMpID09PSBcIkFycmF5XCIpID8gcGF0dGVybnMgOiBbcGF0dGVybnNdO1xuXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHBhdHRlcm5zLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHZhciBwYXR0ZXJuID0gcGF0dGVybnNbal0sXG5cdFx0XHRcdFx0aW5zaWRlID0gcGF0dGVybi5pbnNpZGUsXG5cdFx0XHRcdFx0bG9va2JlaGluZCA9ICEhcGF0dGVybi5sb29rYmVoaW5kLFxuXHRcdFx0XHRcdGdyZWVkeSA9ICEhcGF0dGVybi5ncmVlZHksXG5cdFx0XHRcdFx0bG9va2JlaGluZExlbmd0aCA9IDAsXG5cdFx0XHRcdFx0YWxpYXMgPSBwYXR0ZXJuLmFsaWFzO1xuXG5cdFx0XHRcdGlmIChncmVlZHkgJiYgIXBhdHRlcm4ucGF0dGVybi5nbG9iYWwpIHtcblx0XHRcdFx0XHQvLyBXaXRob3V0IHRoZSBnbG9iYWwgZmxhZywgbGFzdEluZGV4IHdvbid0IHdvcmtcblx0XHRcdFx0XHR2YXIgZmxhZ3MgPSBwYXR0ZXJuLnBhdHRlcm4udG9TdHJpbmcoKS5tYXRjaCgvW2ltdXldKiQvKVswXTtcblx0XHRcdFx0XHRwYXR0ZXJuLnBhdHRlcm4gPSBSZWdFeHAocGF0dGVybi5wYXR0ZXJuLnNvdXJjZSwgZmxhZ3MgKyBcImdcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXR0ZXJuID0gcGF0dGVybi5wYXR0ZXJuIHx8IHBhdHRlcm47XG5cblx0XHRcdFx0Ly8gRG9u4oCZdCBjYWNoZSBsZW5ndGggYXMgaXQgY2hhbmdlcyBkdXJpbmcgdGhlIGxvb3Bcblx0XHRcdFx0Zm9yICh2YXIgaT0wLCBwb3MgPSAwOyBpPHN0cmFyci5sZW5ndGg7IHBvcyArPSBzdHJhcnJbaV0ubGVuZ3RoLCArK2kpIHtcblxuXHRcdFx0XHRcdHZhciBzdHIgPSBzdHJhcnJbaV07XG5cblx0XHRcdFx0XHRpZiAoc3RyYXJyLmxlbmd0aCA+IHRleHQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyBTb21ldGhpbmcgd2VudCB0ZXJyaWJseSB3cm9uZywgQUJPUlQsIEFCT1JUIVxuXHRcdFx0XHRcdFx0YnJlYWsgdG9rZW5sb29wO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChzdHIgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cGF0dGVybi5sYXN0SW5kZXggPSAwO1xuXG5cdFx0XHRcdFx0dmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHN0ciksXG5cdFx0XHRcdFx0ICAgIGRlbE51bSA9IDE7XG5cblx0XHRcdFx0XHQvLyBHcmVlZHkgcGF0dGVybnMgY2FuIG92ZXJyaWRlL3JlbW92ZSB1cCB0byB0d28gcHJldmlvdXNseSBtYXRjaGVkIHRva2Vuc1xuXHRcdFx0XHRcdGlmICghbWF0Y2ggJiYgZ3JlZWR5ICYmIGkgIT0gc3RyYXJyLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRcdHBhdHRlcm4ubGFzdEluZGV4ID0gcG9zO1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGV4dCk7XG5cdFx0XHRcdFx0XHRpZiAoIW1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgZnJvbSA9IG1hdGNoLmluZGV4ICsgKGxvb2tiZWhpbmQgPyBtYXRjaFsxXS5sZW5ndGggOiAwKSxcblx0XHRcdFx0XHRcdCAgICB0byA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoLFxuXHRcdFx0XHRcdFx0ICAgIGsgPSBpLFxuXHRcdFx0XHRcdFx0ICAgIHAgPSBwb3M7XG5cblx0XHRcdFx0XHRcdGZvciAodmFyIGxlbiA9IHN0cmFyci5sZW5ndGg7IGsgPCBsZW4gJiYgcCA8IHRvOyArK2spIHtcblx0XHRcdFx0XHRcdFx0cCArPSBzdHJhcnJba10ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHQvLyBNb3ZlIHRoZSBpbmRleCBpIHRvIHRoZSBlbGVtZW50IGluIHN0cmFyciB0aGF0IGlzIGNsb3Nlc3QgdG8gZnJvbVxuXHRcdFx0XHRcdFx0XHRpZiAoZnJvbSA+PSBwKSB7XG5cdFx0XHRcdFx0XHRcdFx0KytpO1xuXHRcdFx0XHRcdFx0XHRcdHBvcyA9IHA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Lypcblx0XHRcdFx0XHRcdCAqIElmIHN0cmFycltpXSBpcyBhIFRva2VuLCB0aGVuIHRoZSBtYXRjaCBzdGFydHMgaW5zaWRlIGFub3RoZXIgVG9rZW4sIHdoaWNoIGlzIGludmFsaWRcblx0XHRcdFx0XHRcdCAqIElmIHN0cmFycltrIC0gMV0gaXMgZ3JlZWR5IHdlIGFyZSBpbiBjb25mbGljdCB3aXRoIGFub3RoZXIgZ3JlZWR5IHBhdHRlcm5cblx0XHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdFx0aWYgKHN0cmFycltpXSBpbnN0YW5jZW9mIFRva2VuIHx8IHN0cmFycltrIC0gMV0uZ3JlZWR5KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBOdW1iZXIgb2YgdG9rZW5zIHRvIGRlbGV0ZSBhbmQgcmVwbGFjZSB3aXRoIHRoZSBuZXcgbWF0Y2hcblx0XHRcdFx0XHRcdGRlbE51bSA9IGsgLSBpO1xuXHRcdFx0XHRcdFx0c3RyID0gdGV4dC5zbGljZShwb3MsIHApO1xuXHRcdFx0XHRcdFx0bWF0Y2guaW5kZXggLT0gcG9zO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICghbWF0Y2gpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmKGxvb2tiZWhpbmQpIHtcblx0XHRcdFx0XHRcdGxvb2tiZWhpbmRMZW5ndGggPSBtYXRjaFsxXS5sZW5ndGg7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGZyb20gPSBtYXRjaC5pbmRleCArIGxvb2tiZWhpbmRMZW5ndGgsXG5cdFx0XHRcdFx0ICAgIG1hdGNoID0gbWF0Y2hbMF0uc2xpY2UobG9va2JlaGluZExlbmd0aCksXG5cdFx0XHRcdFx0ICAgIHRvID0gZnJvbSArIG1hdGNoLmxlbmd0aCxcblx0XHRcdFx0XHQgICAgYmVmb3JlID0gc3RyLnNsaWNlKDAsIGZyb20pLFxuXHRcdFx0XHRcdCAgICBhZnRlciA9IHN0ci5zbGljZSh0byk7XG5cblx0XHRcdFx0XHR2YXIgYXJncyA9IFtpLCBkZWxOdW1dO1xuXG5cdFx0XHRcdFx0aWYgKGJlZm9yZSkge1xuXHRcdFx0XHRcdFx0YXJncy5wdXNoKGJlZm9yZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHdyYXBwZWQgPSBuZXcgVG9rZW4odG9rZW4sIGluc2lkZT8gXy50b2tlbml6ZShtYXRjaCwgaW5zaWRlKSA6IG1hdGNoLCBhbGlhcywgbWF0Y2gsIGdyZWVkeSk7XG5cblx0XHRcdFx0XHRhcmdzLnB1c2god3JhcHBlZCk7XG5cblx0XHRcdFx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdFx0XHRcdGFyZ3MucHVzaChhZnRlcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShzdHJhcnIsIGFyZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0cmFycjtcblx0fSxcblxuXHRob29rczoge1xuXHRcdGFsbDoge30sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGhvb2tzID0gXy5ob29rcy5hbGw7XG5cblx0XHRcdGhvb2tzW25hbWVdID0gaG9va3NbbmFtZV0gfHwgW107XG5cblx0XHRcdGhvb2tzW25hbWVdLnB1c2goY2FsbGJhY2spO1xuXHRcdH0sXG5cblx0XHRydW46IGZ1bmN0aW9uIChuYW1lLCBlbnYpIHtcblx0XHRcdHZhciBjYWxsYmFja3MgPSBfLmhvb2tzLmFsbFtuYW1lXTtcblxuXHRcdFx0aWYgKCFjYWxsYmFja3MgfHwgIWNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpPTAsIGNhbGxiYWNrOyBjYWxsYmFjayA9IGNhbGxiYWNrc1tpKytdOykge1xuXHRcdFx0XHRjYWxsYmFjayhlbnYpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxudmFyIFRva2VuID0gXy5Ub2tlbiA9IGZ1bmN0aW9uKHR5cGUsIGNvbnRlbnQsIGFsaWFzLCBtYXRjaGVkU3RyLCBncmVlZHkpIHtcblx0dGhpcy50eXBlID0gdHlwZTtcblx0dGhpcy5jb250ZW50ID0gY29udGVudDtcblx0dGhpcy5hbGlhcyA9IGFsaWFzO1xuXHQvLyBDb3B5IG9mIHRoZSBmdWxsIHN0cmluZyB0aGlzIHRva2VuIHdhcyBjcmVhdGVkIGZyb21cblx0dGhpcy5sZW5ndGggPSAobWF0Y2hlZFN0ciB8fCBcIlwiKS5sZW5ndGh8MDtcblx0dGhpcy5ncmVlZHkgPSAhIWdyZWVkeTtcbn07XG5cblRva2VuLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKG8sIGxhbmd1YWdlLCBwYXJlbnQpIHtcblx0aWYgKHR5cGVvZiBvID09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIG87XG5cdH1cblxuXHRpZiAoXy51dGlsLnR5cGUobykgPT09ICdBcnJheScpIHtcblx0XHRyZXR1cm4gby5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIFRva2VuLnN0cmluZ2lmeShlbGVtZW50LCBsYW5ndWFnZSwgbyk7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHR2YXIgZW52ID0ge1xuXHRcdHR5cGU6IG8udHlwZSxcblx0XHRjb250ZW50OiBUb2tlbi5zdHJpbmdpZnkoby5jb250ZW50LCBsYW5ndWFnZSwgcGFyZW50KSxcblx0XHR0YWc6ICdzcGFuJyxcblx0XHRjbGFzc2VzOiBbJ3Rva2VuJywgby50eXBlXSxcblx0XHRhdHRyaWJ1dGVzOiB7fSxcblx0XHRsYW5ndWFnZTogbGFuZ3VhZ2UsXG5cdFx0cGFyZW50OiBwYXJlbnRcblx0fTtcblxuXHRpZiAoZW52LnR5cGUgPT0gJ2NvbW1lbnQnKSB7XG5cdFx0ZW52LmF0dHJpYnV0ZXNbJ3NwZWxsY2hlY2snXSA9ICd0cnVlJztcblx0fVxuXG5cdGlmIChvLmFsaWFzKSB7XG5cdFx0dmFyIGFsaWFzZXMgPSBfLnV0aWwudHlwZShvLmFsaWFzKSA9PT0gJ0FycmF5JyA/IG8uYWxpYXMgOiBbby5hbGlhc107XG5cdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW52LmNsYXNzZXMsIGFsaWFzZXMpO1xuXHR9XG5cblx0Xy5ob29rcy5ydW4oJ3dyYXAnLCBlbnYpO1xuXG5cdHZhciBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoZW52LmF0dHJpYnV0ZXMpLm1hcChmdW5jdGlvbihuYW1lKSB7XG5cdFx0cmV0dXJuIG5hbWUgKyAnPVwiJyArIChlbnYuYXR0cmlidXRlc1tuYW1lXSB8fCAnJykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpICsgJ1wiJztcblx0fSkuam9pbignICcpO1xuXG5cdHJldHVybiAnPCcgKyBlbnYudGFnICsgJyBjbGFzcz1cIicgKyBlbnYuY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICsgKGF0dHJpYnV0ZXMgPyAnICcgKyBhdHRyaWJ1dGVzIDogJycpICsgJz4nICsgZW52LmNvbnRlbnQgKyAnPC8nICsgZW52LnRhZyArICc+JztcblxufTtcblxuaWYgKCFfc2VsZi5kb2N1bWVudCkge1xuXHRpZiAoIV9zZWxmLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHQvLyBpbiBOb2RlLmpzXG5cdFx0cmV0dXJuIF9zZWxmLlByaXNtO1xuXHR9XG4gXHQvLyBJbiB3b3JrZXJcblx0X3NlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGV2dCkge1xuXHRcdHZhciBtZXNzYWdlID0gSlNPTi5wYXJzZShldnQuZGF0YSksXG5cdFx0ICAgIGxhbmcgPSBtZXNzYWdlLmxhbmd1YWdlLFxuXHRcdCAgICBjb2RlID0gbWVzc2FnZS5jb2RlLFxuXHRcdCAgICBpbW1lZGlhdGVDbG9zZSA9IG1lc3NhZ2UuaW1tZWRpYXRlQ2xvc2U7XG5cblx0XHRfc2VsZi5wb3N0TWVzc2FnZShfLmhpZ2hsaWdodChjb2RlLCBfLmxhbmd1YWdlc1tsYW5nXSwgbGFuZykpO1xuXHRcdGlmIChpbW1lZGlhdGVDbG9zZSkge1xuXHRcdFx0X3NlbGYuY2xvc2UoKTtcblx0XHR9XG5cdH0sIGZhbHNlKTtcblxuXHRyZXR1cm4gX3NlbGYuUHJpc207XG59XG5cbi8vR2V0IGN1cnJlbnQgc2NyaXB0IGFuZCBoaWdobGlnaHRcbnZhciBzY3JpcHQgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0IHx8IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIikpLnBvcCgpO1xuXG5pZiAoc2NyaXB0KSB7XG5cdF8uZmlsZW5hbWUgPSBzY3JpcHQuc3JjO1xuXG5cdGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICYmICFzY3JpcHQuaGFzQXR0cmlidXRlKCdkYXRhLW1hbnVhbCcpKSB7XG5cdFx0aWYoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpIHtcblx0XHRcdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXy5oaWdobGlnaHRBbGwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoXy5oaWdobGlnaHRBbGwsIDE2KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgXy5oaWdobGlnaHRBbGwpO1xuXHRcdH1cblx0fVxufVxuXG5yZXR1cm4gX3NlbGYuUHJpc207XG5cbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IFByaXNtO1xufVxuXG4vLyBoYWNrIGZvciBjb21wb25lbnRzIHRvIHdvcmsgY29ycmVjdGx5IGluIG5vZGUuanNcbmlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuXHRnbG9iYWwuUHJpc20gPSBQcmlzbTtcbn1cblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLW1hcmt1cC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuXHQnY29tbWVudCc6IC88IS0tW1xcd1xcV10qPy0tPi8sXG5cdCdwcm9sb2cnOiAvPFxcP1tcXHdcXFddKz9cXD8+Lyxcblx0J2RvY3R5cGUnOiAvPCFET0NUWVBFW1xcd1xcV10rPz4vaSxcblx0J2NkYXRhJzogLzwhXFxbQ0RBVEFcXFtbXFx3XFxXXSo/XV0+L2ksXG5cdCd0YWcnOiB7XG5cdFx0cGF0dGVybjogLzxcXC8/KD8hXFxkKVteXFxzPlxcLz0kPF0rKD86XFxzK1teXFxzPlxcLz1dKyg/Oj0oPzooXCJ8JykoPzpcXFxcXFwxfFxcXFw/KD8hXFwxKVtcXHdcXFddKSpcXDF8W15cXHMnXCI+PV0rKSk/KSpcXHMqXFwvPz4vaSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCd0YWcnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9ePFxcLz9bXlxccz5cXC9dKy9pLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXjxcXC8/Lyxcblx0XHRcdFx0XHQnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0J2F0dHItdmFsdWUnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC89KD86KCd8XCIpW1xcd1xcV10qPyhcXDEpfFteXFxzPl0rKS9pLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiAvWz0+XCInXS9cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdwdW5jdHVhdGlvbic6IC9cXC8/Pi8sXG5cdFx0XHQnYXR0ci1uYW1lJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvW15cXHM+XFwvXSsvLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdH0sXG5cdCdlbnRpdHknOiAvJiM/W1xcZGEtel17MSw4fTsvaVxufTtcblxuLy8gUGx1Z2luIHRvIG1ha2UgZW50aXR5IHRpdGxlIHNob3cgdGhlIHJlYWwgZW50aXR5LCBpZGVhIGJ5IFJvbWFuIEtvbWFyb3ZcblByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uKGVudikge1xuXG5cdGlmIChlbnYudHlwZSA9PT0gJ2VudGl0eScpIHtcblx0XHRlbnYuYXR0cmlidXRlc1sndGl0bGUnXSA9IGVudi5jb250ZW50LnJlcGxhY2UoLyZhbXA7LywgJyYnKTtcblx0fVxufSk7XG5cblByaXNtLmxhbmd1YWdlcy54bWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLmh0bWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLm1hdGhtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMuc3ZnID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNzcy5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuY3NzID0ge1xuXHQnY29tbWVudCc6IC9cXC9cXCpbXFx3XFxXXSo/XFwqXFwvLyxcblx0J2F0cnVsZSc6IHtcblx0XHRwYXR0ZXJuOiAvQFtcXHctXSs/Lio/KDt8KD89XFxzKlxceykpL2ksXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQncnVsZSc6IC9AW1xcdy1dKy9cblx0XHRcdC8vIFNlZSByZXN0IGJlbG93XG5cdFx0fVxuXHR9LFxuXHQndXJsJzogL3VybFxcKCg/OihbXCInXSkoXFxcXCg/OlxcclxcbnxbXFx3XFxXXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMXwuKj8pXFwpL2ksXG5cdCdzZWxlY3Rvcic6IC9bXlxce1xcfVxcc11bXlxce1xcfTtdKj8oPz1cXHMqXFx7KS8sXG5cdCdzdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogLyhcInwnKShcXFxcKD86XFxyXFxufFtcXHdcXFddKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J3Byb3BlcnR5JzogLyhcXGJ8XFxCKVtcXHctXSsoPz1cXHMqOikvaSxcblx0J2ltcG9ydGFudCc6IC9cXEIhaW1wb3J0YW50XFxiL2ksXG5cdCdmdW5jdGlvbic6IC9bLWEtejAtOV0rKD89XFwoKS9pLFxuXHQncHVuY3R1YXRpb24nOiAvWygpe307Ol0vXG59O1xuXG5QcmlzbS5sYW5ndWFnZXMuY3NzWydhdHJ1bGUnXS5pbnNpZGUucmVzdCA9IFByaXNtLnV0aWwuY2xvbmUoUHJpc20ubGFuZ3VhZ2VzLmNzcyk7XG5cbmlmIChQcmlzbS5sYW5ndWFnZXMubWFya3VwKSB7XG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICd0YWcnLCB7XG5cdFx0J3N0eWxlJzoge1xuXHRcdFx0cGF0dGVybjogLyg8c3R5bGVbXFx3XFxXXSo/PilbXFx3XFxXXSo/KD89PFxcL3N0eWxlPikvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jc3MsXG5cdFx0XHRhbGlhczogJ2xhbmd1YWdlLWNzcydcblx0XHR9XG5cdH0pO1xuXHRcblx0UHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnaW5zaWRlJywgJ2F0dHItdmFsdWUnLCB7XG5cdFx0J3N0eWxlLWF0dHInOiB7XG5cdFx0XHRwYXR0ZXJuOiAvXFxzKnN0eWxlPShcInwnKS4qP1xcMS9pLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdhdHRyLW5hbWUnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogL15cXHMqc3R5bGUvaSxcblx0XHRcdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmluc2lkZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXlxccyo9XFxzKlsnXCJdfFsnXCJdXFxzKiQvLFxuXHRcdFx0XHQnYXR0ci12YWx1ZSc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvLisvaSxcblx0XHRcdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jc3Ncblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGFsaWFzOiAnbGFuZ3VhZ2UtY3NzJ1xuXHRcdH1cblx0fSwgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcpO1xufVxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNsaWtlLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5jbGlrZSA9IHtcblx0J2NvbW1lbnQnOiBbXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteXFxcXF0pXFwvXFwqW1xcd1xcV10qP1xcKlxcLy8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W15cXFxcOl0pXFwvXFwvLiovLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH1cblx0XSxcblx0J3N0cmluZyc6IHtcblx0XHRwYXR0ZXJuOiAvKFtcIiddKShcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J2NsYXNzLW5hbWUnOiB7XG5cdFx0cGF0dGVybjogLygoPzpcXGIoPzpjbGFzc3xpbnRlcmZhY2V8ZXh0ZW5kc3xpbXBsZW1lbnRzfHRyYWl0fGluc3RhbmNlb2Z8bmV3KVxccyspfCg/OmNhdGNoXFxzK1xcKCkpW2EtejAtOV9cXC5cXFxcXSsvaSxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0cHVuY3R1YXRpb246IC8oXFwufFxcXFwpL1xuXHRcdH1cblx0fSxcblx0J2tleXdvcmQnOiAvXFxiKGlmfGVsc2V8d2hpbGV8ZG98Zm9yfHJldHVybnxpbnxpbnN0YW5jZW9mfGZ1bmN0aW9ufG5ld3x0cnl8dGhyb3d8Y2F0Y2h8ZmluYWxseXxudWxsfGJyZWFrfGNvbnRpbnVlKVxcYi8sXG5cdCdib29sZWFuJzogL1xcYih0cnVlfGZhbHNlKVxcYi8sXG5cdCdmdW5jdGlvbic6IC9bYS16MC05X10rKD89XFwoKS9pLFxuXHQnbnVtYmVyJzogL1xcYi0/KD86MHhbXFxkYS1mXSt8XFxkKlxcLj9cXGQrKD86ZVsrLV0/XFxkKyk/KVxcYi9pLFxuXHQnb3BlcmF0b3InOiAvLS0/fFxcK1xcKz98IT0/PT98PD0/fD49P3w9PT89P3wmJj98XFx8XFx8P3xcXD98XFwqfFxcL3x+fFxcXnwlLyxcblx0J3B1bmN0dWF0aW9uJzogL1t7fVtcXF07KCksLjpdL1xufTtcblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWphdmFzY3JpcHQuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcblx0J2tleXdvcmQnOiAvXFxiKGFzfGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2F0Y2h8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHl8Zm9yfGZyb218ZnVuY3Rpb258Z2V0fGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c2V0fHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpXFxiLyxcblx0J251bWJlcic6IC9cXGItPygweFtcXGRBLUZhLWZdK3wwYlswMV0rfDBvWzAtN10rfFxcZCpcXC4/XFxkKyhbRWVdWystXT9cXGQrKT98TmFOfEluZmluaXR5KVxcYi8sXG5cdC8vIEFsbG93IGZvciBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMgKFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDA4NDQ0KVxuXHQnZnVuY3Rpb24nOiAvW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSooPz1cXCgpL2ksXG5cdCdvcGVyYXRvcic6IC8tLT98XFwrXFwrP3whPT89P3w8PT98Pj0/fD09Pz0/fCYmP3xcXHxcXHw/fFxcP3xcXCpcXCo/fFxcL3x+fFxcXnwlfFxcLnszfS9cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2tleXdvcmQnLCB7XG5cdCdyZWdleCc6IHtcblx0XHRwYXR0ZXJuOiAvKF58W14vXSlcXC8oPyFcXC8pKFxcWy4rP118XFxcXC58W14vXFxcXFxcclxcbl0pK1xcL1tnaW15dV17MCw1fSg/PVxccyooJHxbXFxyXFxuLC47fSldKSkvLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH1cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ3N0cmluZycsIHtcblx0J3RlbXBsYXRlLXN0cmluZyc6IHtcblx0XHRwYXR0ZXJuOiAvYCg/OlxcXFxcXFxcfFxcXFw/W15cXFxcXSkqP2AvLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdpbnRlcnBvbGF0aW9uJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvXFwkXFx7W159XStcXH0vLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbic6IHtcblx0XHRcdFx0XHRcdHBhdHRlcm46IC9eXFwkXFx7fFxcfSQvLFxuXHRcdFx0XHRcdFx0YWxpYXM6ICdwdW5jdHVhdGlvbidcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHJlc3Q6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQnc3RyaW5nJzogL1tcXHNcXFNdKy9cblx0XHR9XG5cdH1cbn0pO1xuXG5pZiAoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCkge1xuXHRQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAndGFnJywge1xuXHRcdCdzY3JpcHQnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKDxzY3JpcHRbXFx3XFxXXSo/PilbXFx3XFxXXSo/KD89PFxcL3NjcmlwdD4pL2ksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCxcblx0XHRcdGFsaWFzOiAnbGFuZ3VhZ2UtamF2YXNjcmlwdCdcblx0XHR9XG5cdH0pO1xufVxuXG5QcmlzbS5sYW5ndWFnZXMuanMgPSBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdDtcblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1maWxlLWhpZ2hsaWdodC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnIHx8ICFzZWxmLlByaXNtIHx8ICFzZWxmLmRvY3VtZW50IHx8ICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0c2VsZi5QcmlzbS5maWxlSGlnaGxpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgRXh0ZW5zaW9ucyA9IHtcblx0XHRcdCdqcyc6ICdqYXZhc2NyaXB0Jyxcblx0XHRcdCdweSc6ICdweXRob24nLFxuXHRcdFx0J3JiJzogJ3J1YnknLFxuXHRcdFx0J3BzMSc6ICdwb3dlcnNoZWxsJyxcblx0XHRcdCdwc20xJzogJ3Bvd2Vyc2hlbGwnLFxuXHRcdFx0J3NoJzogJ2Jhc2gnLFxuXHRcdFx0J2JhdCc6ICdiYXRjaCcsXG5cdFx0XHQnaCc6ICdjJyxcblx0XHRcdCd0ZXgnOiAnbGF0ZXgnXG5cdFx0fTtcblxuXHRcdGlmKEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7IC8vIENoZWNrIHRvIHByZXZlbnQgZXJyb3IgaW4gSUU4XG5cdFx0XHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwcmVbZGF0YS1zcmNdJykpLmZvckVhY2goZnVuY3Rpb24gKHByZSkge1xuXHRcdFx0XHR2YXIgc3JjID0gcHJlLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKTtcblxuXHRcdFx0XHR2YXIgbGFuZ3VhZ2UsIHBhcmVudCA9IHByZTtcblx0XHRcdFx0dmFyIGxhbmcgPSAvXFxibGFuZyg/OnVhZ2UpPy0oPyFcXCopKFxcdyspXFxiL2k7XG5cdFx0XHRcdHdoaWxlIChwYXJlbnQgJiYgIWxhbmcudGVzdChwYXJlbnQuY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHRcdGxhbmd1YWdlID0gKHByZS5jbGFzc05hbWUubWF0Y2gobGFuZykgfHwgWywgJyddKVsxXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghbGFuZ3VhZ2UpIHtcblx0XHRcdFx0XHR2YXIgZXh0ZW5zaW9uID0gKHNyYy5tYXRjaCgvXFwuKFxcdyspJC8pIHx8IFssICcnXSlbMV07XG5cdFx0XHRcdFx0bGFuZ3VhZ2UgPSBFeHRlbnNpb25zW2V4dGVuc2lvbl0gfHwgZXh0ZW5zaW9uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNvZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJyk7XG5cdFx0XHRcdGNvZGUuY2xhc3NOYW1lID0gJ2xhbmd1YWdlLScgKyBsYW5ndWFnZTtcblxuXHRcdFx0XHRwcmUudGV4dENvbnRlbnQgPSAnJztcblxuXHRcdFx0XHRjb2RlLnRleHRDb250ZW50ID0gJ0xvYWRpbmfigKYnO1xuXG5cdFx0XHRcdHByZS5hcHBlbmRDaGlsZChjb2RlKTtcblxuXHRcdFx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oJ0dFVCcsIHNyYywgdHJ1ZSk7XG5cblx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuXG5cdFx0XHRcdFx0XHRpZiAoeGhyLnN0YXR1cyA8IDQwMCAmJiB4aHIucmVzcG9uc2VUZXh0KSB7XG5cdFx0XHRcdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSB4aHIucmVzcG9uc2VUZXh0O1xuXG5cdFx0XHRcdFx0XHRcdFByaXNtLmhpZ2hsaWdodEVsZW1lbnQoY29kZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICh4aHIuc3RhdHVzID49IDQwMCkge1xuXHRcdFx0XHRcdFx0XHRjb2RlLnRleHRDb250ZW50ID0gJ+KcliBFcnJvciAnICsgeGhyLnN0YXR1cyArICcgd2hpbGUgZmV0Y2hpbmcgZmlsZTogJyArIHhoci5zdGF0dXNUZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSAn4pyWIEVycm9yOiBGaWxlIGRvZXMgbm90IGV4aXN0IG9yIGlzIGVtcHR5Jztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0eGhyLnNlbmQobnVsbCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0fTtcblxuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgc2VsZi5QcmlzbS5maWxlSGlnaGxpZ2h0KTtcblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmlzbWpzL3ByaXNtLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9wcmlzbS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3ByaXNtLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJpc20uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpc21qcy90aGVtZXMvcHJpc20uY3NzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcbiAgICogZGVmYXVsdCBzY2FsZSB0aGF0IHdpbGwgYmUgc2V0IG9uIGVsZW1lbnRcbiAgICogQG1heFBpbmNoIHtOdW1iZXJ9XG4gICAqL1xuICBiYXNlU2NhbGU6IDEsXG5cbiAgLyoqXG4gICAqIG1heCBzY2FsZSBhIG5vZGUgY2FuIHJlYWNoXG4gICAqIEBtYXhQaW5jaCB7TnVtYmVyfVxuICAgKi9cbiAgbWF4U2NhbGU6IDMsXG5cbiAgLyoqXG4gICAqIG1heCBzY2FsZSBhIG5vZGUgY2FuIHJlYWNoIGJlZm9yZSBib3VuY2luZyBiYWNrIHRvIG1heFNjYWxlXG4gICAqIEBtYXhTY2FsZVRpbWVzIHtOdW1iZXJ9XG4gICAqL1xuICBtYXhTY2FsZVRpbWVzOiA0LFxuXG4gIC8qKlxuICAgKiBtaW4gc2NhbGUgYSBub2RlIGNhbiByZWFjaFxuICAgKiBAbWluUGluY2gge051bWJlcn1cbiAgICovXG4gIG1pblNjYWxlOiAxLFxuXG4gIC8qKlxuICAgKiBtaW4gc2NhbGUgYSBub2RlIGNhbiByZWFjaCBiZWZvcmUgYm91bmNpbmcgYmFjayB0byBtaW5TY2FsZVxuICAgKiBAbWluU2NhbGVUaW1lcyB7TnVtYmVyfVxuICAgKi9cbiAgbWluU2NhbGVUaW1lczogMC44LFxuXG4gIC8qKlxuICAgKiB0aW1lIGZvciB0aGUgc25hcEJhY2sgb2YgdGhlIHBpbmNoIGlmIHRoZSBub2RlIGhhcyByZWFjaCBhYm92ZVxuICAgKiBvciBiZWxvdyBpdHMgcGluY2ggdmFsdWVcbiAgICogQHNuYXBCYWNrU3BlZWQge051bWJlcn1cbiAgICovXG4gIHNuYXBCYWNrU3BlZWQ6IDIwMCxcblxuICAvKipcbiAgICogQmFzaWMgZWFzaW5nIGZ1bmN0aW9uczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZGUvZG9jcy9XZWIvQ1NTL3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXG4gICAqIGN1YmljIGJlemllciBlYXNpbmcgZnVuY3Rpb25zOiBodHRwOi8vZWFzaW5ncy5uZXQvZGVcbiAgICogQGVhc2Uge1N0cmluZ31cbiAgICovXG4gIGVhc2U6ICdlYXNlJyxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZGVmYXVsdHMuanMiLCIvLyBAZmxvd1xuLy9cbmltcG9ydCBldmVudERpc3BhdGNoZXIgZnJvbSAnLi91dGlscy9kaXNwYXRjaC1ldmVudCc7XG5pbXBvcnQgeyBjYW5jZWxFdmVudCwgZ2V0VG91Y2hlcywgZGV0ZWN0RG91YmxlVGFwIH0gZnJvbSAnLi91dGlscy9oYW5kbGUtZXZlbnQnO1xuaW1wb3J0IHNjYWxlRWxlbWVudCBmcm9tICcuL3V0aWxzL2hhbmRsZS1lbGVtZW50JztcbmltcG9ydCB7IGlzV2l0aGluLCBjYWxjU2NhbGUsIGNhbGNOZXdTY2FsZSwgYWRkT2Zmc2V0LCBnZXRJbml0aWFsU2NhbGUsIHNjYWxlRmFjdG9yLCBnZXRUb3VjaENlbnRlciB9IGZyb20gJy4vdXRpbHMvaGFuZGxlLXBpbmNoJztcbmltcG9ydCB7IGRyYWcsIHNhbml0aXplT2Zmc2V0IH0gZnJvbSAnLi91dGlscy9oYW5kbGUtZHJhZyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9kZWZhdWx0cyc7XG5cbmNvbnN0IGZpcnN0ID0gKGl0ZW1zOiBBcnJheTxPYmplY3Q+KSA9PiBpdGVtc1swXTtcblxuY29uc3QgcGluY2hJdCA9ICh0YXJnZXRzOiBzdHJpbmcgfCBPYmplY3QsIG9wdGlvbnM6IE9iamVjdCA9IHt9KSA9PiB7XG4gIC8vIHByaXZhdGUgdmFyaWFibGUgY2FjaGVcbiAgbGV0IGVsZW1lbnRzO1xuXG4gIGxldCBzY2FsaW5nO1xuICBsZXQgbGFzdFNjYWxlID0gMTtcbiAgbGV0IHN0YXJ0VG91Y2hlcztcblxuICBsZXQgem9vbUZhY3RvciA9IDE7XG5cbiAgbGV0IG9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICBsZXQgbGFzdFpvb21DZW50ZXIgPSBmYWxzZTtcbiAgbGV0IGxhc3REcmFnUG9zaXRpb24gPSBmYWxzZTtcblxuICBjb25zdCB7IG9uLCBkaXNwYXRjaCB9ID0gZXZlbnREaXNwYXRjaGVyKCk7XG5cbiAvKipcbiAgKiAgZGlzcGF0Y2hQaW5jaEV2ZW50IC0gU2hvcnRoYW5kIG1ldGhvZCBmb3IgY3JlYXRpbmcgZXZlbnRzXG4gICpcbiAgKiAgQHBhcmFtIHsgU3RyaW5nIH0gcGhhc2VcbiAgKiAgQHBhcmFtIHsgU3RyaW5nIH0gdHlwZVxuICAqICBAcGFyYW0geyBPYmplY3QgfSBkZXRhaWxzXG4gICogIEByZXR1cm4geyBWb2lkIH1cbiAgKiovXG4gIGNvbnN0IGRpc3BhdGNoUGluY2hFdmVudCA9IChldmVudE5hbWU6IHN0cmluZywgcGhhc2U6IHN0cmluZywgZGF0YTogT2JqZWN0ID0ge30pOiB2b2lkID0+IHtcbiAgICBkaXNwYXRjaChldmVudE5hbWUsIE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgICAgcGhhc2VcbiAgICB9KSk7XG4gIH07XG5cbiAgY29uc3QgcmVzZXRHbG9iYWxzID0gKC8qIG9wdHMgKi8pOiB2b2lkID0+IHtcbiAgICBzY2FsaW5nID0gZmFsc2U7XG4gICAgbGFzdFNjYWxlID0gMTtcbiAgICBzdGFydFRvdWNoZXMgPSBudWxsO1xuICAgIHpvb21GYWN0b3IgPSAxO1xuICAgIGxhc3Rab29tQ2VudGVyID0gZmFsc2U7XG5cbiAgICBsYXN0RHJhZ1Bvc2l0aW9uID0gZmFsc2U7XG4gICAgb2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gIH07XG5cbiAgLy8gZXZlbnQgaGFuZGxpbmdcbiAgLyoqXG4gICAqIFNldCBzY2FsaW5nIGlmIHdlIGFyZSB1c2luZyBtb3JlIHRoZW4gb25lIGZpbmdlclxuICAgKiBhbmQgY2FwdHVyZXMgb3VyIGZpcnN0IHB1bmNoIHBvaW50XG4gICAqXG4gICAqIHByaXZhdGVcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gZSB0aGUgZXZlbnQgZnJvbSBvdXIgZXZlbnRsaXN0ZW5lclxuICAgKi9cbiAgY29uc3Qgb25Ub3VjaHN0YXJ0ID0gKG9wdHM6IE9iamVjdCkgPT4gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ3RvdWNoc3RhcnQnLCAnYmVmb3JlJywgZSk7XG5cblxuICAgIHNjYWxpbmcgPSAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMik7XG4gICAgc3RhcnRUb3VjaGVzID0gQXJyYXkuZnJvbShlLnRvdWNoZXMpO1xuICAgIGxhc3RTY2FsZSA9IDE7XG5cbiAgICBpZiAoZGV0ZWN0RG91YmxlVGFwKGUpKSB7XG4gICAgICBzY2FsZUVsZW1lbnQoZS50YXJnZXQsIDEsIHsgeDogMCwgeTogMCB9LCBvcHRzLnNuYXBCYWNrU3BlZWQsIG9wdHMuZWFzZSk7XG4gICAgICByZXNldEdsb2JhbHMoKTtcbiAgICB9XG5cbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ3RvdWNoc3RhcnQnLCAnYWZ0ZXInLCBlKTtcbiAgfTtcblxuICBjb25zdCBvblRvdWNobW92ZSA9IChvcHRzOiBPYmplY3QpID0+IChlOiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCd0b3VjaG1vdmUnLCAnYmVmb3JlJywgZSk7XG5cbiAgICBpZiAoKCFzY2FsaW5nIHx8ICFzdGFydFRvdWNoZXMpICYmIHpvb21GYWN0b3IgPiAxKSB7XG4gICAgICBjYW5jZWxFdmVudChlKTtcblxuICAgICAgY29uc3QgdG91Y2ggPSBmaXJzdChnZXRUb3VjaGVzKGUudGFyZ2V0LCBBcnJheS5mcm9tKGUudG91Y2hlcykpKTtcbiAgICAgIGNvbnN0IGRyYWdPZmZzZXQgPSBkcmFnKHRvdWNoLCBsYXN0RHJhZ1Bvc2l0aW9uLCBvZmZzZXQsIHpvb21GYWN0b3IpO1xuXG4gICAgICBvZmZzZXQgPSBzYW5pdGl6ZU9mZnNldChlLnRhcmdldCwgZHJhZ09mZnNldCwgem9vbUZhY3Rvcik7XG4gICAgICBsYXN0RHJhZ1Bvc2l0aW9uID0gdG91Y2g7XG4gICAgfSBlbHNlIGlmIChzY2FsaW5nICYmIHN0YXJ0VG91Y2hlcykge1xuICAgICAgY2FuY2VsRXZlbnQoZSk7XG5cbiAgICAgIC8vIGEgcmVsYXRpdmUgc2NhbGUgZmFjdG9yIGlzIHVzZWRcbiAgICAgIGNvbnN0IHRvdWNoQ2VudGVyID0gZ2V0VG91Y2hDZW50ZXIoZ2V0VG91Y2hlcyhlLnRhcmdldCwgQXJyYXkuZnJvbShlLnRvdWNoZXMpKSk7XG4gICAgICBjb25zdCBuZXdTY2FsZSA9IGNhbGNTY2FsZShlLnRhcmdldCwgc3RhcnRUb3VjaGVzLCBBcnJheS5mcm9tKGUudG91Y2hlcykpO1xuICAgICAgY29uc3Qgc2NhbGUgPSBjYWxjTmV3U2NhbGUobmV3U2NhbGUsIGxhc3RTY2FsZSk7XG5cbiAgICAgIGNvbnN0IGZhY3RvciA9IHNjYWxlRmFjdG9yKHNjYWxlLCB6b29tRmFjdG9yLCBvcHRzKTtcblxuICAgICAgb2Zmc2V0ID0gYWRkT2Zmc2V0KG9mZnNldCwge1xuICAgICAgICB4OiAoZmFjdG9yLnNjYWxlIC0gMSkgKiAodG91Y2hDZW50ZXIueCArIG9mZnNldC54KSxcbiAgICAgICAgeTogKGZhY3Rvci5zY2FsZSAtIDEpICogKHRvdWNoQ2VudGVyLnkgKyBvZmZzZXQueSlcbiAgICAgIH0pO1xuXG4gICAgICB6b29tRmFjdG9yID0gZmFjdG9yLnpvb21GYWN0b3I7XG4gICAgICBsYXN0U2NhbGUgPSBuZXdTY2FsZTtcbiAgICAgIG9mZnNldCA9IGRyYWcodG91Y2hDZW50ZXIsIGxhc3Rab29tQ2VudGVyLCBvZmZzZXQsIHpvb21GYWN0b3IpO1xuICAgICAgbGFzdFpvb21DZW50ZXIgPSB0b3VjaENlbnRlcjtcbiAgICB9XG5cbiAgICBzY2FsZUVsZW1lbnQoZS50YXJnZXQsIHpvb21GYWN0b3IsIG9mZnNldCwgMCwgb3B0cy5lYXNlKTtcblxuICAgIGRpc3BhdGNoUGluY2hFdmVudCgndG91Y2htb3ZlJywgJ2FmdGVyJywgZSk7XG4gIH07XG5cbiAgY29uc3Qgb25Ub3VjaGVuZCA9IG9wdHMgPT4gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ3RvdWNoZW5kJywgJ2JlZm9yZScsIGUpO1xuXG4gICAgbGFzdERyYWdQb3NpdGlvbiA9IGZhbHNlO1xuICAgIGxhc3Rab29tQ2VudGVyID0gZmFsc2U7XG4gICAgbGFzdFNjYWxlID0gMTtcbiAgICBpZiAoem9vbUZhY3Rvcikge1xuICAgICAgaWYgKCFpc1dpdGhpbih6b29tRmFjdG9yLCBvcHRzKSkge1xuICAgICAgICBjb25zdCBpc0xlc3NUaGFuID0gKGdldEluaXRpYWxTY2FsZShlLnRhcmdldCkgKiB6b29tRmFjdG9yIDwgb3B0cy5taW5TY2FsZSk7XG4gICAgICAgIHpvb21GYWN0b3IgPSBpc0xlc3NUaGFuID8gb3B0cy5taW5TY2FsZSA6IG9wdHMubWF4U2NhbGU7XG4gICAgICAgIG9mZnNldCA9IHNhbml0aXplT2Zmc2V0KGUudGFyZ2V0LCBvZmZzZXQsIHpvb21GYWN0b3IpO1xuICAgICAgICBzY2FsZUVsZW1lbnQoZS50YXJnZXQsIHpvb21GYWN0b3IsIG9mZnNldCwgb3B0cy5zbmFwQmFja1NwZWVkLCBvcHRzLmVhc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRpc3BhdGNoUGluY2hFdmVudCgndG91Y2hlbmQnLCAnYWZ0ZXInLCBlKTtcbiAgfTtcblxuICBjb25zdCBhdHRhY2hFdmVudHMgPSBvcHRzID0+IChlbDogSFRNTEVsZW1lbnQpID0+IHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaHN0YXJ0KG9wdHMpKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNobW92ZShvcHRzKSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoZW5kKG9wdHMpKTtcbiAgfTtcblxuICBjb25zdCBkZXRhY2hoRXZlbnRzID0gKGVsOiBPYmplY3QpID0+IHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaHN0YXJ0KTtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNobW92ZSk7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoZW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogcHVibGljXG4gICAqIHJlc2V0IGZ1bmN0aW9uOlxuICAgKiBAcGFyYW0geyBOdW1iZXIgfSBkdXJhdGlvblxuICAgKiBAcGFyYW0geyBTdHJpbmcgfSBlYXNpbmdcbiAgICogQHJldHVybiB7IFZvaWQgfVxuICAgKi9cbiAgY29uc3QgcmVzZXQgPSAob3B0OiBPYmplY3QpID0+IChpdGVtOiA/bnVtYmVyKTogdm9pZCA9PiB7XG4gICAgY29uc3QgeyBzbmFwQmFja1NwZWVkLCBlYXNpbmcgfSA9IHsuLi5kZWZhdWx0cywgLi4ub3B0fTtcblxuICAgIGlmIChpdGVtICYmICFpc05hTihpdGVtKSAmJiBlbGVtZW50c1tpdGVtXSkge1xuICAgICAgc2NhbGVFbGVtZW50KGVsZW1lbnRzW2l0ZW1dLCAxLCB7IHg6IDAsIHk6IDAgfSwgc25hcEJhY2tTcGVlZCwgZWFzaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQXJyYXkuZnJvbShlbGVtZW50cykuZm9yRWFjaChlbCA9PiAoXG4gICAgICAgIHNjYWxlRWxlbWVudChlbCwgMSwgeyB4OiAwLCB5OiAwIH0sIHNuYXBCYWNrU3BlZWQsIGVhc2luZykpXG4gICAgICApO1xuICAgIH1cblxuICAgIHJlc2V0R2xvYmFscygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBwdWJsaWNcbiAgICogZGVzdHJveSBmdW5jdGlvbjogY2FsbGVkIHRvIGdyYWNlZnVsbHkgZGVzdHJveSB0aGUgbG9yeSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHsgVm9pZCB9XG4gICAqL1xuICBjb25zdCBkZXN0cm95ID0gKCk6IHZvaWQgPT4ge1xuICAgIGRpc3BhdGNoUGluY2hFdmVudCgnZGVzdHJveScsICdiZWZvcmUnLCB7fSk7XG4gICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgIEFycmF5LmZyb20oZWxlbWVudHMpLmZvckVhY2goZGV0YWNoaEV2ZW50cyk7XG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCdkZXN0cm95JywgJ2FmdGVyJywge30pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBzZXR1cCAtIEluaXQgZnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHsgU3RyaW5nLCBPYmplY3QgfVxuICAgKiBAcmV0dXJuIHsgVm9pZCB9XG4gICAqKi9cblxuICB0eXBlIE9wdGlvbnMgPSB7XG4gICAgbWF4UGluY2g/OiBudW1iZXI7XG4gICAgbWluUGluY2g/OiBudW1iZXI7XG4gICAgc25hcEJhY2tTcGVlZD86IG51bWJlcjtcbiAgICBlYXNlPzogc3RyaW5nO1xuICB9O1xuXG4gIGNvbnN0IHNldHVwID0gKHRhcmdldDogc3RyaW5nIHwgT2JqZWN0LCBvcHQ6IE9wdGlvbnMpOiB2b2lkID0+IHtcbiAgICBpZiAoZWxlbWVudHMpIGRlc3Ryb3koKTtcbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ2luaXQnLCAnYmVmb3JlJywge30pO1xuXG4gICAgLy8gQmFzZSBjb25maWd1cmF0aW9uIGZvciB0aGUgcGluY2ggaW5zdGFuY2VcbiAgICBjb25zdCBvcHRzID0gey4uLmRlZmF1bHRzLCAuLi5vcHR9O1xuXG4gICAgLy8gcmVzb2x2ZSB0YXJnZXRcbiAgICAvLyBwaW5jaGl0IGFsbG93cyBmb3IgYm90aCBhIG5vZGUgb3IgYSBzdHJpbmcgdG8gYmUgcGFzc2VkXG4gICAgc3dpdGNoICh0eXBlb2YgdGFyZ2V0KSB7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBlbGVtZW50cyA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldCA6IFt0YXJnZXRdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnRzID0gW107XG4gICAgICAgIGNvbnNvbGUud2FybignbWlzc2luZyB0YXJnZXQsIGVpdGhlciBwYXNzIGFuIG5vZGUgb3IgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBBcnJheS5mcm9tKGVsZW1lbnRzKS5mb3JFYWNoKGF0dGFjaEV2ZW50cyhvcHRzKSk7XG5cbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ2luaXQnLCAnYWZ0ZXInLCB7fSk7XG4gIH07XG5cbiAgLy8gdHJpZ2dlciBpbml0aWFsIHNldHVwXG4gIHNldHVwKHRhcmdldHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB7XG4gICAgc2V0dXAsXG4gICAgcmVzZXQ6IHJlc2V0KG9wdGlvbnMpLFxuICAgIGRlc3Ryb3ksXG4gICAgZWxlbWVudHMsXG4gICAgb24sXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwaW5jaEl0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BpbmNoLWl0LmpzIiwiLyoqXG4gKiBEZXRlY3RpbmcgcHJlZml4ZXMgZm9yIHNhdmluZyB0aW1lIGFuZCBieXRlc1xuICovXG5leHBvcnQgZGVmYXVsdCAoKSA9PiB7XG4gIGxldCB0cmFuc2Zvcm07XG4gIGxldCB0cmFuc2l0aW9uO1xuICBsZXQgdHJhbnNpdGlvbkVuZDtcbiAgbGV0IGhhc1NjYWxlM2Q7XG5cbiAgKCgpID0+IHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ18nKTtcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuXG4gICAgaWYgKHN0eWxlLndlYmtpdFRyYW5zaXRpb24gPT09ICcnKSB7XG4gICAgICB0cmFuc2l0aW9uRW5kID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICAgICAgdHJhbnNpdGlvbiA9ICd3ZWJraXRUcmFuc2l0aW9uJztcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUudHJhbnNpdGlvbiA9PT0gJycpIHtcbiAgICAgIHRyYW5zaXRpb25FbmQgPSAndHJhbnNpdGlvbmVuZCc7XG4gICAgICB0cmFuc2l0aW9uID0gJ3RyYW5zaXRpb24nO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPT09ICcnKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAnd2Via2l0VHJhbnNmb3JtJztcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUubXNUcmFuc2Zvcm0gPT09ICcnKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAnbXNUcmFuc2Zvcm0nO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS50cmFuc2Zvcm0gPT09ICcnKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAndHJhbnNmb3JtJztcbiAgICB9XG5cbiAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShlbCwgbnVsbCk7XG4gICAgc3R5bGVbdHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSc7XG4gICAgaGFzU2NhbGUzZCA9ICEhZ2xvYmFsLmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUodHJhbnNmb3JtKTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgfSkoKTtcblxuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybSxcbiAgICB0cmFuc2l0aW9uLFxuICAgIHRyYW5zaXRpb25FbmQsXG4gICAgaGFzU2NhbGUzZFxuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9kZXRlY3QtcHJlZml4ZXMuanMiLCIvLyBAZmxvd1xuXG4vKipcbiAqIGRpc3BhdGNoIGN1c3RvbSBldmVudHNcbiAqL1xuXG5jb25zdCBldmVudERpc3BhdGNoZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGV2ZW50cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGhhbmRsZXIgZm9yIGV2ZW50LCB0byBiZSBmaXJlZFxuICAgKiBmb3IgZXZlcnkgZXZlbnQuXG4gICAqL1xuICBjb25zdCBvbiA9IChldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogRnVuY3Rpb24pID0+IHtcbiAgICBldmVudHNbZXZlbnROYW1lXSA9IGV2ZW50c1tldmVudE5hbWVdIHx8IFtdO1xuICAgIGV2ZW50c1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBoYW5kbGVyIGZvciBldmVudC5cbiAgICovXG4gIGNvbnN0IG9mZiA9IChldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogRnVuY3Rpb24pID0+IHtcbiAgICBpZiAoZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzW2V2ZW50TmFtZV0ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGV2ZW50c1tldmVudE5hbWVdW2ldID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGRpc3BhdGNoID0gKGV2ZW50TmFtZTogc3RyaW5nLCBkYXRhOiBPYmplY3QpID0+IHtcbiAgICBpZiAoZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIGV2ZW50c1tldmVudE5hbWVdLmZvckVhY2goKGZuKSA9PiB7XG4gICAgICAgIGZuKGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgb24sXG4gICAgb2ZmLFxuICAgIGRpc3BhdGNoLFxuICB9O1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBldmVudERpc3BhdGNoZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvZGlzcGF0Y2gtZXZlbnQuanMiLCIvLyBAZmxvd1xuXG5pbXBvcnQgeyBnZXRQYXJlbnRYLCBnZXRQYXJlbnRZLCBhZGRPZmZzZXQgfSBmcm9tICcuL2hhbmRsZS1waW5jaCc7XG5cbnR5cGUgQ2VudGVyID0ge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbn07XG5cbmNvbnN0IGNhbGNNYXggPSAoZWw6IEV2ZW50VGFyZ2V0LCBkaWZmZXI6IG51bWJlciwgem9vbUZhY3RvcjogbnVtYmVyKTogT2JqZWN0ID0+ICh7XG4gIG1heFg6ICh6b29tRmFjdG9yIC0gZGlmZmVyKSAqIGdldFBhcmVudFgoZWwpLFxuICBtYXhZOiAoem9vbUZhY3RvciAtIGRpZmZlcikgKiBnZXRQYXJlbnRZKGVsKSxcbn0pO1xuXG5leHBvcnQgY29uc3Qgc2FuaXRpemVPZmZzZXQgPSAoZWw6IEV2ZW50VGFyZ2V0LCBvZmZzZXQ6IENlbnRlciwgem9vbUZhY3RvcjogbnVtYmVyKTogT2JqZWN0ID0+IHtcbiAgY29uc3QgeyBtYXhYLCBtYXhZIH0gPSBjYWxjTWF4KGVsLCAxLCB6b29tRmFjdG9yKTtcbiAgY29uc3QgbWF4T2Zmc2V0WCA9IE1hdGgubWF4KG1heFgsIDApO1xuICBjb25zdCBtYXhPZmZzZXRZID0gTWF0aC5tYXgobWF4WSwgMCk7XG4gIGNvbnN0IG1pbk9mZnNldFggPSBNYXRoLm1pbihtYXhYLCAwKTtcbiAgY29uc3QgbWluT2Zmc2V0WSA9IE1hdGgubWluKG1heFksIDApO1xuXG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5taW4oTWF0aC5tYXgob2Zmc2V0LngsIG1pbk9mZnNldFgpLCBtYXhPZmZzZXRYKSxcbiAgICB5OiBNYXRoLm1pbihNYXRoLm1heChvZmZzZXQueSwgbWluT2Zmc2V0WSksIG1heE9mZnNldFkpXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZHJhZyA9IChjZW50ZXI6IENlbnRlciwgbGFzdENlbnRlcjogQ2VudGVyLCBsYXN0T2Zmc2V0OiBPYmplY3QsIHpvb21GYWN0b3I6IG51bWJlcik6IE9iamVjdCA9PiAoXG4gIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGFzdENlbnRlciwgJ3gnKSlcbiAgPyBhZGRPZmZzZXQobGFzdE9mZnNldCwge1xuICAgIHg6IC0oKChjZW50ZXIueCAtIGxhc3RDZW50ZXIueCkgKiB6b29tRmFjdG9yKSAvIHpvb21GYWN0b3IpLFxuICAgIHk6IC0oKChjZW50ZXIueSAtIGxhc3RDZW50ZXIueSkgKiB6b29tRmFjdG9yKSAvIHpvb21GYWN0b3IpLFxuICB9KVxuICA6IGxhc3RPZmZzZXRcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvaGFuZGxlLWRyYWcuanMiLCIvLyBAZmxvd1xuXG5pbXBvcnQgZGV0ZWN0UHJlZml4ZXMgZnJvbSAnLi9kZXRlY3QtcHJlZml4ZXMnO1xuaW1wb3J0IHsgZ2V0SW5pdGlhbFNjYWxlIH0gZnJvbSAnLi9oYW5kbGUtcGluY2gnO1xuXG5jb25zdCBwcmVmaXhlcyA9IGRldGVjdFByZWZpeGVzKCk7XG5cbmNvbnN0IGhhbmRsZUFuaW1hdGlvbiA9IChlbDogRXZlbnRUYXJnZXQsIHRyYW5zaXRpb246IHN0cmluZywgZHVyYXRpb246IG51bWJlciwgZWFzZTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIGNvbnN0IHsgc3R5bGUgfSA9IGVsO1xuICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCUgMCUnO1xuICBzdHlsZVtgJHt0cmFuc2l0aW9ufVRpbWluZ0Z1bmN0aW9uYF0gPSBlYXNlO1xuICBzdHlsZVtgJHt0cmFuc2l0aW9ufUR1cmF0aW9uYF0gPSBgJHtkdXJhdGlvbn1tc2A7XG59O1xuXG4vKipcbiAqIHNjYWxlRWxlbWVudCAtdHJhbnNkb3JtcyB0byBhIGdpdmVuIHBvc2l0aW9uIGluIGEgZ2l2ZW4gdGltZSBpbiBtaWxsaXNlY29uZHNcbiAqXG4gKiBAcGFyYW0geyBPYmplY3QgfSBlbCBlbGVtZW50IGZyb20gdGhlIGV2ZW50c1xuICogQHBhcmFtIHsgTnVtYmVyIH0gcGluY2ggbnVtYmVyIHdoZXJlIHRvIHNjYWxlIHRvXG4gKiBAcGFyYW0geyBPYmplY3QgfSBjb29yZHMgb2JqZWN0IHdoZXJlIHRvIHRyYW5zbGF0ZSB0b1xuICogQHBhcmFtIHsgTnVtYmVyIH0gZHVyYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2lzdGlvblxuICogQHBhcmFtIHsgU3RyaW5nIH0gZWFzZSBlYXNpbmcgY3NzIHByb3BlcnR5XG4gKiBAcmV0dXJuIHsgVm9pZCB9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgKGVsOiBFdmVudFRhcmdldCwgcGluY2g6IG51bWJlciwgY29vcmRzOiBPYmplY3QsIGR1cmF0aW9uOiBudW1iZXIsIGVhc2U6IHN0cmluZyk6IHZvaWQgPT4ge1xuICBjb25zdCB7IHRyYW5zaXRpb24sIHRyYW5zZm9ybSwgaGFzU2NhbGUzZCB9ID0gcHJlZml4ZXM7XG4gIGNvbnN0IHsgc3R5bGUgfSA9IGVsO1xuXG4gIGNvbnN0IHpvb21GYWN0b3IgPSBnZXRJbml0aWFsU2NhbGUoZWwpICogcGluY2g7XG5cbiAgY29uc3Qgb2Zmc2V0WCA9IC1jb29yZHMueDtcbiAgY29uc3Qgb2Zmc2V0WSA9IC1jb29yZHMueTtcblxuICBoYW5kbGVBbmltYXRpb24oZWwsIHRyYW5zaXRpb24sIGR1cmF0aW9uLCBlYXNlKTtcbiAgY29uc3Qgc2NhbGVQcm9wID0gKGhhc1NjYWxlM2QpXG4gICAgPyBgc2NhbGUzZCgke3pvb21GYWN0b3J9LCAke3pvb21GYWN0b3J9LCAxKWBcbiAgICA6IGBzY2FsZSgke3pvb21GYWN0b3J9LCAke3pvb21GYWN0b3J9KWA7XG4gIGNvbnN0IHRyYW5zbGF0ZVByb3AgPSBgdHJhbnNsYXRlKCR7b2Zmc2V0WH1weCwgJHtvZmZzZXRZfXB4KWA7XG5cbiAgc3R5bGVbdHJhbnNmb3JtXSA9IGAke3RyYW5zbGF0ZVByb3B9ICR7c2NhbGVQcm9wfWA7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL2hhbmRsZS1lbGVtZW50LmpzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qKlxcbiAqIHByaXNtLmpzIGRlZmF1bHQgdGhlbWUgZm9yIEphdmFTY3JpcHQsIENTUyBhbmQgSFRNTFxcbiAqIEJhc2VkIG9uIGRhYmJsZXQgKGh0dHA6Ly9kYWJibGV0LmNvbSlcXG4gKiBAYXV0aG9yIExlYSBWZXJvdVxcbiAqL1xcblxcbmNvZGVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSxcXG5wcmVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSB7XFxuXFx0Y29sb3I6IGJsYWNrO1xcblxcdGJhY2tncm91bmQ6IG5vbmU7XFxuXFx0dGV4dC1zaGFkb3c6IDAgMXB4IHdoaXRlO1xcblxcdGZvbnQtZmFtaWx5OiBDb25zb2xhcywgTW9uYWNvLCAnQW5kYWxlIE1vbm8nLCAnVWJ1bnR1IE1vbm8nLCBtb25vc3BhY2U7XFxuXFx0dGV4dC1hbGlnbjogbGVmdDtcXG5cXHR3aGl0ZS1zcGFjZTogcHJlO1xcblxcdHdvcmQtc3BhY2luZzogbm9ybWFsO1xcblxcdHdvcmQtYnJlYWs6IG5vcm1hbDtcXG5cXHR3b3JkLXdyYXA6IG5vcm1hbDtcXG5cXHRsaW5lLWhlaWdodDogMS41O1xcblxcblxcdC1tb3otdGFiLXNpemU6IDQ7XFxuXFx0LW8tdGFiLXNpemU6IDQ7XFxuXFx0dGFiLXNpemU6IDQ7XFxuXFxuXFx0LXdlYmtpdC1oeXBoZW5zOiBub25lO1xcblxcdC1tb3otaHlwaGVuczogbm9uZTtcXG5cXHQtbXMtaHlwaGVuczogbm9uZTtcXG5cXHRoeXBoZW5zOiBub25lO1xcbn1cXG5cXG5wcmVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXTo6LW1vei1zZWxlY3Rpb24sIHByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIDo6LW1vei1zZWxlY3Rpb24sXFxuY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdOjotbW96LXNlbGVjdGlvbiwgY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIDo6LW1vei1zZWxlY3Rpb24ge1xcblxcdHRleHQtc2hhZG93OiBub25lO1xcblxcdGJhY2tncm91bmQ6ICNiM2Q0ZmM7XFxufVxcblxcbnByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdOjpzZWxlY3Rpb24sIHByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIDo6c2VsZWN0aW9uLFxcbmNvZGVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXTo6c2VsZWN0aW9uLCBjb2RlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0gOjpzZWxlY3Rpb24ge1xcblxcdHRleHQtc2hhZG93OiBub25lO1xcblxcdGJhY2tncm91bmQ6ICNiM2Q0ZmM7XFxufVxcblxcbkBtZWRpYSBwcmludCB7XFxuXFx0Y29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdLFxcblxcdHByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIHtcXG5cXHRcXHR0ZXh0LXNoYWRvdzogbm9uZTtcXG5cXHR9XFxufVxcblxcbi8qIENvZGUgYmxvY2tzICovXFxucHJlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0ge1xcblxcdHBhZGRpbmc6IDFlbTtcXG5cXHRtYXJnaW46IC41ZW0gMDtcXG5cXHRvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuOm5vdChwcmUpID4gY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdLFxcbnByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIHtcXG5cXHRiYWNrZ3JvdW5kOiAjZjVmMmYwO1xcbn1cXG5cXG4vKiBJbmxpbmUgY29kZSAqL1xcbjpub3QocHJlKSA+IGNvZGVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSB7XFxuXFx0cGFkZGluZzogLjFlbTtcXG5cXHRib3JkZXItcmFkaXVzOiAuM2VtO1xcblxcdHdoaXRlLXNwYWNlOiBub3JtYWw7XFxufVxcblxcbi50b2tlbi5jb21tZW50LFxcbi50b2tlbi5wcm9sb2csXFxuLnRva2VuLmRvY3R5cGUsXFxuLnRva2VuLmNkYXRhIHtcXG5cXHRjb2xvcjogc2xhdGVncmF5O1xcbn1cXG5cXG4udG9rZW4ucHVuY3R1YXRpb24ge1xcblxcdGNvbG9yOiAjOTk5O1xcbn1cXG5cXG4ubmFtZXNwYWNlIHtcXG5cXHRvcGFjaXR5OiAuNztcXG59XFxuXFxuLnRva2VuLnByb3BlcnR5LFxcbi50b2tlbi50YWcsXFxuLnRva2VuLmJvb2xlYW4sXFxuLnRva2VuLm51bWJlcixcXG4udG9rZW4uY29uc3RhbnQsXFxuLnRva2VuLnN5bWJvbCxcXG4udG9rZW4uZGVsZXRlZCB7XFxuXFx0Y29sb3I6ICM5MDU7XFxufVxcblxcbi50b2tlbi5zZWxlY3RvcixcXG4udG9rZW4uYXR0ci1uYW1lLFxcbi50b2tlbi5zdHJpbmcsXFxuLnRva2VuLmNoYXIsXFxuLnRva2VuLmJ1aWx0aW4sXFxuLnRva2VuLmluc2VydGVkIHtcXG5cXHRjb2xvcjogIzY5MDtcXG59XFxuXFxuLnRva2VuLm9wZXJhdG9yLFxcbi50b2tlbi5lbnRpdHksXFxuLnRva2VuLnVybCxcXG4ubGFuZ3VhZ2UtY3NzIC50b2tlbi5zdHJpbmcsXFxuLnN0eWxlIC50b2tlbi5zdHJpbmcge1xcblxcdGNvbG9yOiAjYTY3ZjU5O1xcblxcdGJhY2tncm91bmQ6IGhzbGEoMCwgMCUsIDEwMCUsIC41KTtcXG59XFxuXFxuLnRva2VuLmF0cnVsZSxcXG4udG9rZW4uYXR0ci12YWx1ZSxcXG4udG9rZW4ua2V5d29yZCB7XFxuXFx0Y29sb3I6ICMwN2E7XFxufVxcblxcbi50b2tlbi5mdW5jdGlvbiB7XFxuXFx0Y29sb3I6ICNERDRBNjg7XFxufVxcblxcbi50b2tlbi5yZWdleCxcXG4udG9rZW4uaW1wb3J0YW50LFxcbi50b2tlbi52YXJpYWJsZSB7XFxuXFx0Y29sb3I6ICNlOTA7XFxufVxcblxcbi50b2tlbi5pbXBvcnRhbnQsXFxuLnRva2VuLmJvbGQge1xcblxcdGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4udG9rZW4uaXRhbGljIHtcXG5cXHRmb250LXN0eWxlOiBpdGFsaWM7XFxufVxcblxcbi50b2tlbi5lbnRpdHkge1xcblxcdGN1cnNvcjogaGVscDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3ByaXNtanMvdGhlbWVzL3ByaXNtLmNzc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cclxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXHJcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xyXG5cdFx0XHRpZihpdGVtWzJdKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHByaXNtIGZyb20gJ3ByaXNtanMnO1xuaW1wb3J0ICdwcmlzbWpzL3RoZW1lcy9wcmlzbS5jc3MnO1xuXG5pbXBvcnQgaGFuZGxlRXZlbnQgZnJvbSAnLi9oYW5kbGUtZXZlbnQnO1xuaW1wb3J0IHBpbmNoSXQgZnJvbSAnLi4vc3JjLyc7XG5cbnBpbmNoSXQoJy5leGFtcGxlLW9uZSBpbWcnKTtcbnBpbmNoSXQoJy5leGFtcGxlLXR3byBpbWcnKTtcbnBpbmNoSXQoJy5leGFtcGxlLXRyZWUgaW1nJywge1xuICBtYXhTY2FsZTogNCxcbiAgbWluU2NhbGU6IDAuNSxcbiAgc25hcEJhY2tTcGVlZDogNTAwLFxufSk7XG5cbmNvbnN0IHBpbmNoSW1hZ2UgPSBwaW5jaEl0KCcuZXhhbXBsZS1mb3VyIGltZycsIHtcbiAgc25hcEJhY2tTcGVlZDogMTAwMCxcbn0pO1xuXG5kb2N1bWVudFxuICAucXVlcnlTZWxlY3RvcignLnJlc2V0LWJ1dHRvbicpXG4gIC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBwaW5jaEltYWdlLnJlc2V0KCk7XG4gIH0pO1xuXG5jb25zdCB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZXZlbnQtdGFyZ2V0Jyk7XG5jb25zdCBoYW5kbGVFdmVudEV4YW1wbGUgPSBoYW5kbGVFdmVudCh0YXJnZXQpO1xuY29uc3QgcGluY2hFdmVudCA9IHBpbmNoSXQoJy5leGFtcGxlLWZpdmUgaW1nJywge1xuICBzbmFwQmFja1NwZWVkOiAxMDAwLFxufSk7XG5cbnBpbmNoRXZlbnQub24oJ3RvdWNoc3RhcnQnLCBoYW5kbGVFdmVudEV4YW1wbGUpO1xucGluY2hFdmVudC5vbigndG91Y2htb3ZlJywgaGFuZGxlRXZlbnRFeGFtcGxlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3MvYXBwLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==