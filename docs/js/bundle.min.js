/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 16);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var sum = function sum(acc, next) {
  return acc + next;
};

/**
 * Calculates the average of multiple vectors (x, y values)
 */
var getVectorAvg = function getVectorAvg(vectors) {
  return {
    x: vectors.map(function (v) {
      return v.x;
    }).reduce(sum) / vectors.length,
    y: vectors.map(function (v) {
      return v.y;
    }).reduce(sum) / vectors.length
  };
};

var getElement = function getElement(type) {
  return function (el) {
    return el instanceof HTMLImageElement ? el[type] : 1;
  };
};

/**
 * isWithin - Check if value is between two values
 *
 * @param { Number } scale current scale value
 * @param { Object } minPinch, maxPinh
 * @return { Boolean }
 **/
var isWithin = exports.isWithin = function isWithin(scale, opts) {
  var maxScale = opts.maxScale,
      minScale = opts.minScale;

  return scale >= minScale && scale <= maxScale;
};

/**
 * addOffset - Combine current offset with old offset and returns a new offset
 *
 * @param { Object } lastOffset last offset
 * @param { Object } offset, new offset
 * @return { Object }
 **/
var addOffset = exports.addOffset = function addOffset(lastOffset, offset) {
  return {
    x: lastOffset.x + offset.x,
    y: lastOffset.y + offset.y
  };
};

var getX = exports.getX = getElement('offsetWidth');
var getY = exports.getY = getElement('offsetHeight');

/**
 * getScale - Check if value is between two values
 *
 * @param { Node } el current scale value
 * @return { Number }
 **/
var getInitialScale = exports.getInitialScale = function getInitialScale(el, image) {
  return el instanceof HTMLImageElement ? getX(el) / image.offsetWidth : 1;
};

/**
 * Scales the zoom factor relative to current state
 *
 * @param scale
 * @return the actual scale (can differ because of max min zoom factor)
 */
var getScaleFactor = exports.getScaleFactor = function getScaleFactor(scale, factor, opts) {
  var maxScaleTimes = opts.maxScaleTimes,
      minScaleTimes = opts.minScaleTimes;

  var zoomFactor = Math.min(maxScaleTimes, Math.max(factor * scale, minScaleTimes));
  return zoomFactor / factor;
};

/**
 * Scales the zoom factor relative to current state
 *
 * @param scale
 * @return the actual scale (can differ because of max min zoom factor)
 */
var getZoomFactor = exports.getZoomFactor = function getZoomFactor(scale, factor, opts) {
  var maxScaleTimes = opts.maxScaleTimes,
      minScaleTimes = opts.minScaleTimes;

  return Math.min(maxScaleTimes, Math.max(factor * scale, minScaleTimes));
};

var getTouchCenter = exports.getTouchCenter = function getTouchCenter(touches) {
  return getVectorAvg(touches);
};

var calcNewScale = exports.calcNewScale = function calcNewScale(to) {
  var lastScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return to / lastScale;
};

/***/ }),
/* 1 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (target) {
  return function (e) {
    var newSpan = document.createElement('span');
    var time = new Date();
    time = time.getHours() + ':' + time.getMinutes() + ':' + time.getSeconds() + ',' + time.getMilliseconds();
    var newContent = document.createTextNode('[' + time + '] Event dispatched: "' + e.type + '"');
    newSpan.appendChild(newContent);
    target.appendChild(newSpan);
  };
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pinchIt = __webpack_require__(7);

var _pinchIt2 = _interopRequireDefault(_pinchIt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _pinchIt2.default;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/* **********************************************
     Begin prism-core.js
********************************************** */

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function(){

// Private helper vars
var lang = /\blang(?:uage)?-(\w+)\b/i;
var uniqueId = 0;

var _ = _self.Prism = {
	util: {
		encode: function (tokens) {
			if (tokens instanceof Token) {
				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
			} else if (_.util.type(tokens) === 'Array') {
				return tokens.map(_.util.encode);
			} else {
				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
			}
		},

		type: function (o) {
			return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
		},

		objId: function (obj) {
			if (!obj['__id']) {
				Object.defineProperty(obj, '__id', { value: ++uniqueId });
			}
			return obj['__id'];
		},

		// Deep clone a language definition (e.g. to extend it)
		clone: function (o) {
			var type = _.util.type(o);

			switch (type) {
				case 'Object':
					var clone = {};

					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = _.util.clone(o[key]);
						}
					}

					return clone;

				case 'Array':
					// Check for existence for IE8
					return o.map && o.map(function(v) { return _.util.clone(v); });
			}

			return o;
		}
	},

	languages: {
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);

			for (var key in redef) {
				lang[key] = redef[key];
			}

			return lang;
		},

		/**
		 * Insert a token before another token in a language literal
		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
		 * we cannot just provide an object, we need anobject and a key.
		 * @param inside The key (or language id) of the parent
		 * @param before The key to insert before. If not provided, the function appends instead.
		 * @param insert Object with the key/value pairs to insert
		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
		 */
		insertBefore: function (inside, before, insert, root) {
			root = root || _.languages;
			var grammar = root[inside];

			if (arguments.length == 2) {
				insert = arguments[1];

				for (var newToken in insert) {
					if (insert.hasOwnProperty(newToken)) {
						grammar[newToken] = insert[newToken];
					}
				}

				return grammar;
			}

			var ret = {};

			for (var token in grammar) {

				if (grammar.hasOwnProperty(token)) {

					if (token == before) {

						for (var newToken in insert) {

							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}

					ret[token] = grammar[token];
				}
			}

			// Update references in other language definitions
			_.languages.DFS(_.languages, function(key, value) {
				if (value === root[inside] && key != inside) {
					this[key] = ret;
				}
			});

			return root[inside] = ret;
		},

		// Traverse a language definition with Depth First Search
		DFS: function(o, callback, type, visited) {
			visited = visited || {};
			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					callback.call(o, i, o[i], type || i);

					if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, null, visited);
					}
					else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, i, visited);
					}
				}
			}
		}
	},
	plugins: {},

	highlightAll: function(async, callback) {
		var env = {
			callback: callback,
			selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
		};

		_.hooks.run("before-highlightall", env);

		var elements = env.elements || document.querySelectorAll(env.selector);

		for (var i=0, element; element = elements[i++];) {
			_.highlightElement(element, async === true, env.callback);
		}
	},

	highlightElement: function(element, async, callback) {
		// Find language
		var language, grammar, parent = element;

		while (parent && !lang.test(parent.className)) {
			parent = parent.parentNode;
		}

		if (parent) {
			language = (parent.className.match(lang) || [,''])[1].toLowerCase();
			grammar = _.languages[language];
		}

		// Set language on the element, if not present
		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

		// Set language on the parent, for styling
		parent = element.parentNode;

		if (/pre/i.test(parent.nodeName)) {
			parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
		}

		var code = element.textContent;

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};

		_.hooks.run('before-sanity-check', env);

		if (!env.code || !env.grammar) {
			if (env.code) {
				env.element.textContent = env.code;
			}
			_.hooks.run('complete', env);
			return;
		}

		_.hooks.run('before-highlight', env);

		if (async && _self.Worker) {
			var worker = new Worker(_.filename);

			worker.onmessage = function(evt) {
				env.highlightedCode = evt.data;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				callback && callback.call(env.element);
				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			};

			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code,
				immediateClose: true
			}));
		}
		else {
			env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

			_.hooks.run('before-insert', env);

			env.element.innerHTML = env.highlightedCode;

			callback && callback.call(element);

			_.hooks.run('after-highlight', env);
			_.hooks.run('complete', env);
		}
	},

	highlight: function (text, grammar, language) {
		var tokens = _.tokenize(text, grammar);
		return Token.stringify(_.util.encode(tokens), language);
	},

	tokenize: function(text, grammar, language) {
		var Token = _.Token;

		var strarr = [text];

		var rest = grammar.rest;

		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}

			delete grammar.rest;
		}

		tokenloop: for (var token in grammar) {
			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				var pattern = patterns[j],
					inside = pattern.inside,
					lookbehind = !!pattern.lookbehind,
					greedy = !!pattern.greedy,
					lookbehindLength = 0,
					alias = pattern.alias;

				if (greedy && !pattern.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
					pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
				}

				pattern = pattern.pattern || pattern;

				// Don’t cache length as it changes during the loop
				for (var i=0, pos = 0; i<strarr.length; pos += strarr[i].length, ++i) {

					var str = strarr[i];

					if (strarr.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						break tokenloop;
					}

					if (str instanceof Token) {
						continue;
					}

					pattern.lastIndex = 0;

					var match = pattern.exec(str),
					    delNum = 1;

					// Greedy patterns can override/remove up to two previously matched tokens
					if (!match && greedy && i != strarr.length - 1) {
						pattern.lastIndex = pos;
						match = pattern.exec(text);
						if (!match) {
							break;
						}

						var from = match.index + (lookbehind ? match[1].length : 0),
						    to = match.index + match[0].length,
						    k = i,
						    p = pos;

						for (var len = strarr.length; k < len && p < to; ++k) {
							p += strarr[k].length;
							// Move the index i to the element in strarr that is closest to from
							if (from >= p) {
								++i;
								pos = p;
							}
						}

						/*
						 * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
						 * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
						 */
						if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
							continue;
						}

						// Number of tokens to delete and replace with the new match
						delNum = k - i;
						str = text.slice(pos, p);
						match.index -= pos;
					}

					if (!match) {
						continue;
					}

					if(lookbehind) {
						lookbehindLength = match[1].length;
					}

					var from = match.index + lookbehindLength,
					    match = match[0].slice(lookbehindLength),
					    to = from + match.length,
					    before = str.slice(0, from),
					    after = str.slice(to);

					var args = [i, delNum];

					if (before) {
						args.push(before);
					}

					var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

					args.push(wrapped);

					if (after) {
						args.push(after);
					}

					Array.prototype.splice.apply(strarr, args);
				}
			}
		}

		return strarr;
	},

	hooks: {
		all: {},

		add: function (name, callback) {
			var hooks = _.hooks.all;

			hooks[name] = hooks[name] || [];

			hooks[name].push(callback);
		},

		run: function (name, env) {
			var callbacks = _.hooks.all[name];

			if (!callbacks || !callbacks.length) {
				return;
			}

			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	}
};

var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
	this.type = type;
	this.content = content;
	this.alias = alias;
	// Copy of the full string this token was created from
	this.length = (matchedStr || "").length|0;
	this.greedy = !!greedy;
};

Token.stringify = function(o, language, parent) {
	if (typeof o == 'string') {
		return o;
	}

	if (_.util.type(o) === 'Array') {
		return o.map(function(element) {
			return Token.stringify(element, language, o);
		}).join('');
	}

	var env = {
		type: o.type,
		content: Token.stringify(o.content, language, parent),
		tag: 'span',
		classes: ['token', o.type],
		attributes: {},
		language: language,
		parent: parent
	};

	if (env.type == 'comment') {
		env.attributes['spellcheck'] = 'true';
	}

	if (o.alias) {
		var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
		Array.prototype.push.apply(env.classes, aliases);
	}

	_.hooks.run('wrap', env);

	var attributes = Object.keys(env.attributes).map(function(name) {
		return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
	}).join(' ');

	return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';

};

if (!_self.document) {
	if (!_self.addEventListener) {
		// in Node.js
		return _self.Prism;
	}
 	// In worker
	_self.addEventListener('message', function(evt) {
		var message = JSON.parse(evt.data),
		    lang = message.language,
		    code = message.code,
		    immediateClose = message.immediateClose;

		_self.postMessage(_.highlight(code, _.languages[lang], lang));
		if (immediateClose) {
			_self.close();
		}
	}, false);

	return _self.Prism;
}

//Get current script and highlight
var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

if (script) {
	_.filename = script.src;

	if (document.addEventListener && !script.hasAttribute('data-manual')) {
		if(document.readyState !== "loading") {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(_.highlightAll);
			} else {
				window.setTimeout(_.highlightAll, 16);
			}
		}
		else {
			document.addEventListener('DOMContentLoaded', _.highlightAll);
		}
	}
}

return _self.Prism;

})();

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== 'undefined') {
	global.Prism = Prism;
}


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': /<!--[\w\W]*?-->/,
	'prolog': /<\?[\w\W]+?\?>/,
	'doctype': /<!DOCTYPE[\w\W]+?>/i,
	'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/i,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'attr-value': {
				pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
				inside: {
					'punctuation': /[=>"']/
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': /&#?[\da-z]{1,8};/i
};

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function(env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;


/* **********************************************
     Begin prism-css.js
********************************************** */

Prism.languages.css = {
	'comment': /\/\*[\w\W]*?\*\//,
	'atrule': {
		pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
		inside: {
			'rule': /@[\w-]+/
			// See rest below
		}
	},
	'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
	'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
	'string': {
		pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'property': /(\b|\B)[\w-]+(?=\s*:)/i,
	'important': /\B!important\b/i,
	'function': /[-a-z0-9]+(?=\()/i,
	'punctuation': /[(){};:]/
};

Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'style': {
			pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
			lookbehind: true,
			inside: Prism.languages.css,
			alias: 'language-css'
		}
	});
	
	Prism.languages.insertBefore('inside', 'attr-value', {
		'style-attr': {
			pattern: /\s*style=("|').*?\1/i,
			inside: {
				'attr-name': {
					pattern: /^\s*style/i,
					inside: Prism.languages.markup.tag.inside
				},
				'punctuation': /^\s*=\s*['"]|['"]\s*$/,
				'attr-value': {
					pattern: /.+/i,
					inside: Prism.languages.css
				}
			},
			alias: 'language-css'
		}
	}, Prism.languages.markup.tag);
}

/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
			lookbehind: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true
		}
	],
	'string': {
		pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
		lookbehind: true,
		inside: {
			punctuation: /(\.|\\)/
		}
	},
	'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(true|false)\b/,
	'function': /[a-z0-9_]+(?=\()/i,
	'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
	'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
});

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
		lookbehind: true,
		greedy: true
	}
});

Prism.languages.insertBefore('javascript', 'string', {
	'template-string': {
		pattern: /`(?:\\\\|\\?[^\\])*?`/,
		greedy: true,
		inside: {
			'interpolation': {
				pattern: /\$\{[^}]+\}/,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'script': {
			pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript,
			alias: 'language-javascript'
		}
	});
}

Prism.languages.js = Prism.languages.javascript;

/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
	if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
		return;
	}

	self.Prism.fileHighlight = function() {

		var Extensions = {
			'js': 'javascript',
			'py': 'python',
			'rb': 'ruby',
			'ps1': 'powershell',
			'psm1': 'powershell',
			'sh': 'bash',
			'bat': 'batch',
			'h': 'c',
			'tex': 'latex'
		};

		if(Array.prototype.forEach) { // Check to prevent error in IE8
			Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
				var src = pre.getAttribute('data-src');

				var language, parent = pre;
				var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
				while (parent && !lang.test(parent.className)) {
					parent = parent.parentNode;
				}

				if (parent) {
					language = (pre.className.match(lang) || [, ''])[1];
				}

				if (!language) {
					var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
					language = Extensions[extension] || extension;
				}

				var code = document.createElement('code');
				code.className = 'language-' + language;

				pre.textContent = '';

				code.textContent = 'Loading…';

				pre.appendChild(code);

				var xhr = new XMLHttpRequest();

				xhr.open('GET', src, true);

				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {

						if (xhr.status < 400 && xhr.responseText) {
							code.textContent = xhr.responseText;

							Prism.highlightElement(code);
						}
						else if (xhr.status >= 400) {
							code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
						}
						else {
							code.textContent = '✖ Error: File does not exist or is empty';
						}
					}
				};

				xhr.send(null);
			});
		}

	};

	document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(13);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(15)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!./../../css-loader/index.js!./prism.css", function() {
			var newContent = require("!!./../../css-loader/index.js!./prism.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {

  /**
   * default scale that will be set on element
   * @maxPinch {Number}
   */
  baseScale: 1,

  /**
   * max scale a node can reach
   * @maxPinch {Number}
   */
  maxScale: 3,

  /**
   * max scale a node can reach before bouncing back to maxScale
   * @maxScaleTimes {Number}
   */
  maxScaleTimes: 4,

  /**
   * min scale a node can reach
   * @minPinch {Number}
   */
  minScale: 1,

  /**
   * min scale a node can reach before bouncing back to minScale
   * @minScaleTimes {Number}
   */
  minScaleTimes: 0.8,

  /**
   * time for the snapBack of the pinch if the node has reach above
   * or below its pinch value
   * @snapBackSpeed {Number}
   */
  snapBackSpeed: 200,

  /**
   * Basic easing functions: https://developer.mozilla.org/de/docs/Web/CSS/transition-timing-function
   * cubic bezier easing functions: http://easings.net/de
   * @ease {String}
   */
  ease: 'ease'
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
//


var _dispatchEvent = __webpack_require__(9);

var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

var _handleEvent = __webpack_require__(12);

var _handleElement = __webpack_require__(11);

var _handleElement2 = _interopRequireDefault(_handleElement);

var _handlePinch = __webpack_require__(0);

var _handleDrag = __webpack_require__(10);

var _defaults = __webpack_require__(6);

var _defaults2 = _interopRequireDefault(_defaults);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var first = function first(items) {
  return items[0];
};

var setTarget = function setTarget(el, opts) {
  return el.querySelector(opts.target ? 'img' + opts.target : 'img');
};

var pinchIt = function pinchIt(targets) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // private variable cache
  var element = null;

  var scaling = void 0;
  var lastScale = 1;
  var startTouches = void 0;

  var zoomFactor = 1;

  var offset = { x: 0, y: 0 };
  var lastZoomCenter = false;
  var lastDragPosition = false;

  // Base configuration for the pinch instance
  var opts = _extends({}, _defaults2.default, options);

  var _eventDispatcher = (0, _dispatchEvent2.default)(),
      on = _eventDispatcher.on,
      dispatch = _eventDispatcher.dispatch;

  /**
   *  dispatchPinchEvent - Shorthand method for creating events
   *
   *  @param { String } phase
   *  @param { String } type
   *  @param { Object } details
   *  @return { Void }
   **/


  var dispatchPinchEvent = function dispatchPinchEvent(eventName, phase) {
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    dispatch(eventName, Object.assign(data, {
      phase: phase
    }));
  };

  var resetGlobals = function resetGlobals() {
    scaling = undefined;
    lastScale = 1;
    startTouches = null;
    zoomFactor = 1;
    lastZoomCenter = false;

    lastDragPosition = false;
    offset = { x: 0, y: 0 };
  };

  // event handling
  /**
   * Set scaling if we are using more then one finger
   * and captures our first punch point
   *
   * private
   * @param { Object } e the event from our eventlistener
   */
  var onTouchstart = function onTouchstart(e) {
    dispatchPinchEvent('touchstart', 'before', e);

    scaling = e.touches.length === 2;
    startTouches = Array.from(e.touches);
    lastScale = 1;

    if ((0, _handleEvent.detectDoubleTap)(e)) {
      var image = e.currentTarget.querySelector('img');
      (0, _handleElement2.default)(e.target, image, 1, { x: 0, y: 0 }, opts.snapBackSpeed, opts.ease);
      resetGlobals();
    }

    dispatchPinchEvent('touchstart', 'after', e);
  };

  var onTouchmove = function onTouchmove(e) {
    dispatchPinchEvent('touchmove', 'before', e);

    if ((!scaling || !startTouches) && zoomFactor > 1) {
      (0, _handleEvent.cancelEvent)(e);

      var touch = first((0, _handleEvent.getTouches)(e.currentTarget, Array.from(e.touches)));
      var dragOffset = (0, _handleDrag.drag)(touch, lastDragPosition, offset, zoomFactor);

      offset = (0, _handleDrag.sanitizeOffset)(e.target, dragOffset, zoomFactor);
      lastDragPosition = touch;
    } else if (scaling && startTouches) {
      (0, _handleEvent.cancelEvent)(e);

      // a relative scale factor is used
      var touchCenter = (0, _handlePinch.getTouchCenter)((0, _handleEvent.getTouches)(e.currentTarget, Array.from(e.touches)));
      var newScale = (0, _handleEvent.calcScale)(e.currentTarget, startTouches, Array.from(e.touches));
      var scaleValue = (0, _handlePinch.calcNewScale)(newScale, lastScale);
      var scale = (0, _handlePinch.getScaleFactor)(scaleValue, zoomFactor, opts);

      zoomFactor = (0, _handlePinch.getZoomFactor)(scaleValue, zoomFactor, opts);

      offset = (0, _handlePinch.addOffset)(offset, {
        x: (scale - 1) * (touchCenter.x + offset.x),
        y: (scale - 1) * (touchCenter.y + offset.y)
      });

      lastScale = newScale;
      offset = (0, _handleDrag.drag)(touchCenter, lastZoomCenter, offset, zoomFactor);
      lastZoomCenter = touchCenter;
    }

    var image = e.currentTarget.querySelector('img');
    (0, _handleElement2.default)(e.target, image, zoomFactor, offset, 0, opts.ease);

    dispatchPinchEvent('touchmove', 'after', e);
  };

  var onTouchend = function onTouchend(e) {
    dispatchPinchEvent('touchend', 'before', e);

    if (zoomFactor) {
      if (!(0, _handlePinch.isWithin)(zoomFactor, opts)) {
        var image = e.currentTarget.querySelector('img');
        var isLessThan = (0, _handlePinch.getInitialScale)(e.target, image) * zoomFactor < opts.minScale;
        var lastZoom = zoomFactor;
        zoomFactor = isLessThan ? opts.minScale : opts.maxScale;
        var scaleValue = (0, _handlePinch.calcNewScale)(zoomFactor, lastZoom);
        var scale = (0, _handlePinch.getScaleFactor)(scaleValue, zoomFactor, opts);
        offset = (0, _handlePinch.addOffset)(offset, {
          x: (scale - 1) * (lastZoomCenter.x + offset.x),
          y: (scale - 1) * (lastZoomCenter.y + offset.y)
        });
        offset = (0, _handleDrag.sanitizeOffset)(e.target, offset, zoomFactor);
        (0, _handleElement2.default)(e.target, image, zoomFactor, offset, opts.snapBackSpeed, opts.ease);
      }
    }

    lastScale = 1;
    lastDragPosition = false;
    lastZoomCenter = false;

    dispatchPinchEvent('touchend', 'after', e);
  };

  var attachEvents = function attachEvents(el) {
    el.addEventListener('touchstart', onTouchstart);
    el.addEventListener('touchmove', onTouchmove);
    el.addEventListener('touchend', onTouchend);
  };

  var detachhEvents = function detachhEvents(el) {
    el.removeEventListener('touchstart', onTouchstart);
    el.removeEventListener('touchmove', onTouchmove);
    el.removeEventListener('touchend', onTouchend);
  };

  /**
   * public
   * reset function:
   * @param { Number } duration
   * @param { String } easing
   * @return { Void }
   */
  var reset = function reset() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!element) return;
    var image = setTarget(element, opts);
    if (!image) return;

    var _Object$assign = Object.assign({}, opts, opt),
        snapBackSpeed = _Object$assign.snapBackSpeed,
        easing = _Object$assign.easing;

    (0, _handleElement2.default)(element, image, 1, { x: 0, y: 0 }, snapBackSpeed, easing);
    resetGlobals();
  };

  /**
   * public
   * destroy function: called to gracefully destroy the lory instance
   * @return { Void }
   */
  var destroy = function destroy() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    dispatchPinchEvent('destroy', 'before', {});
    if (!element) return;
    reset(opt);
    // remove event listeners
    detachhEvents(element);
    element = null;
    resetGlobals();
    dispatchPinchEvent('destroy', 'after', {});
  };

  /**
   * setup - Init function
   *
   * @param { String, Object }
   * @return { Void }
   **/
  var setup = function setup(target) {
    if (element) destroy();
    dispatchPinchEvent('init', 'before', {});
    // resolve target
    // pinchit allows for both a node or a string to be passed
    switch (typeof target === 'undefined' ? 'undefined' : _typeof(target)) {
      case 'object':
        element = target;
        break;
      case 'string':
        element = document.querySelector(target);
        break;
      default:
        element = null;
        console.warn('missing target, either pass an node or a string');
    }

    if (element) {
      attachEvents(element);
    }

    dispatchPinchEvent('init', 'after', {});
  };

  // trigger initial setup
  setup(targets);

  return {
    setup: setup,
    reset: reset,
    destroy: destroy,
    element: element,
    on: on
  };
};

exports.default = pinchIt;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Detecting prefixes for saving time and bytes
 */
exports.default = function () {
  var transform = void 0;
  var transition = void 0;
  var transitionEnd = void 0;
  var hasScale3d = void 0;

  (function () {
    var el = document.createElement('_');
    var style = el.style;

    if (style.webkitTransition === '') {
      transitionEnd = 'webkitTransitionEnd';
      transition = 'webkitTransition';
    }

    if (style.transition === '') {
      transitionEnd = 'transitionend';
      transition = 'transition';
    }

    if (style.webkitTransform === '') {
      transform = 'webkitTransform';
    }

    if (style.msTransform === '') {
      transform = 'msTransform';
    }

    if (style.transform === '') {
      transform = 'transform';
    }

    document.body.insertBefore(el, null);
    style[transform] = 'translate3d(0, 0, 0)';
    hasScale3d = !!global.getComputedStyle(el).getPropertyValue(transform);
    document.body.removeChild(el);
  })();

  return {
    transform: transform,
    transition: transition,
    transitionEnd: transitionEnd,
    hasScale3d: hasScale3d
  };
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});


/**
 * dispatch custom events
 */

var eventDispatcher = function eventDispatcher() {
  var events = {};

  /**
   * Register a handler for event, to be fired
   * for every event.
   */
  var on = function on(eventName, handler) {
    events[eventName] = events[eventName] || [];
    events[eventName].push(handler);
    return undefined;
  };

  /**
   * dispatch an event for a handler.
   */
  var dispatch = function dispatch(eventName, data) {
    if (events[eventName]) {
      events[eventName].forEach(function (fn) {
        fn(data);
      });
    }
  };

  return {
    on: on,
    dispatch: dispatch
  };
};

exports.default = eventDispatcher;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drag = exports.sanitizeOffset = undefined;

var _handlePinch = __webpack_require__(0);

var calcMax = function calcMax(el, differ, zoomFactor) {
  return {
    maxX: (zoomFactor - differ) * (0, _handlePinch.getX)(el),
    maxY: (zoomFactor - differ) * (0, _handlePinch.getY)(el)
  };
};

var sanitizeOffset = exports.sanitizeOffset = function sanitizeOffset(el, offset, zoomFactor) {
  var _calcMax = calcMax(el, 1, zoomFactor),
      maxX = _calcMax.maxX,
      maxY = _calcMax.maxY;

  var maxOffsetX = Math.max(maxX, 0);
  var maxOffsetY = Math.max(maxY, 0);
  var minOffsetX = Math.min(maxX, 0);
  var minOffsetY = Math.min(maxY, 0);

  return {
    x: Math.min(Math.max(offset.x, minOffsetX), maxOffsetX),
    y: Math.min(Math.max(offset.y, minOffsetY), maxOffsetY)
  };
};

var drag = exports.drag = function drag(center, lastCenter, lastOffset, zoomFactor) {
  return Object.prototype.hasOwnProperty.call(lastCenter, 'x') ? (0, _handlePinch.addOffset)(lastOffset, {
    x: -((center.x - lastCenter.x) * zoomFactor / zoomFactor),
    y: -((center.y - lastCenter.y) * zoomFactor / zoomFactor)
  }) : lastOffset;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _detectPrefixes = __webpack_require__(8);

var _detectPrefixes2 = _interopRequireDefault(_detectPrefixes);

var _handlePinch = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var prefixes = (0, _detectPrefixes2.default)();

var handleAnimation = function handleAnimation(el, transition, duration, ease) {
  var style = el.style;

  style.transformOrigin = '0% 0%';
  style[transition + 'TimingFunction'] = ease;
  style[transition + 'Duration'] = duration + 'ms';
};

/**
 * scaleElement -transdorms to a given position in a given time in milliseconds
 *
 * @param { Object } el element from the events
 * @param { Number } pinch number where to scale to
 * @param { Object } coords object where to translate to
 * @param { Number } duration time in milliseconds for the transistion
 * @param { String } ease easing css property
 * @return { Void }
 */

exports.default = function (el, image, pinch, coords, duration, ease) {
  var transition = prefixes.transition,
      transform = prefixes.transform,
      hasScale3d = prefixes.hasScale3d;
  var style = image.style;


  var zoomFactor = (0, _handlePinch.getInitialScale)(el, image) * pinch;

  var offsetX = -coords.x;
  var offsetY = -coords.y;

  handleAnimation(image, transition, duration, ease);
  var scaleProp = hasScale3d ? 'scale3d(' + zoomFactor + ', ' + zoomFactor + ', 1)' : 'scale(' + zoomFactor + ', ' + zoomFactor + ')';
  var translateProp = 'translate(' + offsetX + 'px, ' + offsetY + 'px)';

  style[transform] = translateProp + ' ' + scaleProp;
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var lastTouchStart = 0;

/**
 * cancelEvent - Cancel Events so we dont bubble up our events to the document
 *
 * @param { Object } event
 * @return { Void }
 **/
var cancelEvent = exports.cancelEvent = function cancelEvent(e) {
  e.stopPropagation();
  e.preventDefault();
};

/**
 * detectDoubleTap - Check if we are double tapping
 *
 * @param { Object } event
 * @return { Boolean }
 **/
var detectDoubleTap = exports.detectDoubleTap = function detectDoubleTap(e) {
  var time = new Date().getTime();

  if (e.touches.length > 1) {
    lastTouchStart = 0;
  }

  if (time - lastTouchStart < 300) {
    cancelEvent(e);
    return true;
  }

  if (e.touches.length === 1) {
    lastTouchStart = time;
  }
  return false;
};

/**
 * Returns the touches of an event relative to the container offset
 *
 * @param event
 * @return array touches
 */
var getTouches = exports.getTouches = function getTouches(el, touches) {
  var position = el.getBoundingClientRect();
  return touches.map(function (touch) {
    return {
      x: touch.pageX - (position.left + document.body.scrollLeft),
      y: touch.pageY - (position.top + document.body.scrollTop)
    };
  });
};

/**
 * getDistance - Calculate the distance between our fingers
 *
 * @param { Array } touches touches passas an array from TouchList
 * @return { Number } the calcualted distance between the fingers
 **/
var getDistance = exports.getDistance = function getDistance(touches) {
  var _touches = _slicedToArray(touches, 2),
      first = _touches[0],
      second = _touches[1];

  return Math.sqrt((first.x - second.x) * (first.x - second.x) + (first.y - second.y) * (first.y - second.y));
};

/**
 * calcScale - Calculate the distance between where we start our pinch
 * to where we end it
 *
 * @param { Array } startTouch The starting point of our touch
 * @param { Array } endTouch The current point of our touch
 * @return { Number }
 */
var calcScale = exports.calcScale = function calcScale(el, startTouch, endTouch) {
  return getDistance(getTouches(el, endTouch)) / getDistance(getTouches(el, startTouch));
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(14)();
// imports


// module
exports.push([module.i, "/**\n * prism.js default theme for JavaScript, CSS and HTML\n * Based on dabblet (http://dabblet.com)\n * @author Lea Verou\n */\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n\tcolor: black;\n\tbackground: none;\n\ttext-shadow: 0 1px white;\n\tfont-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;\n\ttext-align: left;\n\twhite-space: pre;\n\tword-spacing: normal;\n\tword-break: normal;\n\tword-wrap: normal;\n\tline-height: 1.5;\n\n\t-moz-tab-size: 4;\n\t-o-tab-size: 4;\n\ttab-size: 4;\n\n\t-webkit-hyphens: none;\n\t-moz-hyphens: none;\n\t-ms-hyphens: none;\n\thyphens: none;\n}\n\npre[class*=\"language-\"]::-moz-selection, pre[class*=\"language-\"] ::-moz-selection,\ncode[class*=\"language-\"]::-moz-selection, code[class*=\"language-\"] ::-moz-selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\npre[class*=\"language-\"]::selection, pre[class*=\"language-\"] ::selection,\ncode[class*=\"language-\"]::selection, code[class*=\"language-\"] ::selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\n@media print {\n\tcode[class*=\"language-\"],\n\tpre[class*=\"language-\"] {\n\t\ttext-shadow: none;\n\t}\n}\n\n/* Code blocks */\npre[class*=\"language-\"] {\n\tpadding: 1em;\n\tmargin: .5em 0;\n\toverflow: auto;\n}\n\n:not(pre) > code[class*=\"language-\"],\npre[class*=\"language-\"] {\n\tbackground: #f5f2f0;\n}\n\n/* Inline code */\n:not(pre) > code[class*=\"language-\"] {\n\tpadding: .1em;\n\tborder-radius: .3em;\n\twhite-space: normal;\n}\n\n.token.comment,\n.token.prolog,\n.token.doctype,\n.token.cdata {\n\tcolor: slategray;\n}\n\n.token.punctuation {\n\tcolor: #999;\n}\n\n.namespace {\n\topacity: .7;\n}\n\n.token.property,\n.token.tag,\n.token.boolean,\n.token.number,\n.token.constant,\n.token.symbol,\n.token.deleted {\n\tcolor: #905;\n}\n\n.token.selector,\n.token.attr-name,\n.token.string,\n.token.char,\n.token.builtin,\n.token.inserted {\n\tcolor: #690;\n}\n\n.token.operator,\n.token.entity,\n.token.url,\n.language-css .token.string,\n.style .token.string {\n\tcolor: #a67f59;\n\tbackground: hsla(0, 0%, 100%, .5);\n}\n\n.token.atrule,\n.token.attr-value,\n.token.keyword {\n\tcolor: #07a;\n}\n\n.token.function {\n\tcolor: #DD4A68;\n}\n\n.token.regex,\n.token.important,\n.token.variable {\n\tcolor: #e90;\n}\n\n.token.important,\n.token.bold {\n\tfont-weight: bold;\n}\n.token.italic {\n\tfont-style: italic;\n}\n\n.token.entity {\n\tcursor: help;\n}\n", ""]);

// exports


/***/ }),
/* 14 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function() {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		var result = [];
		for(var i = 0; i < this.length; i++) {
			var item = this[i];
			if(item[2]) {
				result.push("@media " + item[2] + "{" + item[1] + "}");
			} else {
				result.push(item[1]);
			}
		}
		return result.join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
	}),
	getHeadElement = memoize(function () {
		return document.head || document.getElementsByTagName("head")[0];
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [];

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the bottom of <head>.
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
}

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var head = getHeadElement();
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			head.insertBefore(styleElement, head.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			head.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		head.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	styleElement.type = "text/css";
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	linkElement.rel = "stylesheet";
	insertStyleElement(options, linkElement);
	return linkElement;
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _prismjs = __webpack_require__(4);

var _prismjs2 = _interopRequireDefault(_prismjs);

__webpack_require__(5);

var _handleEvent = __webpack_require__(2);

var _handleEvent2 = _interopRequireDefault(_handleEvent);

var _src = __webpack_require__(3);

var _src2 = _interopRequireDefault(_src);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _src2.default)('.example-one .img-wrapper');
(0, _src2.default)('.example-tree .img-wrapper', {
  maxScale: 4,
  minScale: 0.5,
  snapBackSpeed: 500
});

var pinchImage = (0, _src2.default)('.example-four .img-wrapper', {
  snapBackSpeed: 1000
});

document.querySelector('.reset-button').addEventListener('click', function () {
  pinchImage.reset();
});

var target = document.querySelector('.event-target');
var handleEventExample = (0, _handleEvent2.default)(target);
var pinchEvent = (0, _src2.default)('.example-five .img-wrapper', {
  target: 'img',
  snapBackSpeed: 1000
});

pinchEvent.on('touchstart', handleEventExample);
pinchEvent.on('touchmove', handleEventExample);

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNWM3M2QwYmM1NzMzZmY1ZjAwNjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2hhbmRsZS1waW5jaC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL2RvY3MvaGFuZGxlLWV2ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaXNtanMvcHJpc20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmlzbWpzL3RoZW1lcy9wcmlzbS5jc3M/NjgwZCIsIndlYnBhY2s6Ly8vLi9zcmMvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BpbmNoLWl0LmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9kZXRlY3QtcHJlZml4ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2Rpc3BhdGNoLWV2ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9oYW5kbGUtZHJhZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvaGFuZGxlLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2hhbmRsZS1ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaXNtanMvdGhlbWVzL3ByaXNtLmNzcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9kb2NzL2FwcC5qcyJdLCJuYW1lcyI6WyJzdW0iLCJhY2MiLCJuZXh0IiwiZ2V0VmVjdG9yQXZnIiwidmVjdG9ycyIsIngiLCJtYXAiLCJ2IiwicmVkdWNlIiwibGVuZ3RoIiwieSIsImdldEVsZW1lbnQiLCJ0eXBlIiwiZWwiLCJIVE1MSW1hZ2VFbGVtZW50IiwiaXNXaXRoaW4iLCJzY2FsZSIsIm9wdHMiLCJtYXhTY2FsZSIsIm1pblNjYWxlIiwiYWRkT2Zmc2V0IiwibGFzdE9mZnNldCIsIm9mZnNldCIsImdldFgiLCJnZXRZIiwiZ2V0SW5pdGlhbFNjYWxlIiwiaW1hZ2UiLCJvZmZzZXRXaWR0aCIsImdldFNjYWxlRmFjdG9yIiwiZmFjdG9yIiwibWF4U2NhbGVUaW1lcyIsIm1pblNjYWxlVGltZXMiLCJ6b29tRmFjdG9yIiwiTWF0aCIsIm1pbiIsIm1heCIsImdldFpvb21GYWN0b3IiLCJnZXRUb3VjaENlbnRlciIsInRvdWNoZXMiLCJjYWxjTmV3U2NhbGUiLCJ0byIsImxhc3RTY2FsZSIsImUiLCJuZXdTcGFuIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidGltZSIsIkRhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwibmV3Q29udGVudCIsImNyZWF0ZVRleHROb2RlIiwiYXBwZW5kQ2hpbGQiLCJ0YXJnZXQiLCJiYXNlU2NhbGUiLCJzbmFwQmFja1NwZWVkIiwiZWFzZSIsImZpcnN0IiwiaXRlbXMiLCJzZXRUYXJnZXQiLCJxdWVyeVNlbGVjdG9yIiwicGluY2hJdCIsInRhcmdldHMiLCJvcHRpb25zIiwiZWxlbWVudCIsInNjYWxpbmciLCJzdGFydFRvdWNoZXMiLCJsYXN0Wm9vbUNlbnRlciIsImxhc3REcmFnUG9zaXRpb24iLCJvbiIsImRpc3BhdGNoIiwiZGlzcGF0Y2hQaW5jaEV2ZW50IiwiZXZlbnROYW1lIiwicGhhc2UiLCJkYXRhIiwiT2JqZWN0IiwiYXNzaWduIiwicmVzZXRHbG9iYWxzIiwidW5kZWZpbmVkIiwib25Ub3VjaHN0YXJ0IiwiQXJyYXkiLCJmcm9tIiwiY3VycmVudFRhcmdldCIsIm9uVG91Y2htb3ZlIiwidG91Y2giLCJkcmFnT2Zmc2V0IiwidG91Y2hDZW50ZXIiLCJuZXdTY2FsZSIsInNjYWxlVmFsdWUiLCJvblRvdWNoZW5kIiwiaXNMZXNzVGhhbiIsImxhc3Rab29tIiwiYXR0YWNoRXZlbnRzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImRldGFjaGhFdmVudHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVzZXQiLCJvcHQiLCJlYXNpbmciLCJkZXN0cm95Iiwic2V0dXAiLCJjb25zb2xlIiwid2FybiIsInRyYW5zZm9ybSIsInRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uRW5kIiwiaGFzU2NhbGUzZCIsInN0eWxlIiwid2Via2l0VHJhbnNpdGlvbiIsIndlYmtpdFRyYW5zZm9ybSIsIm1zVHJhbnNmb3JtIiwiYm9keSIsImluc2VydEJlZm9yZSIsImdsb2JhbCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicmVtb3ZlQ2hpbGQiLCJldmVudERpc3BhdGNoZXIiLCJldmVudHMiLCJoYW5kbGVyIiwicHVzaCIsImZvckVhY2giLCJmbiIsImNhbGNNYXgiLCJkaWZmZXIiLCJtYXhYIiwibWF4WSIsInNhbml0aXplT2Zmc2V0IiwibWF4T2Zmc2V0WCIsIm1heE9mZnNldFkiLCJtaW5PZmZzZXRYIiwibWluT2Zmc2V0WSIsImRyYWciLCJjZW50ZXIiLCJsYXN0Q2VudGVyIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwicHJlZml4ZXMiLCJoYW5kbGVBbmltYXRpb24iLCJkdXJhdGlvbiIsInRyYW5zZm9ybU9yaWdpbiIsInBpbmNoIiwiY29vcmRzIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJzY2FsZVByb3AiLCJ0cmFuc2xhdGVQcm9wIiwibGFzdFRvdWNoU3RhcnQiLCJjYW5jZWxFdmVudCIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiZGV0ZWN0RG91YmxlVGFwIiwiZ2V0VGltZSIsImdldFRvdWNoZXMiLCJwb3NpdGlvbiIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhZ2VYIiwibGVmdCIsInNjcm9sbExlZnQiLCJwYWdlWSIsInRvcCIsInNjcm9sbFRvcCIsImdldERpc3RhbmNlIiwic2Vjb25kIiwic3FydCIsImNhbGNTY2FsZSIsInN0YXJ0VG91Y2giLCJlbmRUb3VjaCIsInBpbmNoSW1hZ2UiLCJoYW5kbGVFdmVudEV4YW1wbGUiLCJwaW5jaEV2ZW50Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlEQSxJQUFNQSxNQUFNLFNBQU5BLEdBQU0sQ0FBQ0MsR0FBRCxFQUFNQyxJQUFOO0FBQUEsU0FBZUQsTUFBTUMsSUFBckI7QUFBQSxDQUFaOztBQUVBOzs7QUFHQSxJQUFNQyxlQUFlLFNBQWZBLFlBQWUsQ0FBQ0MsT0FBRDtBQUFBLFNBQXFDO0FBQ3hEQyxPQUFHRCxRQUFRRSxHQUFSLENBQVk7QUFBQSxhQUFNQyxFQUFFRixDQUFSO0FBQUEsS0FBWixFQUF3QkcsTUFBeEIsQ0FBK0JSLEdBQS9CLElBQXNDSSxRQUFRSyxNQURPO0FBRXhEQyxPQUFHTixRQUFRRSxHQUFSLENBQVk7QUFBQSxhQUFNQyxFQUFFRyxDQUFSO0FBQUEsS0FBWixFQUF3QkYsTUFBeEIsQ0FBK0JSLEdBQS9CLElBQXNDSSxRQUFRSztBQUZPLEdBQXJDO0FBQUEsQ0FBckI7O0FBS0EsSUFBTUUsYUFBYSxTQUFiQSxVQUFhLENBQUNDLElBQUQ7QUFBQSxTQUFrQixVQUFDQyxFQUFEO0FBQUEsV0FDbENBLGNBQWNDLGdCQUFmLEdBQ0VELEdBQUdELElBQUgsQ0FERixHQUVFLENBSGlDO0FBQUEsR0FBbEI7QUFBQSxDQUFuQjs7QUFNQTs7Ozs7OztBQU9PLElBQU1HLDhCQUFXLFNBQVhBLFFBQVcsQ0FBQ0MsS0FBRCxFQUFnQkMsSUFBaEIsRUFBMEM7QUFBQSxNQUN4REMsUUFEd0QsR0FDakNELElBRGlDLENBQ3hEQyxRQUR3RDtBQUFBLE1BQzlDQyxRQUQ4QyxHQUNqQ0YsSUFEaUMsQ0FDOUNFLFFBRDhDOztBQUVoRSxTQUFRSCxTQUFTRyxRQUFWLElBQXdCSCxTQUFTRSxRQUF4QztBQUNELENBSE07O0FBS1A7Ozs7Ozs7QUFPTyxJQUFNRSxnQ0FBWSxTQUFaQSxTQUFZLENBQUNDLFVBQUQsRUFBcUJDLE1BQXJCO0FBQUEsU0FBaUQ7QUFDeEVqQixPQUFHZ0IsV0FBV2hCLENBQVgsR0FBZWlCLE9BQU9qQixDQUQrQztBQUV4RUssT0FBR1csV0FBV1gsQ0FBWCxHQUFlWSxPQUFPWjtBQUYrQyxHQUFqRDtBQUFBLENBQWxCOztBQUtBLElBQU1hLHNCQUFPWixXQUFXLGFBQVgsQ0FBYjtBQUNBLElBQU1hLHNCQUFPYixXQUFXLGNBQVgsQ0FBYjs7QUFFUDs7Ozs7O0FBTU8sSUFBTWMsNENBQWtCLFNBQWxCQSxlQUFrQixDQUFDWixFQUFELEVBQWtCYSxLQUFsQjtBQUFBLFNBQzVCYixjQUFjQyxnQkFBZixHQUNFUyxLQUFLVixFQUFMLElBQVdhLE1BQU1DLFdBRG5CLEdBRUUsQ0FIMkI7QUFBQSxDQUF4Qjs7QUFNUDs7Ozs7O0FBTU8sSUFBTUMsMENBQWlCLFNBQWpCQSxjQUFpQixDQUFDWixLQUFELEVBQWdCYSxNQUFoQixFQUFnQ1osSUFBaEMsRUFBeUQ7QUFBQSxNQUM3RWEsYUFENkUsR0FDNUNiLElBRDRDLENBQzdFYSxhQUQ2RTtBQUFBLE1BQzlEQyxhQUQ4RCxHQUM1Q2QsSUFENEMsQ0FDOURjLGFBRDhEOztBQUVyRixNQUFNQyxhQUFhQyxLQUFLQyxHQUFMLENBQVNKLGFBQVQsRUFBd0JHLEtBQUtFLEdBQUwsQ0FBU04sU0FBU2IsS0FBbEIsRUFBeUJlLGFBQXpCLENBQXhCLENBQW5CO0FBQ0EsU0FBT0MsYUFBYUgsTUFBcEI7QUFDRCxDQUpNOztBQU1QOzs7Ozs7QUFNTyxJQUFNTyx3Q0FBZ0IsU0FBaEJBLGFBQWdCLENBQUNwQixLQUFELEVBQWdCYSxNQUFoQixFQUFnQ1osSUFBaEMsRUFBeUQ7QUFBQSxNQUM1RWEsYUFENEUsR0FDM0NiLElBRDJDLENBQzVFYSxhQUQ0RTtBQUFBLE1BQzdEQyxhQUQ2RCxHQUMzQ2QsSUFEMkMsQ0FDN0RjLGFBRDZEOztBQUVwRixTQUFPRSxLQUFLQyxHQUFMLENBQVNKLGFBQVQsRUFBd0JHLEtBQUtFLEdBQUwsQ0FBU04sU0FBU2IsS0FBbEIsRUFBeUJlLGFBQXpCLENBQXhCLENBQVA7QUFDRCxDQUhNOztBQUtBLElBQU1NLDBDQUFpQixTQUFqQkEsY0FBaUIsQ0FBQ0MsT0FBRDtBQUFBLFNBQTRCbkMsYUFBYW1DLE9BQWIsQ0FBNUI7QUFBQSxDQUF2Qjs7QUFFQSxJQUFNQyxzQ0FBZSxTQUFmQSxZQUFlLENBQUNDLEVBQUQ7QUFBQSxNQUFhQyxTQUFiLHVFQUFpQyxDQUFqQztBQUFBLFNBQzFCRCxLQUFLQyxTQURxQjtBQUFBLENBQXJCLEM7Ozs7OztBQ2xGUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7Ozs7Ozs7Ozs7a0JDcEJlO0FBQUEsU0FBVSxVQUFDQyxDQUFELEVBQU87QUFDOUIsUUFBTUMsVUFBVUMsU0FBU0MsYUFBVCxDQUF1QixNQUF2QixDQUFoQjtBQUNBLFFBQUlDLE9BQU8sSUFBSUMsSUFBSixFQUFYO0FBQ0FELFdBQU9BLEtBQUtFLFFBQUwsS0FBa0IsR0FBbEIsR0FBd0JGLEtBQUtHLFVBQUwsRUFBeEIsR0FBNEMsR0FBNUMsR0FBa0RILEtBQUtJLFVBQUwsRUFBbEQsR0FBc0UsR0FBdEUsR0FBNEVKLEtBQUtLLGVBQUwsRUFBbkY7QUFDQSxRQUFNQyxhQUFhUixTQUFTUyxjQUFULENBQXdCLE1BQU1QLElBQU4sR0FBYSx1QkFBYixHQUF1Q0osRUFBRTlCLElBQXpDLEdBQWdELEdBQXhFLENBQW5CO0FBQ0ErQixZQUFRVyxXQUFSLENBQW9CRixVQUFwQjtBQUNBRyxXQUFPRCxXQUFQLENBQW1CWCxPQUFuQjtBQUNELEdBUGM7QUFBQSxDOzs7Ozs7Ozs7Ozs7O0FDQWY7Ozs7Ozs7Ozs7Ozs7QUNDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx3Q0FBd0Msb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLHdCQUF3QixFQUFFO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCLGlCQUFpQjs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLG1CQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlFQUF5RTtBQUN6RSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3JQQTs7OztBQUNBOztBQUVBOzs7O0FBQ0E7Ozs7OztBQUVBLG1CQUFRLDJCQUFSO0FBQ0EsbUJBQVEsNEJBQVIsRUFBc0M7QUFDcEN2SixZQUFVLENBRDBCO0FBRXBDQyxZQUFVLEdBRjBCO0FBR3BDc0MsaUJBQWU7QUFIcUIsQ0FBdEM7O0FBTUEsSUFBTWtILGFBQWEsbUJBQVEsNEJBQVIsRUFBc0M7QUFDdkRsSCxpQkFBZTtBQUR3QyxDQUF0QyxDQUFuQjs7QUFJQWIsU0FDR2tCLGFBREgsQ0FDaUIsZUFEakIsRUFFR2lDLGdCQUZILENBRW9CLE9BRnBCLEVBRTZCLFlBQU07QUFDL0I0RSxhQUFXekUsS0FBWDtBQUNELENBSkg7O0FBTUEsSUFBTTNDLFNBQVNYLFNBQVNrQixhQUFULENBQXVCLGVBQXZCLENBQWY7QUFDQSxJQUFNOEcscUJBQXFCLDJCQUFZckgsTUFBWixDQUEzQjtBQUNBLElBQU1zSCxhQUFhLG1CQUFRLDRCQUFSLEVBQXNDO0FBQ3ZEdEgsVUFBUSxLQUQrQztBQUV2REUsaUJBQWU7QUFGd0MsQ0FBdEMsQ0FBbkI7O0FBS0FvSCxXQUFXdEcsRUFBWCxDQUFjLFlBQWQsRUFBNEJxRyxrQkFBNUI7QUFDQUMsV0FBV3RHLEVBQVgsQ0FBYyxXQUFkLEVBQTJCcUcsa0JBQTNCLEUiLCJmaWxlIjoiYnVuZGxlLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9qcy9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNWM3M2QwYmM1NzMzZmY1ZjAwNjYiLCIvLyBAZmxvd1xuXG5jb25zdCBzdW0gPSAoYWNjLCBuZXh0KSA9PiBhY2MgKyBuZXh0O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGF2ZXJhZ2Ugb2YgbXVsdGlwbGUgdmVjdG9ycyAoeCwgeSB2YWx1ZXMpXG4gKi9cbmNvbnN0IGdldFZlY3RvckF2ZyA9ICh2ZWN0b3JzOiBBcnJheTxPYmplY3Q+KTogT2JqZWN0ID0+ICh7XG4gIHg6IHZlY3RvcnMubWFwKHYgPT4gKHYueCkpLnJlZHVjZShzdW0pIC8gdmVjdG9ycy5sZW5ndGgsXG4gIHk6IHZlY3RvcnMubWFwKHYgPT4gKHYueSkpLnJlZHVjZShzdW0pIC8gdmVjdG9ycy5sZW5ndGgsXG59KTtcblxuY29uc3QgZ2V0RWxlbWVudCA9ICh0eXBlOiBzdHJpbmcpID0+IChlbDogRXZlbnRUYXJnZXQpOiBudW1iZXIgPT4gKFxuICAoZWwgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KVxuICA/IGVsW3R5cGVdXG4gIDogMVxuKTtcblxuLyoqXG4gKiBpc1dpdGhpbiAtIENoZWNrIGlmIHZhbHVlIGlzIGJldHdlZW4gdHdvIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7IE51bWJlciB9IHNjYWxlIGN1cnJlbnQgc2NhbGUgdmFsdWVcbiAqIEBwYXJhbSB7IE9iamVjdCB9IG1pblBpbmNoLCBtYXhQaW5oXG4gKiBAcmV0dXJuIHsgQm9vbGVhbiB9XG4gKiovXG5leHBvcnQgY29uc3QgaXNXaXRoaW4gPSAoc2NhbGU6IG51bWJlciwgb3B0czogT2JqZWN0KTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IHsgbWF4U2NhbGUsIG1pblNjYWxlIH0gPSBvcHRzO1xuICByZXR1cm4gKHNjYWxlID49IG1pblNjYWxlKSAmJiAoc2NhbGUgPD0gbWF4U2NhbGUpO1xufTtcblxuLyoqXG4gKiBhZGRPZmZzZXQgLSBDb21iaW5lIGN1cnJlbnQgb2Zmc2V0IHdpdGggb2xkIG9mZnNldCBhbmQgcmV0dXJucyBhIG5ldyBvZmZzZXRcbiAqXG4gKiBAcGFyYW0geyBPYmplY3QgfSBsYXN0T2Zmc2V0IGxhc3Qgb2Zmc2V0XG4gKiBAcGFyYW0geyBPYmplY3QgfSBvZmZzZXQsIG5ldyBvZmZzZXRcbiAqIEByZXR1cm4geyBPYmplY3QgfVxuICoqL1xuZXhwb3J0IGNvbnN0IGFkZE9mZnNldCA9IChsYXN0T2Zmc2V0OiBPYmplY3QsIG9mZnNldDogT2JqZWN0KTogT2JqZWN0ID0+ICh7XG4gIHg6IGxhc3RPZmZzZXQueCArIG9mZnNldC54LFxuICB5OiBsYXN0T2Zmc2V0LnkgKyBvZmZzZXQueSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZ2V0WCA9IGdldEVsZW1lbnQoJ29mZnNldFdpZHRoJyk7XG5leHBvcnQgY29uc3QgZ2V0WSA9IGdldEVsZW1lbnQoJ29mZnNldEhlaWdodCcpO1xuXG4vKipcbiAqIGdldFNjYWxlIC0gQ2hlY2sgaWYgdmFsdWUgaXMgYmV0d2VlbiB0d28gdmFsdWVzXG4gKlxuICogQHBhcmFtIHsgTm9kZSB9IGVsIGN1cnJlbnQgc2NhbGUgdmFsdWVcbiAqIEByZXR1cm4geyBOdW1iZXIgfVxuICoqL1xuZXhwb3J0IGNvbnN0IGdldEluaXRpYWxTY2FsZSA9IChlbDogRXZlbnRUYXJnZXQsIGltYWdlOiBIVE1MRWxlbWVudCk6IG51bWJlciA9PiAoXG4gIChlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpXG4gID8gZ2V0WChlbCkgLyBpbWFnZS5vZmZzZXRXaWR0aFxuICA6IDFcbik7XG5cbi8qKlxuICogU2NhbGVzIHRoZSB6b29tIGZhY3RvciByZWxhdGl2ZSB0byBjdXJyZW50IHN0YXRlXG4gKlxuICogQHBhcmFtIHNjYWxlXG4gKiBAcmV0dXJuIHRoZSBhY3R1YWwgc2NhbGUgKGNhbiBkaWZmZXIgYmVjYXVzZSBvZiBtYXggbWluIHpvb20gZmFjdG9yKVxuICovXG5leHBvcnQgY29uc3QgZ2V0U2NhbGVGYWN0b3IgPSAoc2NhbGU6IG51bWJlciwgZmFjdG9yOiBudW1iZXIsIG9wdHM6IE9iamVjdCk6IE9iamVjdCA9PiB7XG4gIGNvbnN0IHsgbWF4U2NhbGVUaW1lcywgbWluU2NhbGVUaW1lcyB9ID0gb3B0cztcbiAgY29uc3Qgem9vbUZhY3RvciA9IE1hdGgubWluKG1heFNjYWxlVGltZXMsIE1hdGgubWF4KGZhY3RvciAqIHNjYWxlLCBtaW5TY2FsZVRpbWVzKSk7XG4gIHJldHVybiB6b29tRmFjdG9yIC8gZmFjdG9yO1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIHpvb20gZmFjdG9yIHJlbGF0aXZlIHRvIGN1cnJlbnQgc3RhdGVcbiAqXG4gKiBAcGFyYW0gc2NhbGVcbiAqIEByZXR1cm4gdGhlIGFjdHVhbCBzY2FsZSAoY2FuIGRpZmZlciBiZWNhdXNlIG9mIG1heCBtaW4gem9vbSBmYWN0b3IpXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRab29tRmFjdG9yID0gKHNjYWxlOiBudW1iZXIsIGZhY3RvcjogbnVtYmVyLCBvcHRzOiBPYmplY3QpOiBPYmplY3QgPT4ge1xuICBjb25zdCB7IG1heFNjYWxlVGltZXMsIG1pblNjYWxlVGltZXMgfSA9IG9wdHM7XG4gIHJldHVybiBNYXRoLm1pbihtYXhTY2FsZVRpbWVzLCBNYXRoLm1heChmYWN0b3IgKiBzY2FsZSwgbWluU2NhbGVUaW1lcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFRvdWNoQ2VudGVyID0gKHRvdWNoZXM6IEFycmF5PE9iamVjdD4pID0+IGdldFZlY3RvckF2Zyh0b3VjaGVzKTtcblxuZXhwb3J0IGNvbnN0IGNhbGNOZXdTY2FsZSA9ICh0bzogbnVtYmVyLCBsYXN0U2NhbGU6IG51bWJlciA9IDEpOiBudW1iZXIgPT4gKFxuICB0byAvIGxhc3RTY2FsZVxuKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9oYW5kbGUtcGluY2guanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGRlZmF1bHQgdGFyZ2V0ID0+IChlKSA9PiB7XG4gIGNvbnN0IG5ld1NwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGxldCB0aW1lID0gbmV3IERhdGUoKTtcbiAgdGltZSA9IHRpbWUuZ2V0SG91cnMoKSArICc6JyArIHRpbWUuZ2V0TWludXRlcygpICsgJzonICsgdGltZS5nZXRTZWNvbmRzKCkgKyAnLCcgKyB0aW1lLmdldE1pbGxpc2Vjb25kcygpO1xuICBjb25zdCBuZXdDb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1snICsgdGltZSArICddIEV2ZW50IGRpc3BhdGNoZWQ6IFwiJyArIGUudHlwZSArICdcIicpO1xuICBuZXdTcGFuLmFwcGVuZENoaWxkKG5ld0NvbnRlbnQpO1xuICB0YXJnZXQuYXBwZW5kQ2hpbGQobmV3U3Bhbik7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy9oYW5kbGUtZXZlbnQuanMiLCJpbXBvcnQgcGluY2hJdCBmcm9tICcuL3BpbmNoLWl0JztcblxuZXhwb3J0IGRlZmF1bHQgcGluY2hJdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyIsIlxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jb3JlLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbnZhciBfc2VsZiA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcblx0PyB3aW5kb3cgICAvLyBpZiBpbiBicm93c2VyXG5cdDogKFxuXHRcdCh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSlcblx0XHQ/IHNlbGYgLy8gaWYgaW4gd29ya2VyXG5cdFx0OiB7fSAgIC8vIGlmIGluIG5vZGUganNcblx0KTtcblxuLyoqXG4gKiBQcmlzbTogTGlnaHR3ZWlnaHQsIHJvYnVzdCwgZWxlZ2FudCBzeW50YXggaGlnaGxpZ2h0aW5nXG4gKiBNSVQgbGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC9cbiAqIEBhdXRob3IgTGVhIFZlcm91IGh0dHA6Ly9sZWEudmVyb3UubWVcbiAqL1xuXG52YXIgUHJpc20gPSAoZnVuY3Rpb24oKXtcblxuLy8gUHJpdmF0ZSBoZWxwZXIgdmFyc1xudmFyIGxhbmcgPSAvXFxibGFuZyg/OnVhZ2UpPy0oXFx3KylcXGIvaTtcbnZhciB1bmlxdWVJZCA9IDA7XG5cbnZhciBfID0gX3NlbGYuUHJpc20gPSB7XG5cdHV0aWw6IHtcblx0XHRlbmNvZGU6IGZ1bmN0aW9uICh0b2tlbnMpIHtcblx0XHRcdGlmICh0b2tlbnMgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFRva2VuKHRva2Vucy50eXBlLCBfLnV0aWwuZW5jb2RlKHRva2Vucy5jb250ZW50KSwgdG9rZW5zLmFsaWFzKTtcblx0XHRcdH0gZWxzZSBpZiAoXy51dGlsLnR5cGUodG9rZW5zKSA9PT0gJ0FycmF5Jykge1xuXHRcdFx0XHRyZXR1cm4gdG9rZW5zLm1hcChfLnV0aWwuZW5jb2RlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0b2tlbnMucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR0eXBlOiBmdW5jdGlvbiAobykge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5tYXRjaCgvXFxbb2JqZWN0IChcXHcrKVxcXS8pWzFdO1xuXHRcdH0sXG5cblx0XHRvYmpJZDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0aWYgKCFvYmpbJ19faWQnXSkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAnX19pZCcsIHsgdmFsdWU6ICsrdW5pcXVlSWQgfSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqWydfX2lkJ107XG5cdFx0fSxcblxuXHRcdC8vIERlZXAgY2xvbmUgYSBsYW5ndWFnZSBkZWZpbml0aW9uIChlLmcuIHRvIGV4dGVuZCBpdClcblx0XHRjbG9uZTogZnVuY3Rpb24gKG8pIHtcblx0XHRcdHZhciB0eXBlID0gXy51dGlsLnR5cGUobyk7XG5cblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0XHRcdHZhciBjbG9uZSA9IHt9O1xuXG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG8pIHtcblx0XHRcdFx0XHRcdGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdFx0Y2xvbmVba2V5XSA9IF8udXRpbC5jbG9uZShvW2tleV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBjbG9uZTtcblxuXHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGV4aXN0ZW5jZSBmb3IgSUU4XG5cdFx0XHRcdFx0cmV0dXJuIG8ubWFwICYmIG8ubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIF8udXRpbC5jbG9uZSh2KTsgfSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvO1xuXHRcdH1cblx0fSxcblxuXHRsYW5ndWFnZXM6IHtcblx0XHRleHRlbmQ6IGZ1bmN0aW9uIChpZCwgcmVkZWYpIHtcblx0XHRcdHZhciBsYW5nID0gXy51dGlsLmNsb25lKF8ubGFuZ3VhZ2VzW2lkXSk7XG5cblx0XHRcdGZvciAodmFyIGtleSBpbiByZWRlZikge1xuXHRcdFx0XHRsYW5nW2tleV0gPSByZWRlZltrZXldO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGFuZztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW5zZXJ0IGEgdG9rZW4gYmVmb3JlIGFub3RoZXIgdG9rZW4gaW4gYSBsYW5ndWFnZSBsaXRlcmFsXG5cdFx0ICogQXMgdGhpcyBuZWVkcyB0byByZWNyZWF0ZSB0aGUgb2JqZWN0ICh3ZSBjYW5ub3QgYWN0dWFsbHkgaW5zZXJ0IGJlZm9yZSBrZXlzIGluIG9iamVjdCBsaXRlcmFscyksXG5cdFx0ICogd2UgY2Fubm90IGp1c3QgcHJvdmlkZSBhbiBvYmplY3QsIHdlIG5lZWQgYW5vYmplY3QgYW5kIGEga2V5LlxuXHRcdCAqIEBwYXJhbSBpbnNpZGUgVGhlIGtleSAob3IgbGFuZ3VhZ2UgaWQpIG9mIHRoZSBwYXJlbnRcblx0XHQgKiBAcGFyYW0gYmVmb3JlIFRoZSBrZXkgdG8gaW5zZXJ0IGJlZm9yZS4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZnVuY3Rpb24gYXBwZW5kcyBpbnN0ZWFkLlxuXHRcdCAqIEBwYXJhbSBpbnNlcnQgT2JqZWN0IHdpdGggdGhlIGtleS92YWx1ZSBwYWlycyB0byBpbnNlcnRcblx0XHQgKiBAcGFyYW0gcm9vdCBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgYGluc2lkZWAuIElmIGVxdWFsIHRvIFByaXNtLmxhbmd1YWdlcywgaXQgY2FuIGJlIG9taXR0ZWQuXG5cdFx0ICovXG5cdFx0aW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAoaW5zaWRlLCBiZWZvcmUsIGluc2VydCwgcm9vdCkge1xuXHRcdFx0cm9vdCA9IHJvb3QgfHwgXy5sYW5ndWFnZXM7XG5cdFx0XHR2YXIgZ3JhbW1hciA9IHJvb3RbaW5zaWRlXTtcblxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuXHRcdFx0XHRpbnNlcnQgPSBhcmd1bWVudHNbMV07XG5cblx0XHRcdFx0Zm9yICh2YXIgbmV3VG9rZW4gaW4gaW5zZXJ0KSB7XG5cdFx0XHRcdFx0aWYgKGluc2VydC5oYXNPd25Qcm9wZXJ0eShuZXdUb2tlbikpIHtcblx0XHRcdFx0XHRcdGdyYW1tYXJbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZ3JhbW1hcjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJldCA9IHt9O1xuXG5cdFx0XHRmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG5cblx0XHRcdFx0aWYgKGdyYW1tYXIuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG5cblx0XHRcdFx0XHRpZiAodG9rZW4gPT0gYmVmb3JlKSB7XG5cblx0XHRcdFx0XHRcdGZvciAodmFyIG5ld1Rva2VuIGluIGluc2VydCkge1xuXG5cdFx0XHRcdFx0XHRcdGlmIChpbnNlcnQuaGFzT3duUHJvcGVydHkobmV3VG9rZW4pKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0W25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXRbdG9rZW5dID0gZ3JhbW1hclt0b2tlbl07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIHJlZmVyZW5jZXMgaW4gb3RoZXIgbGFuZ3VhZ2UgZGVmaW5pdGlvbnNcblx0XHRcdF8ubGFuZ3VhZ2VzLkRGUyhfLmxhbmd1YWdlcywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IHJvb3RbaW5zaWRlXSAmJiBrZXkgIT0gaW5zaWRlKSB7XG5cdFx0XHRcdFx0dGhpc1trZXldID0gcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHJvb3RbaW5zaWRlXSA9IHJldDtcblx0XHR9LFxuXG5cdFx0Ly8gVHJhdmVyc2UgYSBsYW5ndWFnZSBkZWZpbml0aW9uIHdpdGggRGVwdGggRmlyc3QgU2VhcmNoXG5cdFx0REZTOiBmdW5jdGlvbihvLCBjYWxsYmFjaywgdHlwZSwgdmlzaXRlZCkge1xuXHRcdFx0dmlzaXRlZCA9IHZpc2l0ZWQgfHwge307XG5cdFx0XHRmb3IgKHZhciBpIGluIG8pIHtcblx0XHRcdFx0aWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKG8sIGksIG9baV0sIHR5cGUgfHwgaSk7XG5cblx0XHRcdFx0XHRpZiAoXy51dGlsLnR5cGUob1tpXSkgPT09ICdPYmplY3QnICYmICF2aXNpdGVkW18udXRpbC5vYmpJZChvW2ldKV0pIHtcblx0XHRcdFx0XHRcdHZpc2l0ZWRbXy51dGlsLm9iaklkKG9baV0pXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRfLmxhbmd1YWdlcy5ERlMob1tpXSwgY2FsbGJhY2ssIG51bGwsIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChfLnV0aWwudHlwZShvW2ldKSA9PT0gJ0FycmF5JyAmJiAhdmlzaXRlZFtfLnV0aWwub2JqSWQob1tpXSldKSB7XG5cdFx0XHRcdFx0XHR2aXNpdGVkW18udXRpbC5vYmpJZChvW2ldKV0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0Xy5sYW5ndWFnZXMuREZTKG9baV0sIGNhbGxiYWNrLCBpLCB2aXNpdGVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdHBsdWdpbnM6IHt9LFxuXG5cdGhpZ2hsaWdodEFsbDogZnVuY3Rpb24oYXN5bmMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGVudiA9IHtcblx0XHRcdGNhbGxiYWNrOiBjYWxsYmFjayxcblx0XHRcdHNlbGVjdG9yOiAnY29kZVtjbGFzcyo9XCJsYW5ndWFnZS1cIl0sIFtjbGFzcyo9XCJsYW5ndWFnZS1cIl0gY29kZSwgY29kZVtjbGFzcyo9XCJsYW5nLVwiXSwgW2NsYXNzKj1cImxhbmctXCJdIGNvZGUnXG5cdFx0fTtcblxuXHRcdF8uaG9va3MucnVuKFwiYmVmb3JlLWhpZ2hsaWdodGFsbFwiLCBlbnYpO1xuXG5cdFx0dmFyIGVsZW1lbnRzID0gZW52LmVsZW1lbnRzIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZW52LnNlbGVjdG9yKTtcblxuXHRcdGZvciAodmFyIGk9MCwgZWxlbWVudDsgZWxlbWVudCA9IGVsZW1lbnRzW2krK107KSB7XG5cdFx0XHRfLmhpZ2hsaWdodEVsZW1lbnQoZWxlbWVudCwgYXN5bmMgPT09IHRydWUsIGVudi5jYWxsYmFjayk7XG5cdFx0fVxuXHR9LFxuXG5cdGhpZ2hsaWdodEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGFzeW5jLCBjYWxsYmFjaykge1xuXHRcdC8vIEZpbmQgbGFuZ3VhZ2Vcblx0XHR2YXIgbGFuZ3VhZ2UsIGdyYW1tYXIsIHBhcmVudCA9IGVsZW1lbnQ7XG5cblx0XHR3aGlsZSAocGFyZW50ICYmICFsYW5nLnRlc3QocGFyZW50LmNsYXNzTmFtZSkpIHtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdGxhbmd1YWdlID0gKHBhcmVudC5jbGFzc05hbWUubWF0Y2gobGFuZykgfHwgWywnJ10pWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRncmFtbWFyID0gXy5sYW5ndWFnZXNbbGFuZ3VhZ2VdO1xuXHRcdH1cblxuXHRcdC8vIFNldCBsYW5ndWFnZSBvbiB0aGUgZWxlbWVudCwgaWYgbm90IHByZXNlbnRcblx0XHRlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UobGFuZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKSArICcgbGFuZ3VhZ2UtJyArIGxhbmd1YWdlO1xuXG5cdFx0Ly8gU2V0IGxhbmd1YWdlIG9uIHRoZSBwYXJlbnQsIGZvciBzdHlsaW5nXG5cdFx0cGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXG5cdFx0aWYgKC9wcmUvaS50ZXN0KHBhcmVudC5ub2RlTmFtZSkpIHtcblx0XHRcdHBhcmVudC5jbGFzc05hbWUgPSBwYXJlbnQuY2xhc3NOYW1lLnJlcGxhY2UobGFuZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKSArICcgbGFuZ3VhZ2UtJyArIGxhbmd1YWdlO1xuXHRcdH1cblxuXHRcdHZhciBjb2RlID0gZWxlbWVudC50ZXh0Q29udGVudDtcblxuXHRcdHZhciBlbnYgPSB7XG5cdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuXHRcdFx0bGFuZ3VhZ2U6IGxhbmd1YWdlLFxuXHRcdFx0Z3JhbW1hcjogZ3JhbW1hcixcblx0XHRcdGNvZGU6IGNvZGVcblx0XHR9O1xuXG5cdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1zYW5pdHktY2hlY2snLCBlbnYpO1xuXG5cdFx0aWYgKCFlbnYuY29kZSB8fCAhZW52LmdyYW1tYXIpIHtcblx0XHRcdGlmIChlbnYuY29kZSkge1xuXHRcdFx0XHRlbnYuZWxlbWVudC50ZXh0Q29udGVudCA9IGVudi5jb2RlO1xuXHRcdFx0fVxuXHRcdFx0Xy5ob29rcy5ydW4oJ2NvbXBsZXRlJywgZW52KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWhpZ2hsaWdodCcsIGVudik7XG5cblx0XHRpZiAoYXN5bmMgJiYgX3NlbGYuV29ya2VyKSB7XG5cdFx0XHR2YXIgd29ya2VyID0gbmV3IFdvcmtlcihfLmZpbGVuYW1lKTtcblxuXHRcdFx0d29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2dCkge1xuXHRcdFx0XHRlbnYuaGlnaGxpZ2h0ZWRDb2RlID0gZXZ0LmRhdGE7XG5cblx0XHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1pbnNlcnQnLCBlbnYpO1xuXG5cdFx0XHRcdGVudi5lbGVtZW50LmlubmVySFRNTCA9IGVudi5oaWdobGlnaHRlZENvZGU7XG5cblx0XHRcdFx0Y2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChlbnYuZWxlbWVudCk7XG5cdFx0XHRcdF8uaG9va3MucnVuKCdhZnRlci1oaWdobGlnaHQnLCBlbnYpO1xuXHRcdFx0XHRfLmhvb2tzLnJ1bignY29tcGxldGUnLCBlbnYpO1xuXHRcdFx0fTtcblxuXHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdFx0bGFuZ3VhZ2U6IGVudi5sYW5ndWFnZSxcblx0XHRcdFx0Y29kZTogZW52LmNvZGUsXG5cdFx0XHRcdGltbWVkaWF0ZUNsb3NlOiB0cnVlXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZW52LmhpZ2hsaWdodGVkQ29kZSA9IF8uaGlnaGxpZ2h0KGVudi5jb2RlLCBlbnYuZ3JhbW1hciwgZW52Lmxhbmd1YWdlKTtcblxuXHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1pbnNlcnQnLCBlbnYpO1xuXG5cdFx0XHRlbnYuZWxlbWVudC5pbm5lckhUTUwgPSBlbnYuaGlnaGxpZ2h0ZWRDb2RlO1xuXG5cdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVsZW1lbnQpO1xuXG5cdFx0XHRfLmhvb2tzLnJ1bignYWZ0ZXItaGlnaGxpZ2h0JywgZW52KTtcblx0XHRcdF8uaG9va3MucnVuKCdjb21wbGV0ZScsIGVudik7XG5cdFx0fVxuXHR9LFxuXG5cdGhpZ2hsaWdodDogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG5cdFx0dmFyIHRva2VucyA9IF8udG9rZW5pemUodGV4dCwgZ3JhbW1hcik7XG5cdFx0cmV0dXJuIFRva2VuLnN0cmluZ2lmeShfLnV0aWwuZW5jb2RlKHRva2VucyksIGxhbmd1YWdlKTtcblx0fSxcblxuXHR0b2tlbml6ZTogZnVuY3Rpb24odGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcblx0XHR2YXIgVG9rZW4gPSBfLlRva2VuO1xuXG5cdFx0dmFyIHN0cmFyciA9IFt0ZXh0XTtcblxuXHRcdHZhciByZXN0ID0gZ3JhbW1hci5yZXN0O1xuXG5cdFx0aWYgKHJlc3QpIHtcblx0XHRcdGZvciAodmFyIHRva2VuIGluIHJlc3QpIHtcblx0XHRcdFx0Z3JhbW1hclt0b2tlbl0gPSByZXN0W3Rva2VuXTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsZXRlIGdyYW1tYXIucmVzdDtcblx0XHR9XG5cblx0XHR0b2tlbmxvb3A6IGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcblx0XHRcdGlmKCFncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSB8fCAhZ3JhbW1hclt0b2tlbl0pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwYXR0ZXJucyA9IGdyYW1tYXJbdG9rZW5dO1xuXHRcdFx0cGF0dGVybnMgPSAoXy51dGlsLnR5cGUocGF0dGVybnMpID09PSBcIkFycmF5XCIpID8gcGF0dGVybnMgOiBbcGF0dGVybnNdO1xuXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHBhdHRlcm5zLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHZhciBwYXR0ZXJuID0gcGF0dGVybnNbal0sXG5cdFx0XHRcdFx0aW5zaWRlID0gcGF0dGVybi5pbnNpZGUsXG5cdFx0XHRcdFx0bG9va2JlaGluZCA9ICEhcGF0dGVybi5sb29rYmVoaW5kLFxuXHRcdFx0XHRcdGdyZWVkeSA9ICEhcGF0dGVybi5ncmVlZHksXG5cdFx0XHRcdFx0bG9va2JlaGluZExlbmd0aCA9IDAsXG5cdFx0XHRcdFx0YWxpYXMgPSBwYXR0ZXJuLmFsaWFzO1xuXG5cdFx0XHRcdGlmIChncmVlZHkgJiYgIXBhdHRlcm4ucGF0dGVybi5nbG9iYWwpIHtcblx0XHRcdFx0XHQvLyBXaXRob3V0IHRoZSBnbG9iYWwgZmxhZywgbGFzdEluZGV4IHdvbid0IHdvcmtcblx0XHRcdFx0XHR2YXIgZmxhZ3MgPSBwYXR0ZXJuLnBhdHRlcm4udG9TdHJpbmcoKS5tYXRjaCgvW2ltdXldKiQvKVswXTtcblx0XHRcdFx0XHRwYXR0ZXJuLnBhdHRlcm4gPSBSZWdFeHAocGF0dGVybi5wYXR0ZXJuLnNvdXJjZSwgZmxhZ3MgKyBcImdcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXR0ZXJuID0gcGF0dGVybi5wYXR0ZXJuIHx8IHBhdHRlcm47XG5cblx0XHRcdFx0Ly8gRG9u4oCZdCBjYWNoZSBsZW5ndGggYXMgaXQgY2hhbmdlcyBkdXJpbmcgdGhlIGxvb3Bcblx0XHRcdFx0Zm9yICh2YXIgaT0wLCBwb3MgPSAwOyBpPHN0cmFyci5sZW5ndGg7IHBvcyArPSBzdHJhcnJbaV0ubGVuZ3RoLCArK2kpIHtcblxuXHRcdFx0XHRcdHZhciBzdHIgPSBzdHJhcnJbaV07XG5cblx0XHRcdFx0XHRpZiAoc3RyYXJyLmxlbmd0aCA+IHRleHQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyBTb21ldGhpbmcgd2VudCB0ZXJyaWJseSB3cm9uZywgQUJPUlQsIEFCT1JUIVxuXHRcdFx0XHRcdFx0YnJlYWsgdG9rZW5sb29wO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChzdHIgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cGF0dGVybi5sYXN0SW5kZXggPSAwO1xuXG5cdFx0XHRcdFx0dmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHN0ciksXG5cdFx0XHRcdFx0ICAgIGRlbE51bSA9IDE7XG5cblx0XHRcdFx0XHQvLyBHcmVlZHkgcGF0dGVybnMgY2FuIG92ZXJyaWRlL3JlbW92ZSB1cCB0byB0d28gcHJldmlvdXNseSBtYXRjaGVkIHRva2Vuc1xuXHRcdFx0XHRcdGlmICghbWF0Y2ggJiYgZ3JlZWR5ICYmIGkgIT0gc3RyYXJyLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRcdHBhdHRlcm4ubGFzdEluZGV4ID0gcG9zO1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGV4dCk7XG5cdFx0XHRcdFx0XHRpZiAoIW1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgZnJvbSA9IG1hdGNoLmluZGV4ICsgKGxvb2tiZWhpbmQgPyBtYXRjaFsxXS5sZW5ndGggOiAwKSxcblx0XHRcdFx0XHRcdCAgICB0byA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoLFxuXHRcdFx0XHRcdFx0ICAgIGsgPSBpLFxuXHRcdFx0XHRcdFx0ICAgIHAgPSBwb3M7XG5cblx0XHRcdFx0XHRcdGZvciAodmFyIGxlbiA9IHN0cmFyci5sZW5ndGg7IGsgPCBsZW4gJiYgcCA8IHRvOyArK2spIHtcblx0XHRcdFx0XHRcdFx0cCArPSBzdHJhcnJba10ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHQvLyBNb3ZlIHRoZSBpbmRleCBpIHRvIHRoZSBlbGVtZW50IGluIHN0cmFyciB0aGF0IGlzIGNsb3Nlc3QgdG8gZnJvbVxuXHRcdFx0XHRcdFx0XHRpZiAoZnJvbSA+PSBwKSB7XG5cdFx0XHRcdFx0XHRcdFx0KytpO1xuXHRcdFx0XHRcdFx0XHRcdHBvcyA9IHA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Lypcblx0XHRcdFx0XHRcdCAqIElmIHN0cmFycltpXSBpcyBhIFRva2VuLCB0aGVuIHRoZSBtYXRjaCBzdGFydHMgaW5zaWRlIGFub3RoZXIgVG9rZW4sIHdoaWNoIGlzIGludmFsaWRcblx0XHRcdFx0XHRcdCAqIElmIHN0cmFycltrIC0gMV0gaXMgZ3JlZWR5IHdlIGFyZSBpbiBjb25mbGljdCB3aXRoIGFub3RoZXIgZ3JlZWR5IHBhdHRlcm5cblx0XHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdFx0aWYgKHN0cmFycltpXSBpbnN0YW5jZW9mIFRva2VuIHx8IHN0cmFycltrIC0gMV0uZ3JlZWR5KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBOdW1iZXIgb2YgdG9rZW5zIHRvIGRlbGV0ZSBhbmQgcmVwbGFjZSB3aXRoIHRoZSBuZXcgbWF0Y2hcblx0XHRcdFx0XHRcdGRlbE51bSA9IGsgLSBpO1xuXHRcdFx0XHRcdFx0c3RyID0gdGV4dC5zbGljZShwb3MsIHApO1xuXHRcdFx0XHRcdFx0bWF0Y2guaW5kZXggLT0gcG9zO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICghbWF0Y2gpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmKGxvb2tiZWhpbmQpIHtcblx0XHRcdFx0XHRcdGxvb2tiZWhpbmRMZW5ndGggPSBtYXRjaFsxXS5sZW5ndGg7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGZyb20gPSBtYXRjaC5pbmRleCArIGxvb2tiZWhpbmRMZW5ndGgsXG5cdFx0XHRcdFx0ICAgIG1hdGNoID0gbWF0Y2hbMF0uc2xpY2UobG9va2JlaGluZExlbmd0aCksXG5cdFx0XHRcdFx0ICAgIHRvID0gZnJvbSArIG1hdGNoLmxlbmd0aCxcblx0XHRcdFx0XHQgICAgYmVmb3JlID0gc3RyLnNsaWNlKDAsIGZyb20pLFxuXHRcdFx0XHRcdCAgICBhZnRlciA9IHN0ci5zbGljZSh0byk7XG5cblx0XHRcdFx0XHR2YXIgYXJncyA9IFtpLCBkZWxOdW1dO1xuXG5cdFx0XHRcdFx0aWYgKGJlZm9yZSkge1xuXHRcdFx0XHRcdFx0YXJncy5wdXNoKGJlZm9yZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHdyYXBwZWQgPSBuZXcgVG9rZW4odG9rZW4sIGluc2lkZT8gXy50b2tlbml6ZShtYXRjaCwgaW5zaWRlKSA6IG1hdGNoLCBhbGlhcywgbWF0Y2gsIGdyZWVkeSk7XG5cblx0XHRcdFx0XHRhcmdzLnB1c2god3JhcHBlZCk7XG5cblx0XHRcdFx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdFx0XHRcdGFyZ3MucHVzaChhZnRlcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShzdHJhcnIsIGFyZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0cmFycjtcblx0fSxcblxuXHRob29rczoge1xuXHRcdGFsbDoge30sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGhvb2tzID0gXy5ob29rcy5hbGw7XG5cblx0XHRcdGhvb2tzW25hbWVdID0gaG9va3NbbmFtZV0gfHwgW107XG5cblx0XHRcdGhvb2tzW25hbWVdLnB1c2goY2FsbGJhY2spO1xuXHRcdH0sXG5cblx0XHRydW46IGZ1bmN0aW9uIChuYW1lLCBlbnYpIHtcblx0XHRcdHZhciBjYWxsYmFja3MgPSBfLmhvb2tzLmFsbFtuYW1lXTtcblxuXHRcdFx0aWYgKCFjYWxsYmFja3MgfHwgIWNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpPTAsIGNhbGxiYWNrOyBjYWxsYmFjayA9IGNhbGxiYWNrc1tpKytdOykge1xuXHRcdFx0XHRjYWxsYmFjayhlbnYpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxudmFyIFRva2VuID0gXy5Ub2tlbiA9IGZ1bmN0aW9uKHR5cGUsIGNvbnRlbnQsIGFsaWFzLCBtYXRjaGVkU3RyLCBncmVlZHkpIHtcblx0dGhpcy50eXBlID0gdHlwZTtcblx0dGhpcy5jb250ZW50ID0gY29udGVudDtcblx0dGhpcy5hbGlhcyA9IGFsaWFzO1xuXHQvLyBDb3B5IG9mIHRoZSBmdWxsIHN0cmluZyB0aGlzIHRva2VuIHdhcyBjcmVhdGVkIGZyb21cblx0dGhpcy5sZW5ndGggPSAobWF0Y2hlZFN0ciB8fCBcIlwiKS5sZW5ndGh8MDtcblx0dGhpcy5ncmVlZHkgPSAhIWdyZWVkeTtcbn07XG5cblRva2VuLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKG8sIGxhbmd1YWdlLCBwYXJlbnQpIHtcblx0aWYgKHR5cGVvZiBvID09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIG87XG5cdH1cblxuXHRpZiAoXy51dGlsLnR5cGUobykgPT09ICdBcnJheScpIHtcblx0XHRyZXR1cm4gby5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIFRva2VuLnN0cmluZ2lmeShlbGVtZW50LCBsYW5ndWFnZSwgbyk7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHR2YXIgZW52ID0ge1xuXHRcdHR5cGU6IG8udHlwZSxcblx0XHRjb250ZW50OiBUb2tlbi5zdHJpbmdpZnkoby5jb250ZW50LCBsYW5ndWFnZSwgcGFyZW50KSxcblx0XHR0YWc6ICdzcGFuJyxcblx0XHRjbGFzc2VzOiBbJ3Rva2VuJywgby50eXBlXSxcblx0XHRhdHRyaWJ1dGVzOiB7fSxcblx0XHRsYW5ndWFnZTogbGFuZ3VhZ2UsXG5cdFx0cGFyZW50OiBwYXJlbnRcblx0fTtcblxuXHRpZiAoZW52LnR5cGUgPT0gJ2NvbW1lbnQnKSB7XG5cdFx0ZW52LmF0dHJpYnV0ZXNbJ3NwZWxsY2hlY2snXSA9ICd0cnVlJztcblx0fVxuXG5cdGlmIChvLmFsaWFzKSB7XG5cdFx0dmFyIGFsaWFzZXMgPSBfLnV0aWwudHlwZShvLmFsaWFzKSA9PT0gJ0FycmF5JyA/IG8uYWxpYXMgOiBbby5hbGlhc107XG5cdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW52LmNsYXNzZXMsIGFsaWFzZXMpO1xuXHR9XG5cblx0Xy5ob29rcy5ydW4oJ3dyYXAnLCBlbnYpO1xuXG5cdHZhciBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoZW52LmF0dHJpYnV0ZXMpLm1hcChmdW5jdGlvbihuYW1lKSB7XG5cdFx0cmV0dXJuIG5hbWUgKyAnPVwiJyArIChlbnYuYXR0cmlidXRlc1tuYW1lXSB8fCAnJykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpICsgJ1wiJztcblx0fSkuam9pbignICcpO1xuXG5cdHJldHVybiAnPCcgKyBlbnYudGFnICsgJyBjbGFzcz1cIicgKyBlbnYuY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICsgKGF0dHJpYnV0ZXMgPyAnICcgKyBhdHRyaWJ1dGVzIDogJycpICsgJz4nICsgZW52LmNvbnRlbnQgKyAnPC8nICsgZW52LnRhZyArICc+JztcblxufTtcblxuaWYgKCFfc2VsZi5kb2N1bWVudCkge1xuXHRpZiAoIV9zZWxmLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHQvLyBpbiBOb2RlLmpzXG5cdFx0cmV0dXJuIF9zZWxmLlByaXNtO1xuXHR9XG4gXHQvLyBJbiB3b3JrZXJcblx0X3NlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGV2dCkge1xuXHRcdHZhciBtZXNzYWdlID0gSlNPTi5wYXJzZShldnQuZGF0YSksXG5cdFx0ICAgIGxhbmcgPSBtZXNzYWdlLmxhbmd1YWdlLFxuXHRcdCAgICBjb2RlID0gbWVzc2FnZS5jb2RlLFxuXHRcdCAgICBpbW1lZGlhdGVDbG9zZSA9IG1lc3NhZ2UuaW1tZWRpYXRlQ2xvc2U7XG5cblx0XHRfc2VsZi5wb3N0TWVzc2FnZShfLmhpZ2hsaWdodChjb2RlLCBfLmxhbmd1YWdlc1tsYW5nXSwgbGFuZykpO1xuXHRcdGlmIChpbW1lZGlhdGVDbG9zZSkge1xuXHRcdFx0X3NlbGYuY2xvc2UoKTtcblx0XHR9XG5cdH0sIGZhbHNlKTtcblxuXHRyZXR1cm4gX3NlbGYuUHJpc207XG59XG5cbi8vR2V0IGN1cnJlbnQgc2NyaXB0IGFuZCBoaWdobGlnaHRcbnZhciBzY3JpcHQgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0IHx8IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIikpLnBvcCgpO1xuXG5pZiAoc2NyaXB0KSB7XG5cdF8uZmlsZW5hbWUgPSBzY3JpcHQuc3JjO1xuXG5cdGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICYmICFzY3JpcHQuaGFzQXR0cmlidXRlKCdkYXRhLW1hbnVhbCcpKSB7XG5cdFx0aWYoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpIHtcblx0XHRcdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXy5oaWdobGlnaHRBbGwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoXy5oaWdobGlnaHRBbGwsIDE2KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgXy5oaWdobGlnaHRBbGwpO1xuXHRcdH1cblx0fVxufVxuXG5yZXR1cm4gX3NlbGYuUHJpc207XG5cbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IFByaXNtO1xufVxuXG4vLyBoYWNrIGZvciBjb21wb25lbnRzIHRvIHdvcmsgY29ycmVjdGx5IGluIG5vZGUuanNcbmlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuXHRnbG9iYWwuUHJpc20gPSBQcmlzbTtcbn1cblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLW1hcmt1cC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuXHQnY29tbWVudCc6IC88IS0tW1xcd1xcV10qPy0tPi8sXG5cdCdwcm9sb2cnOiAvPFxcP1tcXHdcXFddKz9cXD8+Lyxcblx0J2RvY3R5cGUnOiAvPCFET0NUWVBFW1xcd1xcV10rPz4vaSxcblx0J2NkYXRhJzogLzwhXFxbQ0RBVEFcXFtbXFx3XFxXXSo/XV0+L2ksXG5cdCd0YWcnOiB7XG5cdFx0cGF0dGVybjogLzxcXC8/KD8hXFxkKVteXFxzPlxcLz0kPF0rKD86XFxzK1teXFxzPlxcLz1dKyg/Oj0oPzooXCJ8JykoPzpcXFxcXFwxfFxcXFw/KD8hXFwxKVtcXHdcXFddKSpcXDF8W15cXHMnXCI+PV0rKSk/KSpcXHMqXFwvPz4vaSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCd0YWcnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9ePFxcLz9bXlxccz5cXC9dKy9pLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXjxcXC8/Lyxcblx0XHRcdFx0XHQnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0J2F0dHItdmFsdWUnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC89KD86KCd8XCIpW1xcd1xcV10qPyhcXDEpfFteXFxzPl0rKS9pLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiAvWz0+XCInXS9cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdwdW5jdHVhdGlvbic6IC9cXC8/Pi8sXG5cdFx0XHQnYXR0ci1uYW1lJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvW15cXHM+XFwvXSsvLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdH0sXG5cdCdlbnRpdHknOiAvJiM/W1xcZGEtel17MSw4fTsvaVxufTtcblxuLy8gUGx1Z2luIHRvIG1ha2UgZW50aXR5IHRpdGxlIHNob3cgdGhlIHJlYWwgZW50aXR5LCBpZGVhIGJ5IFJvbWFuIEtvbWFyb3ZcblByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uKGVudikge1xuXG5cdGlmIChlbnYudHlwZSA9PT0gJ2VudGl0eScpIHtcblx0XHRlbnYuYXR0cmlidXRlc1sndGl0bGUnXSA9IGVudi5jb250ZW50LnJlcGxhY2UoLyZhbXA7LywgJyYnKTtcblx0fVxufSk7XG5cblByaXNtLmxhbmd1YWdlcy54bWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLmh0bWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLm1hdGhtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMuc3ZnID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNzcy5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuY3NzID0ge1xuXHQnY29tbWVudCc6IC9cXC9cXCpbXFx3XFxXXSo/XFwqXFwvLyxcblx0J2F0cnVsZSc6IHtcblx0XHRwYXR0ZXJuOiAvQFtcXHctXSs/Lio/KDt8KD89XFxzKlxceykpL2ksXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQncnVsZSc6IC9AW1xcdy1dKy9cblx0XHRcdC8vIFNlZSByZXN0IGJlbG93XG5cdFx0fVxuXHR9LFxuXHQndXJsJzogL3VybFxcKCg/OihbXCInXSkoXFxcXCg/OlxcclxcbnxbXFx3XFxXXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMXwuKj8pXFwpL2ksXG5cdCdzZWxlY3Rvcic6IC9bXlxce1xcfVxcc11bXlxce1xcfTtdKj8oPz1cXHMqXFx7KS8sXG5cdCdzdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogLyhcInwnKShcXFxcKD86XFxyXFxufFtcXHdcXFddKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J3Byb3BlcnR5JzogLyhcXGJ8XFxCKVtcXHctXSsoPz1cXHMqOikvaSxcblx0J2ltcG9ydGFudCc6IC9cXEIhaW1wb3J0YW50XFxiL2ksXG5cdCdmdW5jdGlvbic6IC9bLWEtejAtOV0rKD89XFwoKS9pLFxuXHQncHVuY3R1YXRpb24nOiAvWygpe307Ol0vXG59O1xuXG5QcmlzbS5sYW5ndWFnZXMuY3NzWydhdHJ1bGUnXS5pbnNpZGUucmVzdCA9IFByaXNtLnV0aWwuY2xvbmUoUHJpc20ubGFuZ3VhZ2VzLmNzcyk7XG5cbmlmIChQcmlzbS5sYW5ndWFnZXMubWFya3VwKSB7XG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICd0YWcnLCB7XG5cdFx0J3N0eWxlJzoge1xuXHRcdFx0cGF0dGVybjogLyg8c3R5bGVbXFx3XFxXXSo/PilbXFx3XFxXXSo/KD89PFxcL3N0eWxlPikvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jc3MsXG5cdFx0XHRhbGlhczogJ2xhbmd1YWdlLWNzcydcblx0XHR9XG5cdH0pO1xuXHRcblx0UHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnaW5zaWRlJywgJ2F0dHItdmFsdWUnLCB7XG5cdFx0J3N0eWxlLWF0dHInOiB7XG5cdFx0XHRwYXR0ZXJuOiAvXFxzKnN0eWxlPShcInwnKS4qP1xcMS9pLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdhdHRyLW5hbWUnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogL15cXHMqc3R5bGUvaSxcblx0XHRcdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmluc2lkZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXlxccyo9XFxzKlsnXCJdfFsnXCJdXFxzKiQvLFxuXHRcdFx0XHQnYXR0ci12YWx1ZSc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvLisvaSxcblx0XHRcdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jc3Ncblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGFsaWFzOiAnbGFuZ3VhZ2UtY3NzJ1xuXHRcdH1cblx0fSwgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcpO1xufVxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNsaWtlLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5jbGlrZSA9IHtcblx0J2NvbW1lbnQnOiBbXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteXFxcXF0pXFwvXFwqW1xcd1xcV10qP1xcKlxcLy8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W15cXFxcOl0pXFwvXFwvLiovLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH1cblx0XSxcblx0J3N0cmluZyc6IHtcblx0XHRwYXR0ZXJuOiAvKFtcIiddKShcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J2NsYXNzLW5hbWUnOiB7XG5cdFx0cGF0dGVybjogLygoPzpcXGIoPzpjbGFzc3xpbnRlcmZhY2V8ZXh0ZW5kc3xpbXBsZW1lbnRzfHRyYWl0fGluc3RhbmNlb2Z8bmV3KVxccyspfCg/OmNhdGNoXFxzK1xcKCkpW2EtejAtOV9cXC5cXFxcXSsvaSxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0cHVuY3R1YXRpb246IC8oXFwufFxcXFwpL1xuXHRcdH1cblx0fSxcblx0J2tleXdvcmQnOiAvXFxiKGlmfGVsc2V8d2hpbGV8ZG98Zm9yfHJldHVybnxpbnxpbnN0YW5jZW9mfGZ1bmN0aW9ufG5ld3x0cnl8dGhyb3d8Y2F0Y2h8ZmluYWxseXxudWxsfGJyZWFrfGNvbnRpbnVlKVxcYi8sXG5cdCdib29sZWFuJzogL1xcYih0cnVlfGZhbHNlKVxcYi8sXG5cdCdmdW5jdGlvbic6IC9bYS16MC05X10rKD89XFwoKS9pLFxuXHQnbnVtYmVyJzogL1xcYi0/KD86MHhbXFxkYS1mXSt8XFxkKlxcLj9cXGQrKD86ZVsrLV0/XFxkKyk/KVxcYi9pLFxuXHQnb3BlcmF0b3InOiAvLS0/fFxcK1xcKz98IT0/PT98PD0/fD49P3w9PT89P3wmJj98XFx8XFx8P3xcXD98XFwqfFxcL3x+fFxcXnwlLyxcblx0J3B1bmN0dWF0aW9uJzogL1t7fVtcXF07KCksLjpdL1xufTtcblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWphdmFzY3JpcHQuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcblx0J2tleXdvcmQnOiAvXFxiKGFzfGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2F0Y2h8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHl8Zm9yfGZyb218ZnVuY3Rpb258Z2V0fGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c2V0fHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpXFxiLyxcblx0J251bWJlcic6IC9cXGItPygweFtcXGRBLUZhLWZdK3wwYlswMV0rfDBvWzAtN10rfFxcZCpcXC4/XFxkKyhbRWVdWystXT9cXGQrKT98TmFOfEluZmluaXR5KVxcYi8sXG5cdC8vIEFsbG93IGZvciBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMgKFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDA4NDQ0KVxuXHQnZnVuY3Rpb24nOiAvW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSooPz1cXCgpL2ksXG5cdCdvcGVyYXRvcic6IC8tLT98XFwrXFwrP3whPT89P3w8PT98Pj0/fD09Pz0/fCYmP3xcXHxcXHw/fFxcP3xcXCpcXCo/fFxcL3x+fFxcXnwlfFxcLnszfS9cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2tleXdvcmQnLCB7XG5cdCdyZWdleCc6IHtcblx0XHRwYXR0ZXJuOiAvKF58W14vXSlcXC8oPyFcXC8pKFxcWy4rP118XFxcXC58W14vXFxcXFxcclxcbl0pK1xcL1tnaW15dV17MCw1fSg/PVxccyooJHxbXFxyXFxuLC47fSldKSkvLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH1cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ3N0cmluZycsIHtcblx0J3RlbXBsYXRlLXN0cmluZyc6IHtcblx0XHRwYXR0ZXJuOiAvYCg/OlxcXFxcXFxcfFxcXFw/W15cXFxcXSkqP2AvLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdpbnRlcnBvbGF0aW9uJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvXFwkXFx7W159XStcXH0vLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbic6IHtcblx0XHRcdFx0XHRcdHBhdHRlcm46IC9eXFwkXFx7fFxcfSQvLFxuXHRcdFx0XHRcdFx0YWxpYXM6ICdwdW5jdHVhdGlvbidcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHJlc3Q6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQnc3RyaW5nJzogL1tcXHNcXFNdKy9cblx0XHR9XG5cdH1cbn0pO1xuXG5pZiAoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCkge1xuXHRQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAndGFnJywge1xuXHRcdCdzY3JpcHQnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKDxzY3JpcHRbXFx3XFxXXSo/PilbXFx3XFxXXSo/KD89PFxcL3NjcmlwdD4pL2ksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCxcblx0XHRcdGFsaWFzOiAnbGFuZ3VhZ2UtamF2YXNjcmlwdCdcblx0XHR9XG5cdH0pO1xufVxuXG5QcmlzbS5sYW5ndWFnZXMuanMgPSBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdDtcblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1maWxlLWhpZ2hsaWdodC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnIHx8ICFzZWxmLlByaXNtIHx8ICFzZWxmLmRvY3VtZW50IHx8ICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0c2VsZi5QcmlzbS5maWxlSGlnaGxpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgRXh0ZW5zaW9ucyA9IHtcblx0XHRcdCdqcyc6ICdqYXZhc2NyaXB0Jyxcblx0XHRcdCdweSc6ICdweXRob24nLFxuXHRcdFx0J3JiJzogJ3J1YnknLFxuXHRcdFx0J3BzMSc6ICdwb3dlcnNoZWxsJyxcblx0XHRcdCdwc20xJzogJ3Bvd2Vyc2hlbGwnLFxuXHRcdFx0J3NoJzogJ2Jhc2gnLFxuXHRcdFx0J2JhdCc6ICdiYXRjaCcsXG5cdFx0XHQnaCc6ICdjJyxcblx0XHRcdCd0ZXgnOiAnbGF0ZXgnXG5cdFx0fTtcblxuXHRcdGlmKEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7IC8vIENoZWNrIHRvIHByZXZlbnQgZXJyb3IgaW4gSUU4XG5cdFx0XHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwcmVbZGF0YS1zcmNdJykpLmZvckVhY2goZnVuY3Rpb24gKHByZSkge1xuXHRcdFx0XHR2YXIgc3JjID0gcHJlLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKTtcblxuXHRcdFx0XHR2YXIgbGFuZ3VhZ2UsIHBhcmVudCA9IHByZTtcblx0XHRcdFx0dmFyIGxhbmcgPSAvXFxibGFuZyg/OnVhZ2UpPy0oPyFcXCopKFxcdyspXFxiL2k7XG5cdFx0XHRcdHdoaWxlIChwYXJlbnQgJiYgIWxhbmcudGVzdChwYXJlbnQuY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHRcdGxhbmd1YWdlID0gKHByZS5jbGFzc05hbWUubWF0Y2gobGFuZykgfHwgWywgJyddKVsxXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghbGFuZ3VhZ2UpIHtcblx0XHRcdFx0XHR2YXIgZXh0ZW5zaW9uID0gKHNyYy5tYXRjaCgvXFwuKFxcdyspJC8pIHx8IFssICcnXSlbMV07XG5cdFx0XHRcdFx0bGFuZ3VhZ2UgPSBFeHRlbnNpb25zW2V4dGVuc2lvbl0gfHwgZXh0ZW5zaW9uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNvZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJyk7XG5cdFx0XHRcdGNvZGUuY2xhc3NOYW1lID0gJ2xhbmd1YWdlLScgKyBsYW5ndWFnZTtcblxuXHRcdFx0XHRwcmUudGV4dENvbnRlbnQgPSAnJztcblxuXHRcdFx0XHRjb2RlLnRleHRDb250ZW50ID0gJ0xvYWRpbmfigKYnO1xuXG5cdFx0XHRcdHByZS5hcHBlbmRDaGlsZChjb2RlKTtcblxuXHRcdFx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oJ0dFVCcsIHNyYywgdHJ1ZSk7XG5cblx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuXG5cdFx0XHRcdFx0XHRpZiAoeGhyLnN0YXR1cyA8IDQwMCAmJiB4aHIucmVzcG9uc2VUZXh0KSB7XG5cdFx0XHRcdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSB4aHIucmVzcG9uc2VUZXh0O1xuXG5cdFx0XHRcdFx0XHRcdFByaXNtLmhpZ2hsaWdodEVsZW1lbnQoY29kZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICh4aHIuc3RhdHVzID49IDQwMCkge1xuXHRcdFx0XHRcdFx0XHRjb2RlLnRleHRDb250ZW50ID0gJ+KcliBFcnJvciAnICsgeGhyLnN0YXR1cyArICcgd2hpbGUgZmV0Y2hpbmcgZmlsZTogJyArIHhoci5zdGF0dXNUZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSAn4pyWIEVycm9yOiBGaWxlIGRvZXMgbm90IGV4aXN0IG9yIGlzIGVtcHR5Jztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0eGhyLnNlbmQobnVsbCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0fTtcblxuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgc2VsZi5QcmlzbS5maWxlSGlnaGxpZ2h0KTtcblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmlzbWpzL3ByaXNtLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9wcmlzbS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3ByaXNtLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJpc20uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpc21qcy90aGVtZXMvcHJpc20uY3NzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcbiAgICogZGVmYXVsdCBzY2FsZSB0aGF0IHdpbGwgYmUgc2V0IG9uIGVsZW1lbnRcbiAgICogQG1heFBpbmNoIHtOdW1iZXJ9XG4gICAqL1xuICBiYXNlU2NhbGU6IDEsXG5cbiAgLyoqXG4gICAqIG1heCBzY2FsZSBhIG5vZGUgY2FuIHJlYWNoXG4gICAqIEBtYXhQaW5jaCB7TnVtYmVyfVxuICAgKi9cbiAgbWF4U2NhbGU6IDMsXG5cbiAgLyoqXG4gICAqIG1heCBzY2FsZSBhIG5vZGUgY2FuIHJlYWNoIGJlZm9yZSBib3VuY2luZyBiYWNrIHRvIG1heFNjYWxlXG4gICAqIEBtYXhTY2FsZVRpbWVzIHtOdW1iZXJ9XG4gICAqL1xuICBtYXhTY2FsZVRpbWVzOiA0LFxuXG4gIC8qKlxuICAgKiBtaW4gc2NhbGUgYSBub2RlIGNhbiByZWFjaFxuICAgKiBAbWluUGluY2gge051bWJlcn1cbiAgICovXG4gIG1pblNjYWxlOiAxLFxuXG4gIC8qKlxuICAgKiBtaW4gc2NhbGUgYSBub2RlIGNhbiByZWFjaCBiZWZvcmUgYm91bmNpbmcgYmFjayB0byBtaW5TY2FsZVxuICAgKiBAbWluU2NhbGVUaW1lcyB7TnVtYmVyfVxuICAgKi9cbiAgbWluU2NhbGVUaW1lczogMC44LFxuXG4gIC8qKlxuICAgKiB0aW1lIGZvciB0aGUgc25hcEJhY2sgb2YgdGhlIHBpbmNoIGlmIHRoZSBub2RlIGhhcyByZWFjaCBhYm92ZVxuICAgKiBvciBiZWxvdyBpdHMgcGluY2ggdmFsdWVcbiAgICogQHNuYXBCYWNrU3BlZWQge051bWJlcn1cbiAgICovXG4gIHNuYXBCYWNrU3BlZWQ6IDIwMCxcblxuICAvKipcbiAgICogQmFzaWMgZWFzaW5nIGZ1bmN0aW9uczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZGUvZG9jcy9XZWIvQ1NTL3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXG4gICAqIGN1YmljIGJlemllciBlYXNpbmcgZnVuY3Rpb25zOiBodHRwOi8vZWFzaW5ncy5uZXQvZGVcbiAgICogQGVhc2Uge1N0cmluZ31cbiAgICovXG4gIGVhc2U6ICdlYXNlJyxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZGVmYXVsdHMuanMiLCIvLyBAZmxvd1xuLy9cbmltcG9ydCBldmVudERpc3BhdGNoZXIgZnJvbSAnLi91dGlscy9kaXNwYXRjaC1ldmVudCc7XG5pbXBvcnQgeyBjYW5jZWxFdmVudCwgZ2V0VG91Y2hlcywgZGV0ZWN0RG91YmxlVGFwLCBjYWxjU2NhbGUgfSBmcm9tICcuL3V0aWxzL2hhbmRsZS1ldmVudCc7XG5pbXBvcnQgc2NhbGVFbGVtZW50IGZyb20gJy4vdXRpbHMvaGFuZGxlLWVsZW1lbnQnO1xuaW1wb3J0IHsgaXNXaXRoaW4sIGNhbGNOZXdTY2FsZSwgYWRkT2Zmc2V0LCBnZXRJbml0aWFsU2NhbGUsIGdldFNjYWxlRmFjdG9yLCBnZXRab29tRmFjdG9yLCBnZXRUb3VjaENlbnRlciB9IGZyb20gJy4vdXRpbHMvaGFuZGxlLXBpbmNoJztcbmltcG9ydCB7IGRyYWcsIHNhbml0aXplT2Zmc2V0IH0gZnJvbSAnLi91dGlscy9oYW5kbGUtZHJhZyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9kZWZhdWx0cyc7XG5cbmNvbnN0IGZpcnN0ID0gKGl0ZW1zOiBBcnJheTxPYmplY3Q+KSA9PiBpdGVtc1swXTtcblxuY29uc3Qgc2V0VGFyZ2V0ID0gKGVsLCBvcHRzKSA9PiAoXG4gIGVsLnF1ZXJ5U2VsZWN0b3Iob3B0cy50YXJnZXQgPyBgaW1nJHtvcHRzLnRhcmdldH1gIDogJ2ltZycpXG4pO1xuXG5jb25zdCBwaW5jaEl0ID0gKHRhcmdldHM6IHN0cmluZyB8IE9iamVjdCwgb3B0aW9uczogT2JqZWN0ID0ge30pID0+IHtcbiAgLy8gcHJpdmF0ZSB2YXJpYWJsZSBjYWNoZVxuICBsZXQgZWxlbWVudCA9IG51bGw7XG5cbiAgbGV0IHNjYWxpbmc7XG4gIGxldCBsYXN0U2NhbGUgPSAxO1xuICBsZXQgc3RhcnRUb3VjaGVzO1xuXG4gIGxldCB6b29tRmFjdG9yID0gMTtcblxuICBsZXQgb2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gIGxldCBsYXN0Wm9vbUNlbnRlciA9IGZhbHNlO1xuICBsZXQgbGFzdERyYWdQb3NpdGlvbiA9IGZhbHNlO1xuXG4gIC8vIEJhc2UgY29uZmlndXJhdGlvbiBmb3IgdGhlIHBpbmNoIGluc3RhbmNlXG4gIGNvbnN0IG9wdHMgPSB7Li4uZGVmYXVsdHMsIC4uLm9wdGlvbnN9O1xuICBjb25zdCB7IG9uLCBkaXNwYXRjaCB9ID0gZXZlbnREaXNwYXRjaGVyKCk7XG5cbiAvKipcbiAgKiAgZGlzcGF0Y2hQaW5jaEV2ZW50IC0gU2hvcnRoYW5kIG1ldGhvZCBmb3IgY3JlYXRpbmcgZXZlbnRzXG4gICpcbiAgKiAgQHBhcmFtIHsgU3RyaW5nIH0gcGhhc2VcbiAgKiAgQHBhcmFtIHsgU3RyaW5nIH0gdHlwZVxuICAqICBAcGFyYW0geyBPYmplY3QgfSBkZXRhaWxzXG4gICogIEByZXR1cm4geyBWb2lkIH1cbiAgKiovXG4gIGNvbnN0IGRpc3BhdGNoUGluY2hFdmVudCA9IChldmVudE5hbWU6IHN0cmluZywgcGhhc2U6IHN0cmluZywgZGF0YTogT2JqZWN0ID0ge30pOiB2b2lkID0+IHtcbiAgICBkaXNwYXRjaChldmVudE5hbWUsIE9iamVjdC5hc3NpZ24oZGF0YSwge1xuICAgICAgcGhhc2VcbiAgICB9KSk7XG4gIH07XG5cbiAgY29uc3QgcmVzZXRHbG9iYWxzID0gKC8qIG9wdHMgKi8pOiB2b2lkID0+IHtcbiAgICBzY2FsaW5nID0gdW5kZWZpbmVkO1xuICAgIGxhc3RTY2FsZSA9IDE7XG4gICAgc3RhcnRUb3VjaGVzID0gbnVsbDtcbiAgICB6b29tRmFjdG9yID0gMTtcbiAgICBsYXN0Wm9vbUNlbnRlciA9IGZhbHNlO1xuXG4gICAgbGFzdERyYWdQb3NpdGlvbiA9IGZhbHNlO1xuICAgIG9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICB9O1xuXG4gIC8vIGV2ZW50IGhhbmRsaW5nXG4gIC8qKlxuICAgKiBTZXQgc2NhbGluZyBpZiB3ZSBhcmUgdXNpbmcgbW9yZSB0aGVuIG9uZSBmaW5nZXJcbiAgICogYW5kIGNhcHR1cmVzIG91ciBmaXJzdCBwdW5jaCBwb2ludFxuICAgKlxuICAgKiBwcml2YXRlXG4gICAqIEBwYXJhbSB7IE9iamVjdCB9IGUgdGhlIGV2ZW50IGZyb20gb3VyIGV2ZW50bGlzdGVuZXJcbiAgICovXG4gIGNvbnN0IG9uVG91Y2hzdGFydCA9IChlOiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCd0b3VjaHN0YXJ0JywgJ2JlZm9yZScsIGUpO1xuXG5cbiAgICBzY2FsaW5nID0gKGUudG91Y2hlcy5sZW5ndGggPT09IDIpO1xuICAgIHN0YXJ0VG91Y2hlcyA9IEFycmF5LmZyb20oZS50b3VjaGVzKTtcbiAgICBsYXN0U2NhbGUgPSAxO1xuXG4gICAgaWYgKGRldGVjdERvdWJsZVRhcChlKSkge1xuICAgICAgY29uc3QgaW1hZ2UgPSBlLmN1cnJlbnRUYXJnZXQucXVlcnlTZWxlY3RvcignaW1nJyk7XG4gICAgICBzY2FsZUVsZW1lbnQoZS50YXJnZXQsIGltYWdlLCAxLCB7IHg6IDAsIHk6IDAgfSwgb3B0cy5zbmFwQmFja1NwZWVkLCBvcHRzLmVhc2UpO1xuICAgICAgcmVzZXRHbG9iYWxzKCk7XG4gICAgfVxuXG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCd0b3VjaHN0YXJ0JywgJ2FmdGVyJywgZSk7XG4gIH07XG5cbiAgY29uc3Qgb25Ub3VjaG1vdmUgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGRpc3BhdGNoUGluY2hFdmVudCgndG91Y2htb3ZlJywgJ2JlZm9yZScsIGUpO1xuXG4gICAgaWYgKCghc2NhbGluZyB8fCAhc3RhcnRUb3VjaGVzKSAmJiB6b29tRmFjdG9yID4gMSkge1xuICAgICAgY2FuY2VsRXZlbnQoZSk7XG5cbiAgICAgIGNvbnN0IHRvdWNoID0gZmlyc3QoZ2V0VG91Y2hlcyhlLmN1cnJlbnRUYXJnZXQsIEFycmF5LmZyb20oZS50b3VjaGVzKSkpO1xuICAgICAgY29uc3QgZHJhZ09mZnNldCA9IGRyYWcodG91Y2gsIGxhc3REcmFnUG9zaXRpb24sIG9mZnNldCwgem9vbUZhY3Rvcik7XG5cbiAgICAgIG9mZnNldCA9IHNhbml0aXplT2Zmc2V0KGUudGFyZ2V0LCBkcmFnT2Zmc2V0LCB6b29tRmFjdG9yKTtcbiAgICAgIGxhc3REcmFnUG9zaXRpb24gPSB0b3VjaDtcbiAgICB9IGVsc2UgaWYgKHNjYWxpbmcgJiYgc3RhcnRUb3VjaGVzKSB7XG4gICAgICBjYW5jZWxFdmVudChlKTtcblxuICAgICAgLy8gYSByZWxhdGl2ZSBzY2FsZSBmYWN0b3IgaXMgdXNlZFxuICAgICAgY29uc3QgdG91Y2hDZW50ZXIgPSBnZXRUb3VjaENlbnRlcihnZXRUb3VjaGVzKGUuY3VycmVudFRhcmdldCwgQXJyYXkuZnJvbShlLnRvdWNoZXMpKSk7XG4gICAgICBjb25zdCBuZXdTY2FsZSA9IGNhbGNTY2FsZShlLmN1cnJlbnRUYXJnZXQsIHN0YXJ0VG91Y2hlcywgQXJyYXkuZnJvbShlLnRvdWNoZXMpKTtcbiAgICAgIGNvbnN0IHNjYWxlVmFsdWUgPSBjYWxjTmV3U2NhbGUobmV3U2NhbGUsIGxhc3RTY2FsZSk7XG4gICAgICBjb25zdCBzY2FsZSA9IGdldFNjYWxlRmFjdG9yKHNjYWxlVmFsdWUsIHpvb21GYWN0b3IsIG9wdHMpO1xuXG4gICAgICB6b29tRmFjdG9yID0gZ2V0Wm9vbUZhY3RvcihzY2FsZVZhbHVlLCB6b29tRmFjdG9yLCBvcHRzKTtcblxuICAgICAgb2Zmc2V0ID0gYWRkT2Zmc2V0KG9mZnNldCwge1xuICAgICAgICB4OiAoc2NhbGUgLSAxKSAqICh0b3VjaENlbnRlci54ICsgb2Zmc2V0LngpLFxuICAgICAgICB5OiAoc2NhbGUgLSAxKSAqICh0b3VjaENlbnRlci55ICsgb2Zmc2V0LnkpXG4gICAgICB9KTtcblxuICAgICAgbGFzdFNjYWxlID0gbmV3U2NhbGU7XG4gICAgICBvZmZzZXQgPSBkcmFnKHRvdWNoQ2VudGVyLCBsYXN0Wm9vbUNlbnRlciwgb2Zmc2V0LCB6b29tRmFjdG9yKTtcbiAgICAgIGxhc3Rab29tQ2VudGVyID0gdG91Y2hDZW50ZXI7XG4gICAgfVxuXG4gICAgY29uc3QgaW1hZ2UgPSBlLmN1cnJlbnRUYXJnZXQucXVlcnlTZWxlY3RvcignaW1nJyk7XG4gICAgc2NhbGVFbGVtZW50KGUudGFyZ2V0LCBpbWFnZSwgem9vbUZhY3Rvciwgb2Zmc2V0LCAwLCBvcHRzLmVhc2UpO1xuXG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCd0b3VjaG1vdmUnLCAnYWZ0ZXInLCBlKTtcbiAgfTtcblxuICBjb25zdCBvblRvdWNoZW5kID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ3RvdWNoZW5kJywgJ2JlZm9yZScsIGUpO1xuXG4gICAgaWYgKHpvb21GYWN0b3IpIHtcbiAgICAgIGlmICghaXNXaXRoaW4oem9vbUZhY3Rvciwgb3B0cykpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBlLmN1cnJlbnRUYXJnZXQucXVlcnlTZWxlY3RvcignaW1nJyk7XG4gICAgICAgIGNvbnN0IGlzTGVzc1RoYW4gPSAoZ2V0SW5pdGlhbFNjYWxlKGUudGFyZ2V0LCBpbWFnZSkgKiB6b29tRmFjdG9yIDwgb3B0cy5taW5TY2FsZSk7XG4gICAgICAgIGNvbnN0IGxhc3Rab29tID0gem9vbUZhY3RvcjtcbiAgICAgICAgem9vbUZhY3RvciA9IGlzTGVzc1RoYW4gPyBvcHRzLm1pblNjYWxlIDogb3B0cy5tYXhTY2FsZTtcbiAgICAgICAgY29uc3Qgc2NhbGVWYWx1ZSA9IGNhbGNOZXdTY2FsZSh6b29tRmFjdG9yLCBsYXN0Wm9vbSk7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gZ2V0U2NhbGVGYWN0b3Ioc2NhbGVWYWx1ZSwgem9vbUZhY3Rvciwgb3B0cyk7XG4gICAgICAgIG9mZnNldCA9IGFkZE9mZnNldChvZmZzZXQsIHtcbiAgICAgICAgICB4OiAoc2NhbGUgLSAxKSAqIChsYXN0Wm9vbUNlbnRlci54ICsgb2Zmc2V0LngpLFxuICAgICAgICAgIHk6IChzY2FsZSAtIDEpICogKGxhc3Rab29tQ2VudGVyLnkgKyBvZmZzZXQueSlcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZnNldCA9IHNhbml0aXplT2Zmc2V0KGUudGFyZ2V0LCBvZmZzZXQsIHpvb21GYWN0b3IpO1xuICAgICAgICBzY2FsZUVsZW1lbnQoZS50YXJnZXQsIGltYWdlLCB6b29tRmFjdG9yLCBvZmZzZXQsIG9wdHMuc25hcEJhY2tTcGVlZCwgb3B0cy5lYXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0U2NhbGUgPSAxO1xuICAgIGxhc3REcmFnUG9zaXRpb24gPSBmYWxzZTtcbiAgICBsYXN0Wm9vbUNlbnRlciA9IGZhbHNlO1xuXG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCd0b3VjaGVuZCcsICdhZnRlcicsIGUpO1xuICB9O1xuXG4gIGNvbnN0IGF0dGFjaEV2ZW50cyA9IChlbDogSFRNTEVsZW1lbnQpID0+IHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaHN0YXJ0KTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNobW92ZSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoZW5kKTtcbiAgfTtcblxuICBjb25zdCBkZXRhY2hoRXZlbnRzID0gKGVsOiBPYmplY3QpID0+IHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaHN0YXJ0KTtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNobW92ZSk7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoZW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogcHVibGljXG4gICAqIHJlc2V0IGZ1bmN0aW9uOlxuICAgKiBAcGFyYW0geyBOdW1iZXIgfSBkdXJhdGlvblxuICAgKiBAcGFyYW0geyBTdHJpbmcgfSBlYXNpbmdcbiAgICogQHJldHVybiB7IFZvaWQgfVxuICAgKi9cbiAgY29uc3QgcmVzZXQgPSAob3B0OiBPYmplY3QgPSB7fSk6IHZvaWQgPT4ge1xuICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xuICAgIGNvbnN0IGltYWdlID0gc2V0VGFyZ2V0KGVsZW1lbnQsIG9wdHMpO1xuICAgIGlmICghaW1hZ2UpIHJldHVybjtcbiAgICBjb25zdCB7IHNuYXBCYWNrU3BlZWQsIGVhc2luZyB9ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cywgb3B0KTtcbiAgICBzY2FsZUVsZW1lbnQoZWxlbWVudCwgaW1hZ2UsIDEsIHsgeDogMCwgeTogMCB9LCBzbmFwQmFja1NwZWVkLCBlYXNpbmcpO1xuICAgIHJlc2V0R2xvYmFscygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBwdWJsaWNcbiAgICogZGVzdHJveSBmdW5jdGlvbjogY2FsbGVkIHRvIGdyYWNlZnVsbHkgZGVzdHJveSB0aGUgbG9yeSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHsgVm9pZCB9XG4gICAqL1xuICBjb25zdCBkZXN0cm95ID0gKG9wdDogT2JqZWN0ID0ge30pOiB2b2lkID0+IHtcbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ2Rlc3Ryb3knLCAnYmVmb3JlJywge30pO1xuICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xuICAgIHJlc2V0KG9wdCk7XG4gICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgIGRldGFjaGhFdmVudHMoZWxlbWVudCk7XG4gICAgZWxlbWVudCA9IG51bGw7XG4gICAgcmVzZXRHbG9iYWxzKCk7XG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCdkZXN0cm95JywgJ2FmdGVyJywge30pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBzZXR1cCAtIEluaXQgZnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHsgU3RyaW5nLCBPYmplY3QgfVxuICAgKiBAcmV0dXJuIHsgVm9pZCB9XG4gICAqKi9cbiAgY29uc3Qgc2V0dXAgPSAodGFyZ2V0OiBzdHJpbmcgfCBPYmplY3QpOiB2b2lkID0+IHtcbiAgICBpZiAoZWxlbWVudCkgZGVzdHJveSgpO1xuICAgIGRpc3BhdGNoUGluY2hFdmVudCgnaW5pdCcsICdiZWZvcmUnLCB7fSk7XG4gICAgLy8gcmVzb2x2ZSB0YXJnZXRcbiAgICAvLyBwaW5jaGl0IGFsbG93cyBmb3IgYm90aCBhIG5vZGUgb3IgYSBzdHJpbmcgdG8gYmUgcGFzc2VkXG4gICAgc3dpdGNoICh0eXBlb2YgdGFyZ2V0KSB7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBlbGVtZW50ID0gdGFyZ2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgICAgIGNvbnNvbGUud2FybignbWlzc2luZyB0YXJnZXQsIGVpdGhlciBwYXNzIGFuIG5vZGUgb3IgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgYXR0YWNoRXZlbnRzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGRpc3BhdGNoUGluY2hFdmVudCgnaW5pdCcsICdhZnRlcicsIHt9KTtcbiAgfTtcblxuICAvLyB0cmlnZ2VyIGluaXRpYWwgc2V0dXBcbiAgc2V0dXAodGFyZ2V0cyk7XG5cbiAgcmV0dXJuIHtcbiAgICBzZXR1cCxcbiAgICByZXNldCxcbiAgICBkZXN0cm95LFxuICAgIGVsZW1lbnQsXG4gICAgb24sXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwaW5jaEl0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BpbmNoLWl0LmpzIiwiLyoqXG4gKiBEZXRlY3RpbmcgcHJlZml4ZXMgZm9yIHNhdmluZyB0aW1lIGFuZCBieXRlc1xuICovXG5leHBvcnQgZGVmYXVsdCAoKSA9PiB7XG4gIGxldCB0cmFuc2Zvcm07XG4gIGxldCB0cmFuc2l0aW9uO1xuICBsZXQgdHJhbnNpdGlvbkVuZDtcbiAgbGV0IGhhc1NjYWxlM2Q7XG5cbiAgKCgpID0+IHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ18nKTtcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuXG4gICAgaWYgKHN0eWxlLndlYmtpdFRyYW5zaXRpb24gPT09ICcnKSB7XG4gICAgICB0cmFuc2l0aW9uRW5kID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICAgICAgdHJhbnNpdGlvbiA9ICd3ZWJraXRUcmFuc2l0aW9uJztcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUudHJhbnNpdGlvbiA9PT0gJycpIHtcbiAgICAgIHRyYW5zaXRpb25FbmQgPSAndHJhbnNpdGlvbmVuZCc7XG4gICAgICB0cmFuc2l0aW9uID0gJ3RyYW5zaXRpb24nO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPT09ICcnKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAnd2Via2l0VHJhbnNmb3JtJztcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUubXNUcmFuc2Zvcm0gPT09ICcnKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAnbXNUcmFuc2Zvcm0nO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS50cmFuc2Zvcm0gPT09ICcnKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAndHJhbnNmb3JtJztcbiAgICB9XG5cbiAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShlbCwgbnVsbCk7XG4gICAgc3R5bGVbdHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSc7XG4gICAgaGFzU2NhbGUzZCA9ICEhZ2xvYmFsLmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUodHJhbnNmb3JtKTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgfSkoKTtcblxuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybSxcbiAgICB0cmFuc2l0aW9uLFxuICAgIHRyYW5zaXRpb25FbmQsXG4gICAgaGFzU2NhbGUzZFxuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9kZXRlY3QtcHJlZml4ZXMuanMiLCIvLyBAZmxvd1xuXG4vKipcbiAqIGRpc3BhdGNoIGN1c3RvbSBldmVudHNcbiAqL1xuXG5jb25zdCBldmVudERpc3BhdGNoZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGV2ZW50cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGhhbmRsZXIgZm9yIGV2ZW50LCB0byBiZSBmaXJlZFxuICAgKiBmb3IgZXZlcnkgZXZlbnQuXG4gICAqL1xuICBjb25zdCBvbiA9IChldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogRnVuY3Rpb24pID0+IHtcbiAgICBldmVudHNbZXZlbnROYW1lXSA9IGV2ZW50c1tldmVudE5hbWVdIHx8IFtdO1xuICAgIGV2ZW50c1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIGRpc3BhdGNoIGFuIGV2ZW50IGZvciBhIGhhbmRsZXIuXG4gICAqL1xuICBjb25zdCBkaXNwYXRjaCA9IChldmVudE5hbWU6IHN0cmluZywgZGF0YTogT2JqZWN0KSA9PiB7XG4gICAgaWYgKGV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICBldmVudHNbZXZlbnROYW1lXS5mb3JFYWNoKChmbikgPT4ge1xuICAgICAgICBmbihkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG9uLFxuICAgIGRpc3BhdGNoLFxuICB9O1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBldmVudERpc3BhdGNoZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvZGlzcGF0Y2gtZXZlbnQuanMiLCIvLyBAZmxvd1xuXG5pbXBvcnQgeyBnZXRYLCBnZXRZLCBhZGRPZmZzZXQgfSBmcm9tICcuL2hhbmRsZS1waW5jaCc7XG5cbnR5cGUgQ2VudGVyID0ge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbn07XG5cbmNvbnN0IGNhbGNNYXggPSAoZWw6IEV2ZW50VGFyZ2V0LCBkaWZmZXI6IG51bWJlciwgem9vbUZhY3RvcjogbnVtYmVyKTogT2JqZWN0ID0+ICh7XG4gIG1heFg6ICh6b29tRmFjdG9yIC0gZGlmZmVyKSAqIGdldFgoZWwpLFxuICBtYXhZOiAoem9vbUZhY3RvciAtIGRpZmZlcikgKiBnZXRZKGVsKSxcbn0pO1xuXG5leHBvcnQgY29uc3Qgc2FuaXRpemVPZmZzZXQgPSAoZWw6IEV2ZW50VGFyZ2V0LCBvZmZzZXQ6IENlbnRlciwgem9vbUZhY3RvcjogbnVtYmVyKTogT2JqZWN0ID0+IHtcbiAgY29uc3QgeyBtYXhYLCBtYXhZIH0gPSBjYWxjTWF4KGVsLCAxLCB6b29tRmFjdG9yKTtcbiAgY29uc3QgbWF4T2Zmc2V0WCA9IE1hdGgubWF4KG1heFgsIDApO1xuICBjb25zdCBtYXhPZmZzZXRZID0gTWF0aC5tYXgobWF4WSwgMCk7XG4gIGNvbnN0IG1pbk9mZnNldFggPSBNYXRoLm1pbihtYXhYLCAwKTtcbiAgY29uc3QgbWluT2Zmc2V0WSA9IE1hdGgubWluKG1heFksIDApO1xuXG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5taW4oTWF0aC5tYXgob2Zmc2V0LngsIG1pbk9mZnNldFgpLCBtYXhPZmZzZXRYKSxcbiAgICB5OiBNYXRoLm1pbihNYXRoLm1heChvZmZzZXQueSwgbWluT2Zmc2V0WSksIG1heE9mZnNldFkpXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZHJhZyA9IChjZW50ZXI6IENlbnRlciwgbGFzdENlbnRlcjogQ2VudGVyLCBsYXN0T2Zmc2V0OiBPYmplY3QsIHpvb21GYWN0b3I6IG51bWJlcik6IE9iamVjdCA9PiAoXG4gIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGFzdENlbnRlciwgJ3gnKSlcbiAgPyBhZGRPZmZzZXQobGFzdE9mZnNldCwge1xuICAgIHg6IC0oKChjZW50ZXIueCAtIGxhc3RDZW50ZXIueCkgKiB6b29tRmFjdG9yKSAvIHpvb21GYWN0b3IpLFxuICAgIHk6IC0oKChjZW50ZXIueSAtIGxhc3RDZW50ZXIueSkgKiB6b29tRmFjdG9yKSAvIHpvb21GYWN0b3IpLFxuICB9KVxuICA6IGxhc3RPZmZzZXRcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvaGFuZGxlLWRyYWcuanMiLCIvLyBAZmxvd1xuXG5pbXBvcnQgZGV0ZWN0UHJlZml4ZXMgZnJvbSAnLi9kZXRlY3QtcHJlZml4ZXMnO1xuaW1wb3J0IHsgZ2V0SW5pdGlhbFNjYWxlIH0gZnJvbSAnLi9oYW5kbGUtcGluY2gnO1xuXG5jb25zdCBwcmVmaXhlcyA9IGRldGVjdFByZWZpeGVzKCk7XG5cbmNvbnN0IGhhbmRsZUFuaW1hdGlvbiA9IChlbDogSFRNTEVsZW1lbnQsIHRyYW5zaXRpb246IHN0cmluZywgZHVyYXRpb246IG51bWJlciwgZWFzZTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIGNvbnN0IHsgc3R5bGUgfSA9IGVsO1xuICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCUgMCUnO1xuICBzdHlsZVtgJHt0cmFuc2l0aW9ufVRpbWluZ0Z1bmN0aW9uYF0gPSBlYXNlO1xuICBzdHlsZVtgJHt0cmFuc2l0aW9ufUR1cmF0aW9uYF0gPSBgJHtkdXJhdGlvbn1tc2A7XG59O1xuXG4vKipcbiAqIHNjYWxlRWxlbWVudCAtdHJhbnNkb3JtcyB0byBhIGdpdmVuIHBvc2l0aW9uIGluIGEgZ2l2ZW4gdGltZSBpbiBtaWxsaXNlY29uZHNcbiAqXG4gKiBAcGFyYW0geyBPYmplY3QgfSBlbCBlbGVtZW50IGZyb20gdGhlIGV2ZW50c1xuICogQHBhcmFtIHsgTnVtYmVyIH0gcGluY2ggbnVtYmVyIHdoZXJlIHRvIHNjYWxlIHRvXG4gKiBAcGFyYW0geyBPYmplY3QgfSBjb29yZHMgb2JqZWN0IHdoZXJlIHRvIHRyYW5zbGF0ZSB0b1xuICogQHBhcmFtIHsgTnVtYmVyIH0gZHVyYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2lzdGlvblxuICogQHBhcmFtIHsgU3RyaW5nIH0gZWFzZSBlYXNpbmcgY3NzIHByb3BlcnR5XG4gKiBAcmV0dXJuIHsgVm9pZCB9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgKGVsOiBIVE1MRWxlbWVudCwgaW1hZ2U6IEhUTUxFbGVtZW50LCBwaW5jaDogbnVtYmVyLCBjb29yZHM6IE9iamVjdCwgZHVyYXRpb246IG51bWJlciwgZWFzZTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIGNvbnN0IHsgdHJhbnNpdGlvbiwgdHJhbnNmb3JtLCBoYXNTY2FsZTNkIH0gPSBwcmVmaXhlcztcbiAgY29uc3QgeyBzdHlsZSB9ID0gaW1hZ2U7XG5cbiAgY29uc3Qgem9vbUZhY3RvciA9IGdldEluaXRpYWxTY2FsZShlbCwgaW1hZ2UpICogcGluY2g7XG5cbiAgY29uc3Qgb2Zmc2V0WCA9IC1jb29yZHMueDtcbiAgY29uc3Qgb2Zmc2V0WSA9IC1jb29yZHMueTtcblxuICBoYW5kbGVBbmltYXRpb24oaW1hZ2UsIHRyYW5zaXRpb24sIGR1cmF0aW9uLCBlYXNlKTtcbiAgY29uc3Qgc2NhbGVQcm9wID0gKGhhc1NjYWxlM2QpXG4gICAgPyBgc2NhbGUzZCgke3pvb21GYWN0b3J9LCAke3pvb21GYWN0b3J9LCAxKWBcbiAgICA6IGBzY2FsZSgke3pvb21GYWN0b3J9LCAke3pvb21GYWN0b3J9KWA7XG4gIGNvbnN0IHRyYW5zbGF0ZVByb3AgPSBgdHJhbnNsYXRlKCR7b2Zmc2V0WH1weCwgJHtvZmZzZXRZfXB4KWA7XG5cbiAgc3R5bGVbdHJhbnNmb3JtXSA9IGAke3RyYW5zbGF0ZVByb3B9ICR7c2NhbGVQcm9wfWA7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL2hhbmRsZS1lbGVtZW50LmpzIiwiLy8gQGZsb3dcbmxldCBsYXN0VG91Y2hTdGFydCA9IDA7XG5cbnR5cGUgVG9jaFBhZ2UgPSB7XG4gIHBhZ2VYOiBudW1iZXI7XG4gIHBhZ2VZOiBudW1iZXI7XG59XG5cbnR5cGUgVG91Y2ggPSB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBjYW5jZWxFdmVudCAtIENhbmNlbCBFdmVudHMgc28gd2UgZG9udCBidWJibGUgdXAgb3VyIGV2ZW50cyB0byB0aGUgZG9jdW1lbnRcbiAqXG4gKiBAcGFyYW0geyBPYmplY3QgfSBldmVudFxuICogQHJldHVybiB7IFZvaWQgfVxuICoqL1xuZXhwb3J0IGNvbnN0IGNhbmNlbEV2ZW50ID0gKGU6IEV2ZW50KTogdm9pZCA9PiB7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn07XG5cbi8qKlxuICogZGV0ZWN0RG91YmxlVGFwIC0gQ2hlY2sgaWYgd2UgYXJlIGRvdWJsZSB0YXBwaW5nXG4gKlxuICogQHBhcmFtIHsgT2JqZWN0IH0gZXZlbnRcbiAqIEByZXR1cm4geyBCb29sZWFuIH1cbiAqKi9cbmV4cG9ydCBjb25zdCBkZXRlY3REb3VibGVUYXAgPSAoZTogVG91Y2hFdmVudCk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCB0aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICBsYXN0VG91Y2hTdGFydCA9IDA7XG4gIH1cblxuICBpZiAodGltZSAtIGxhc3RUb3VjaFN0YXJ0IDwgMzAwKSB7XG4gICAgY2FuY2VsRXZlbnQoZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGxhc3RUb3VjaFN0YXJ0ID0gdGltZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHRvdWNoZXMgb2YgYW4gZXZlbnQgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBvZmZzZXRcbiAqXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEByZXR1cm4gYXJyYXkgdG91Y2hlc1xuICovXG5leHBvcnQgY29uc3QgZ2V0VG91Y2hlcyA9IChlbDogRXZlbnRUYXJnZXQsIHRvdWNoZXM6IEFycmF5PFRvY2hQYWdlPik6IEFycmF5PFRvdWNoPiA9PiB7XG4gIGNvbnN0IHBvc2l0aW9uID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB0b3VjaGVzLm1hcCh0b3VjaCA9PiAoe1xuICAgIHg6IHRvdWNoLnBhZ2VYIC0gKHBvc2l0aW9uLmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQpLFxuICAgIHk6IHRvdWNoLnBhZ2VZIC0gKHBvc2l0aW9uLnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKSxcbiAgfSkpO1xufTtcblxuLyoqXG4gKiBnZXREaXN0YW5jZSAtIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBvdXIgZmluZ2Vyc1xuICpcbiAqIEBwYXJhbSB7IEFycmF5IH0gdG91Y2hlcyB0b3VjaGVzIHBhc3NhcyBhbiBhcnJheSBmcm9tIFRvdWNoTGlzdFxuICogQHJldHVybiB7IE51bWJlciB9IHRoZSBjYWxjdWFsdGVkIGRpc3RhbmNlIGJldHdlZW4gdGhlIGZpbmdlcnNcbiAqKi9cbmV4cG9ydCBjb25zdCBnZXREaXN0YW5jZSA9ICh0b3VjaGVzOiBBcnJheTxUb3VjaD4pOiBudW1iZXIgPT4ge1xuICBjb25zdCBbZmlyc3QsIHNlY29uZF0gPSB0b3VjaGVzO1xuICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICgoZmlyc3QueCAtIHNlY29uZC54KSAqIChmaXJzdC54IC0gc2Vjb25kLngpKSArXG4gICAgKChmaXJzdC55IC0gc2Vjb25kLnkpICogKGZpcnN0LnkgLSBzZWNvbmQueSkpXG4gICk7XG59O1xuXG4vKipcbiAqIGNhbGNTY2FsZSAtIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB3aGVyZSB3ZSBzdGFydCBvdXIgcGluY2hcbiAqIHRvIHdoZXJlIHdlIGVuZCBpdFxuICpcbiAqIEBwYXJhbSB7IEFycmF5IH0gc3RhcnRUb3VjaCBUaGUgc3RhcnRpbmcgcG9pbnQgb2Ygb3VyIHRvdWNoXG4gKiBAcGFyYW0geyBBcnJheSB9IGVuZFRvdWNoIFRoZSBjdXJyZW50IHBvaW50IG9mIG91ciB0b3VjaFxuICogQHJldHVybiB7IE51bWJlciB9XG4gKi9cbmV4cG9ydCBjb25zdCBjYWxjU2NhbGUgPSAoZWw6IEV2ZW50VGFyZ2V0LCBzdGFydFRvdWNoOiBBcnJheTxPYmplY3Q+LCBlbmRUb3VjaDogQXJyYXk8T2JqZWN0Pik6IG51bWJlciA9PiAoXG4gIGdldERpc3RhbmNlKGdldFRvdWNoZXMoZWwsIGVuZFRvdWNoKSkgLyBnZXREaXN0YW5jZShnZXRUb3VjaGVzKGVsLCBzdGFydFRvdWNoKSlcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvaGFuZGxlLWV2ZW50LmpzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qKlxcbiAqIHByaXNtLmpzIGRlZmF1bHQgdGhlbWUgZm9yIEphdmFTY3JpcHQsIENTUyBhbmQgSFRNTFxcbiAqIEJhc2VkIG9uIGRhYmJsZXQgKGh0dHA6Ly9kYWJibGV0LmNvbSlcXG4gKiBAYXV0aG9yIExlYSBWZXJvdVxcbiAqL1xcblxcbmNvZGVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSxcXG5wcmVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSB7XFxuXFx0Y29sb3I6IGJsYWNrO1xcblxcdGJhY2tncm91bmQ6IG5vbmU7XFxuXFx0dGV4dC1zaGFkb3c6IDAgMXB4IHdoaXRlO1xcblxcdGZvbnQtZmFtaWx5OiBDb25zb2xhcywgTW9uYWNvLCAnQW5kYWxlIE1vbm8nLCAnVWJ1bnR1IE1vbm8nLCBtb25vc3BhY2U7XFxuXFx0dGV4dC1hbGlnbjogbGVmdDtcXG5cXHR3aGl0ZS1zcGFjZTogcHJlO1xcblxcdHdvcmQtc3BhY2luZzogbm9ybWFsO1xcblxcdHdvcmQtYnJlYWs6IG5vcm1hbDtcXG5cXHR3b3JkLXdyYXA6IG5vcm1hbDtcXG5cXHRsaW5lLWhlaWdodDogMS41O1xcblxcblxcdC1tb3otdGFiLXNpemU6IDQ7XFxuXFx0LW8tdGFiLXNpemU6IDQ7XFxuXFx0dGFiLXNpemU6IDQ7XFxuXFxuXFx0LXdlYmtpdC1oeXBoZW5zOiBub25lO1xcblxcdC1tb3otaHlwaGVuczogbm9uZTtcXG5cXHQtbXMtaHlwaGVuczogbm9uZTtcXG5cXHRoeXBoZW5zOiBub25lO1xcbn1cXG5cXG5wcmVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXTo6LW1vei1zZWxlY3Rpb24sIHByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIDo6LW1vei1zZWxlY3Rpb24sXFxuY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdOjotbW96LXNlbGVjdGlvbiwgY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIDo6LW1vei1zZWxlY3Rpb24ge1xcblxcdHRleHQtc2hhZG93OiBub25lO1xcblxcdGJhY2tncm91bmQ6ICNiM2Q0ZmM7XFxufVxcblxcbnByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdOjpzZWxlY3Rpb24sIHByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIDo6c2VsZWN0aW9uLFxcbmNvZGVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXTo6c2VsZWN0aW9uLCBjb2RlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0gOjpzZWxlY3Rpb24ge1xcblxcdHRleHQtc2hhZG93OiBub25lO1xcblxcdGJhY2tncm91bmQ6ICNiM2Q0ZmM7XFxufVxcblxcbkBtZWRpYSBwcmludCB7XFxuXFx0Y29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdLFxcblxcdHByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIHtcXG5cXHRcXHR0ZXh0LXNoYWRvdzogbm9uZTtcXG5cXHR9XFxufVxcblxcbi8qIENvZGUgYmxvY2tzICovXFxucHJlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0ge1xcblxcdHBhZGRpbmc6IDFlbTtcXG5cXHRtYXJnaW46IC41ZW0gMDtcXG5cXHRvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuOm5vdChwcmUpID4gY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdLFxcbnByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIHtcXG5cXHRiYWNrZ3JvdW5kOiAjZjVmMmYwO1xcbn1cXG5cXG4vKiBJbmxpbmUgY29kZSAqL1xcbjpub3QocHJlKSA+IGNvZGVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSB7XFxuXFx0cGFkZGluZzogLjFlbTtcXG5cXHRib3JkZXItcmFkaXVzOiAuM2VtO1xcblxcdHdoaXRlLXNwYWNlOiBub3JtYWw7XFxufVxcblxcbi50b2tlbi5jb21tZW50LFxcbi50b2tlbi5wcm9sb2csXFxuLnRva2VuLmRvY3R5cGUsXFxuLnRva2VuLmNkYXRhIHtcXG5cXHRjb2xvcjogc2xhdGVncmF5O1xcbn1cXG5cXG4udG9rZW4ucHVuY3R1YXRpb24ge1xcblxcdGNvbG9yOiAjOTk5O1xcbn1cXG5cXG4ubmFtZXNwYWNlIHtcXG5cXHRvcGFjaXR5OiAuNztcXG59XFxuXFxuLnRva2VuLnByb3BlcnR5LFxcbi50b2tlbi50YWcsXFxuLnRva2VuLmJvb2xlYW4sXFxuLnRva2VuLm51bWJlcixcXG4udG9rZW4uY29uc3RhbnQsXFxuLnRva2VuLnN5bWJvbCxcXG4udG9rZW4uZGVsZXRlZCB7XFxuXFx0Y29sb3I6ICM5MDU7XFxufVxcblxcbi50b2tlbi5zZWxlY3RvcixcXG4udG9rZW4uYXR0ci1uYW1lLFxcbi50b2tlbi5zdHJpbmcsXFxuLnRva2VuLmNoYXIsXFxuLnRva2VuLmJ1aWx0aW4sXFxuLnRva2VuLmluc2VydGVkIHtcXG5cXHRjb2xvcjogIzY5MDtcXG59XFxuXFxuLnRva2VuLm9wZXJhdG9yLFxcbi50b2tlbi5lbnRpdHksXFxuLnRva2VuLnVybCxcXG4ubGFuZ3VhZ2UtY3NzIC50b2tlbi5zdHJpbmcsXFxuLnN0eWxlIC50b2tlbi5zdHJpbmcge1xcblxcdGNvbG9yOiAjYTY3ZjU5O1xcblxcdGJhY2tncm91bmQ6IGhzbGEoMCwgMCUsIDEwMCUsIC41KTtcXG59XFxuXFxuLnRva2VuLmF0cnVsZSxcXG4udG9rZW4uYXR0ci12YWx1ZSxcXG4udG9rZW4ua2V5d29yZCB7XFxuXFx0Y29sb3I6ICMwN2E7XFxufVxcblxcbi50b2tlbi5mdW5jdGlvbiB7XFxuXFx0Y29sb3I6ICNERDRBNjg7XFxufVxcblxcbi50b2tlbi5yZWdleCxcXG4udG9rZW4uaW1wb3J0YW50LFxcbi50b2tlbi52YXJpYWJsZSB7XFxuXFx0Y29sb3I6ICNlOTA7XFxufVxcblxcbi50b2tlbi5pbXBvcnRhbnQsXFxuLnRva2VuLmJvbGQge1xcblxcdGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4udG9rZW4uaXRhbGljIHtcXG5cXHRmb250LXN0eWxlOiBpdGFsaWM7XFxufVxcblxcbi50b2tlbi5lbnRpdHkge1xcblxcdGN1cnNvcjogaGVscDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3ByaXNtanMvdGhlbWVzL3ByaXNtLmNzc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cclxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXHJcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xyXG5cdFx0XHRpZihpdGVtWzJdKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHByaXNtIGZyb20gJ3ByaXNtanMnO1xuaW1wb3J0ICdwcmlzbWpzL3RoZW1lcy9wcmlzbS5jc3MnO1xuXG5pbXBvcnQgaGFuZGxlRXZlbnQgZnJvbSAnLi9oYW5kbGUtZXZlbnQnO1xuaW1wb3J0IHBpbmNoSXQgZnJvbSAnLi4vc3JjLyc7XG5cbnBpbmNoSXQoJy5leGFtcGxlLW9uZSAuaW1nLXdyYXBwZXInKTtcbnBpbmNoSXQoJy5leGFtcGxlLXRyZWUgLmltZy13cmFwcGVyJywge1xuICBtYXhTY2FsZTogNCxcbiAgbWluU2NhbGU6IDAuNSxcbiAgc25hcEJhY2tTcGVlZDogNTAwLFxufSk7XG5cbmNvbnN0IHBpbmNoSW1hZ2UgPSBwaW5jaEl0KCcuZXhhbXBsZS1mb3VyIC5pbWctd3JhcHBlcicsIHtcbiAgc25hcEJhY2tTcGVlZDogMTAwMCxcbn0pO1xuXG5kb2N1bWVudFxuICAucXVlcnlTZWxlY3RvcignLnJlc2V0LWJ1dHRvbicpXG4gIC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBwaW5jaEltYWdlLnJlc2V0KCk7XG4gIH0pO1xuXG5jb25zdCB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZXZlbnQtdGFyZ2V0Jyk7XG5jb25zdCBoYW5kbGVFdmVudEV4YW1wbGUgPSBoYW5kbGVFdmVudCh0YXJnZXQpO1xuY29uc3QgcGluY2hFdmVudCA9IHBpbmNoSXQoJy5leGFtcGxlLWZpdmUgLmltZy13cmFwcGVyJywge1xuICB0YXJnZXQ6ICdpbWcnLFxuICBzbmFwQmFja1NwZWVkOiAxMDAwLFxufSk7XG5cbnBpbmNoRXZlbnQub24oJ3RvdWNoc3RhcnQnLCBoYW5kbGVFdmVudEV4YW1wbGUpO1xucGluY2hFdmVudC5vbigndG91Y2htb3ZlJywgaGFuZGxlRXZlbnRFeGFtcGxlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3MvYXBwLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==