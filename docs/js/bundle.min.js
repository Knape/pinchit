/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 16);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var sum = function sum(acc, next) {
  return acc + next;
};

/**
 * Calculates the average of multiple vectors (x, y values)
 */
var getVectorAvg = function getVectorAvg(vectors) {
  return {
    x: vectors.map(function (v) {
      return v.x;
    }).reduce(sum) / vectors.length,
    y: vectors.map(function (v) {
      return v.y;
    }).reduce(sum) / vectors.length
  };
};

var getElement = function getElement(type) {
  return function (el) {
    return el instanceof HTMLImageElement ? el[type] : 1;
  };
};

/**
 * isWithin - Check if value is between two values
 *
 * @param { Number } scale current scale value
 * @param { Object } minPinch, maxPinh
 * @return { Boolean }
 **/
var isWithin = exports.isWithin = function isWithin(scale, opts) {
  var maxScale = opts.maxScale,
      minScale = opts.minScale;

  return scale >= minScale && scale <= maxScale;
};

/**
 * addOffset - Combine current offset with old offset and returns a new offset
 *
 * @param { Object } lastOffset last offset
 * @param { Object } offset, new offset
 * @return { Object }
 **/
var addOffset = exports.addOffset = function addOffset(lastOffset, offset) {
  return {
    x: lastOffset.x + offset.x,
    y: lastOffset.y + offset.y
  };
};

var getX = exports.getX = getElement('offsetWidth');
var getY = exports.getY = getElement('offsetHeight');

/**
 * getScale - Check if value is between two values
 *
 * @param { Node } el current scale value
 * @return { Number }
 **/
var getInitialScale = exports.getInitialScale = function getInitialScale(el, image) {
  return el instanceof HTMLImageElement ? getX(el) / image.offsetWidth : 1;
};

/**
 * Scales the zoom factor relative to current state
 *
 * @param scale
 * @return the actual scale (can differ because of max min zoom factor)
 */
var getScaleFactor = exports.getScaleFactor = function getScaleFactor(scale, factor, opts) {
  var originalFactor = factor;
  var zoomFactor = factor * scale;
  var maxScaleTimes = opts.maxScaleTimes,
      minScaleTimes = opts.minScaleTimes;

  zoomFactor = Math.min(maxScaleTimes, Math.max(zoomFactor, minScaleTimes));
  return zoomFactor / originalFactor;
};

/**
 * Scales the zoom factor relative to current state
 *
 * @param scale
 * @return the actual scale (can differ because of max min zoom factor)
 */
var getZoomFactor = exports.getZoomFactor = function getZoomFactor(scale, factor, opts) {
  var maxScaleTimes = opts.maxScaleTimes,
      minScaleTimes = opts.minScaleTimes;

  return Math.min(maxScaleTimes, Math.max(factor * scale, minScaleTimes));
};

var getTouchCenter = exports.getTouchCenter = function getTouchCenter(touches) {
  return getVectorAvg(touches);
};

var calcNewScale = exports.calcNewScale = function calcNewScale(to) {
  var lastScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return to / lastScale;
};

/***/ }),
/* 1 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (target) {
  return function (e) {
    var newSpan = document.createElement('span');
    var time = new Date();
    time = time.getHours() + ':' + time.getMinutes() + ':' + time.getSeconds() + ',' + time.getMilliseconds();
    var newContent = document.createTextNode('[' + time + '] Event dispatched: "' + e.type + '"');
    newSpan.appendChild(newContent);
    target.appendChild(newSpan);
  };
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pinchIt = __webpack_require__(7);

var _pinchIt2 = _interopRequireDefault(_pinchIt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _pinchIt2.default;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/* **********************************************
     Begin prism-core.js
********************************************** */

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function(){

// Private helper vars
var lang = /\blang(?:uage)?-(\w+)\b/i;
var uniqueId = 0;

var _ = _self.Prism = {
	util: {
		encode: function (tokens) {
			if (tokens instanceof Token) {
				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
			} else if (_.util.type(tokens) === 'Array') {
				return tokens.map(_.util.encode);
			} else {
				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
			}
		},

		type: function (o) {
			return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
		},

		objId: function (obj) {
			if (!obj['__id']) {
				Object.defineProperty(obj, '__id', { value: ++uniqueId });
			}
			return obj['__id'];
		},

		// Deep clone a language definition (e.g. to extend it)
		clone: function (o) {
			var type = _.util.type(o);

			switch (type) {
				case 'Object':
					var clone = {};

					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = _.util.clone(o[key]);
						}
					}

					return clone;

				case 'Array':
					// Check for existence for IE8
					return o.map && o.map(function(v) { return _.util.clone(v); });
			}

			return o;
		}
	},

	languages: {
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);

			for (var key in redef) {
				lang[key] = redef[key];
			}

			return lang;
		},

		/**
		 * Insert a token before another token in a language literal
		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
		 * we cannot just provide an object, we need anobject and a key.
		 * @param inside The key (or language id) of the parent
		 * @param before The key to insert before. If not provided, the function appends instead.
		 * @param insert Object with the key/value pairs to insert
		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
		 */
		insertBefore: function (inside, before, insert, root) {
			root = root || _.languages;
			var grammar = root[inside];

			if (arguments.length == 2) {
				insert = arguments[1];

				for (var newToken in insert) {
					if (insert.hasOwnProperty(newToken)) {
						grammar[newToken] = insert[newToken];
					}
				}

				return grammar;
			}

			var ret = {};

			for (var token in grammar) {

				if (grammar.hasOwnProperty(token)) {

					if (token == before) {

						for (var newToken in insert) {

							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}

					ret[token] = grammar[token];
				}
			}

			// Update references in other language definitions
			_.languages.DFS(_.languages, function(key, value) {
				if (value === root[inside] && key != inside) {
					this[key] = ret;
				}
			});

			return root[inside] = ret;
		},

		// Traverse a language definition with Depth First Search
		DFS: function(o, callback, type, visited) {
			visited = visited || {};
			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					callback.call(o, i, o[i], type || i);

					if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, null, visited);
					}
					else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, i, visited);
					}
				}
			}
		}
	},
	plugins: {},

	highlightAll: function(async, callback) {
		var env = {
			callback: callback,
			selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
		};

		_.hooks.run("before-highlightall", env);

		var elements = env.elements || document.querySelectorAll(env.selector);

		for (var i=0, element; element = elements[i++];) {
			_.highlightElement(element, async === true, env.callback);
		}
	},

	highlightElement: function(element, async, callback) {
		// Find language
		var language, grammar, parent = element;

		while (parent && !lang.test(parent.className)) {
			parent = parent.parentNode;
		}

		if (parent) {
			language = (parent.className.match(lang) || [,''])[1].toLowerCase();
			grammar = _.languages[language];
		}

		// Set language on the element, if not present
		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

		// Set language on the parent, for styling
		parent = element.parentNode;

		if (/pre/i.test(parent.nodeName)) {
			parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
		}

		var code = element.textContent;

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};

		_.hooks.run('before-sanity-check', env);

		if (!env.code || !env.grammar) {
			if (env.code) {
				env.element.textContent = env.code;
			}
			_.hooks.run('complete', env);
			return;
		}

		_.hooks.run('before-highlight', env);

		if (async && _self.Worker) {
			var worker = new Worker(_.filename);

			worker.onmessage = function(evt) {
				env.highlightedCode = evt.data;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				callback && callback.call(env.element);
				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			};

			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code,
				immediateClose: true
			}));
		}
		else {
			env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

			_.hooks.run('before-insert', env);

			env.element.innerHTML = env.highlightedCode;

			callback && callback.call(element);

			_.hooks.run('after-highlight', env);
			_.hooks.run('complete', env);
		}
	},

	highlight: function (text, grammar, language) {
		var tokens = _.tokenize(text, grammar);
		return Token.stringify(_.util.encode(tokens), language);
	},

	tokenize: function(text, grammar, language) {
		var Token = _.Token;

		var strarr = [text];

		var rest = grammar.rest;

		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}

			delete grammar.rest;
		}

		tokenloop: for (var token in grammar) {
			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				var pattern = patterns[j],
					inside = pattern.inside,
					lookbehind = !!pattern.lookbehind,
					greedy = !!pattern.greedy,
					lookbehindLength = 0,
					alias = pattern.alias;

				if (greedy && !pattern.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
					pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
				}

				pattern = pattern.pattern || pattern;

				// Don’t cache length as it changes during the loop
				for (var i=0, pos = 0; i<strarr.length; pos += strarr[i].length, ++i) {

					var str = strarr[i];

					if (strarr.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						break tokenloop;
					}

					if (str instanceof Token) {
						continue;
					}

					pattern.lastIndex = 0;

					var match = pattern.exec(str),
					    delNum = 1;

					// Greedy patterns can override/remove up to two previously matched tokens
					if (!match && greedy && i != strarr.length - 1) {
						pattern.lastIndex = pos;
						match = pattern.exec(text);
						if (!match) {
							break;
						}

						var from = match.index + (lookbehind ? match[1].length : 0),
						    to = match.index + match[0].length,
						    k = i,
						    p = pos;

						for (var len = strarr.length; k < len && p < to; ++k) {
							p += strarr[k].length;
							// Move the index i to the element in strarr that is closest to from
							if (from >= p) {
								++i;
								pos = p;
							}
						}

						/*
						 * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
						 * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
						 */
						if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
							continue;
						}

						// Number of tokens to delete and replace with the new match
						delNum = k - i;
						str = text.slice(pos, p);
						match.index -= pos;
					}

					if (!match) {
						continue;
					}

					if(lookbehind) {
						lookbehindLength = match[1].length;
					}

					var from = match.index + lookbehindLength,
					    match = match[0].slice(lookbehindLength),
					    to = from + match.length,
					    before = str.slice(0, from),
					    after = str.slice(to);

					var args = [i, delNum];

					if (before) {
						args.push(before);
					}

					var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

					args.push(wrapped);

					if (after) {
						args.push(after);
					}

					Array.prototype.splice.apply(strarr, args);
				}
			}
		}

		return strarr;
	},

	hooks: {
		all: {},

		add: function (name, callback) {
			var hooks = _.hooks.all;

			hooks[name] = hooks[name] || [];

			hooks[name].push(callback);
		},

		run: function (name, env) {
			var callbacks = _.hooks.all[name];

			if (!callbacks || !callbacks.length) {
				return;
			}

			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	}
};

var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
	this.type = type;
	this.content = content;
	this.alias = alias;
	// Copy of the full string this token was created from
	this.length = (matchedStr || "").length|0;
	this.greedy = !!greedy;
};

Token.stringify = function(o, language, parent) {
	if (typeof o == 'string') {
		return o;
	}

	if (_.util.type(o) === 'Array') {
		return o.map(function(element) {
			return Token.stringify(element, language, o);
		}).join('');
	}

	var env = {
		type: o.type,
		content: Token.stringify(o.content, language, parent),
		tag: 'span',
		classes: ['token', o.type],
		attributes: {},
		language: language,
		parent: parent
	};

	if (env.type == 'comment') {
		env.attributes['spellcheck'] = 'true';
	}

	if (o.alias) {
		var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
		Array.prototype.push.apply(env.classes, aliases);
	}

	_.hooks.run('wrap', env);

	var attributes = Object.keys(env.attributes).map(function(name) {
		return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
	}).join(' ');

	return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';

};

if (!_self.document) {
	if (!_self.addEventListener) {
		// in Node.js
		return _self.Prism;
	}
 	// In worker
	_self.addEventListener('message', function(evt) {
		var message = JSON.parse(evt.data),
		    lang = message.language,
		    code = message.code,
		    immediateClose = message.immediateClose;

		_self.postMessage(_.highlight(code, _.languages[lang], lang));
		if (immediateClose) {
			_self.close();
		}
	}, false);

	return _self.Prism;
}

//Get current script and highlight
var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

if (script) {
	_.filename = script.src;

	if (document.addEventListener && !script.hasAttribute('data-manual')) {
		if(document.readyState !== "loading") {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(_.highlightAll);
			} else {
				window.setTimeout(_.highlightAll, 16);
			}
		}
		else {
			document.addEventListener('DOMContentLoaded', _.highlightAll);
		}
	}
}

return _self.Prism;

})();

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== 'undefined') {
	global.Prism = Prism;
}


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': /<!--[\w\W]*?-->/,
	'prolog': /<\?[\w\W]+?\?>/,
	'doctype': /<!DOCTYPE[\w\W]+?>/i,
	'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/i,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'attr-value': {
				pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
				inside: {
					'punctuation': /[=>"']/
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': /&#?[\da-z]{1,8};/i
};

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function(env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;


/* **********************************************
     Begin prism-css.js
********************************************** */

Prism.languages.css = {
	'comment': /\/\*[\w\W]*?\*\//,
	'atrule': {
		pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
		inside: {
			'rule': /@[\w-]+/
			// See rest below
		}
	},
	'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
	'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
	'string': {
		pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'property': /(\b|\B)[\w-]+(?=\s*:)/i,
	'important': /\B!important\b/i,
	'function': /[-a-z0-9]+(?=\()/i,
	'punctuation': /[(){};:]/
};

Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'style': {
			pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
			lookbehind: true,
			inside: Prism.languages.css,
			alias: 'language-css'
		}
	});
	
	Prism.languages.insertBefore('inside', 'attr-value', {
		'style-attr': {
			pattern: /\s*style=("|').*?\1/i,
			inside: {
				'attr-name': {
					pattern: /^\s*style/i,
					inside: Prism.languages.markup.tag.inside
				},
				'punctuation': /^\s*=\s*['"]|['"]\s*$/,
				'attr-value': {
					pattern: /.+/i,
					inside: Prism.languages.css
				}
			},
			alias: 'language-css'
		}
	}, Prism.languages.markup.tag);
}

/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
			lookbehind: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true
		}
	],
	'string': {
		pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
		lookbehind: true,
		inside: {
			punctuation: /(\.|\\)/
		}
	},
	'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(true|false)\b/,
	'function': /[a-z0-9_]+(?=\()/i,
	'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
	'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
});

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
		lookbehind: true,
		greedy: true
	}
});

Prism.languages.insertBefore('javascript', 'string', {
	'template-string': {
		pattern: /`(?:\\\\|\\?[^\\])*?`/,
		greedy: true,
		inside: {
			'interpolation': {
				pattern: /\$\{[^}]+\}/,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'script': {
			pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript,
			alias: 'language-javascript'
		}
	});
}

Prism.languages.js = Prism.languages.javascript;

/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
	if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
		return;
	}

	self.Prism.fileHighlight = function() {

		var Extensions = {
			'js': 'javascript',
			'py': 'python',
			'rb': 'ruby',
			'ps1': 'powershell',
			'psm1': 'powershell',
			'sh': 'bash',
			'bat': 'batch',
			'h': 'c',
			'tex': 'latex'
		};

		if(Array.prototype.forEach) { // Check to prevent error in IE8
			Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
				var src = pre.getAttribute('data-src');

				var language, parent = pre;
				var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
				while (parent && !lang.test(parent.className)) {
					parent = parent.parentNode;
				}

				if (parent) {
					language = (pre.className.match(lang) || [, ''])[1];
				}

				if (!language) {
					var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
					language = Extensions[extension] || extension;
				}

				var code = document.createElement('code');
				code.className = 'language-' + language;

				pre.textContent = '';

				code.textContent = 'Loading…';

				pre.appendChild(code);

				var xhr = new XMLHttpRequest();

				xhr.open('GET', src, true);

				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {

						if (xhr.status < 400 && xhr.responseText) {
							code.textContent = xhr.responseText;

							Prism.highlightElement(code);
						}
						else if (xhr.status >= 400) {
							code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
						}
						else {
							code.textContent = '✖ Error: File does not exist or is empty';
						}
					}
				};

				xhr.send(null);
			});
		}

	};

	document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(13);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(15)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!./../../css-loader/index.js!./prism.css", function() {
			var newContent = require("!!./../../css-loader/index.js!./prism.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {

  /**
   * default scale that will be set on element
   * @maxPinch {Number}
   */
  baseScale: 1,

  /**
   * max scale a node can reach
   * @maxPinch {Number}
   */
  maxScale: 3,

  /**
   * max scale a node can reach before bouncing back to maxScale
   * @maxScaleTimes {Number}
   */
  maxScaleTimes: 4,

  /**
   * min scale a node can reach
   * @minPinch {Number}
   */
  minScale: 1,

  /**
   * min scale a node can reach before bouncing back to minScale
   * @minScaleTimes {Number}
   */
  minScaleTimes: 0.8,

  /**
   * time for the snapBack of the pinch if the node has reach above
   * or below its pinch value
   * @snapBackSpeed {Number}
   */
  snapBackSpeed: 200,

  /**
   * Basic easing functions: https://developer.mozilla.org/de/docs/Web/CSS/transition-timing-function
   * cubic bezier easing functions: http://easings.net/de
   * @ease {String}
   */
  ease: 'ease'
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
//


var _dispatchEvent = __webpack_require__(9);

var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

var _handleEvent = __webpack_require__(12);

var _handleElement = __webpack_require__(11);

var _handleElement2 = _interopRequireDefault(_handleElement);

var _handlePinch = __webpack_require__(0);

var _handleDrag = __webpack_require__(10);

var _defaults = __webpack_require__(6);

var _defaults2 = _interopRequireDefault(_defaults);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var first = function first(items) {
  return items[0];
};

var setTarget = function setTarget(el, opts) {
  return el.querySelector(opts.target ? 'img' + opts.target : 'img');
};

var pinchIt = function pinchIt(targets) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // private variable cache
  var element = null;

  var scaling = void 0;
  var lastScale = 1;
  var startTouches = void 0;

  var zoomFactor = 1;

  var offset = { x: 0, y: 0 };
  var lastZoomCenter = false;
  var lastDragPosition = false;

  // Base configuration for the pinch instance
  var opts = _extends({}, _defaults2.default, options);

  var _eventDispatcher = (0, _dispatchEvent2.default)(),
      on = _eventDispatcher.on,
      dispatch = _eventDispatcher.dispatch;

  /**
   *  dispatchPinchEvent - Shorthand method for creating events
   *
   *  @param { String } phase
   *  @param { String } type
   *  @param { Object } details
   *  @return { Void }
   **/


  var dispatchPinchEvent = function dispatchPinchEvent(eventName, phase) {
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    dispatch(eventName, Object.assign(data, {
      phase: phase
    }));
  };

  var resetGlobals = function resetGlobals() {
    scaling = undefined;
    lastScale = 1;
    startTouches = null;
    zoomFactor = 1;
    lastZoomCenter = false;

    lastDragPosition = false;
    offset = { x: 0, y: 0 };
  };

  // event handling
  /**
   * Set scaling if we are using more then one finger
   * and captures our first punch point
   *
   * private
   * @param { Object } e the event from our eventlistener
   */
  var onTouchstart = function onTouchstart(e) {
    dispatchPinchEvent('touchstart', 'before', e);

    scaling = e.touches.length === 2;
    startTouches = Array.from(e.touches);
    lastScale = 1;

    if ((0, _handleEvent.detectDoubleTap)(e)) {
      var image = e.currentTarget.querySelector('img');
      (0, _handleElement2.default)(e.target, image, 1, { x: 0, y: 0 }, opts.snapBackSpeed, opts.ease);
      resetGlobals();
    }

    dispatchPinchEvent('touchstart', 'after', e);
  };

  var onTouchmove = function onTouchmove(e) {
    dispatchPinchEvent('touchmove', 'before', e);

    if ((!scaling || !startTouches) && zoomFactor > 1) {
      (0, _handleEvent.cancelEvent)(e);

      var touch = first((0, _handleEvent.getTouches)(e.currentTarget, Array.from(e.touches)));
      var dragOffset = (0, _handleDrag.drag)(touch, lastDragPosition, offset, zoomFactor);

      offset = (0, _handleDrag.sanitizeOffset)(e.target, dragOffset, zoomFactor);
      lastDragPosition = touch;
    } else if (scaling && startTouches) {
      (0, _handleEvent.cancelEvent)(e);

      // a relative scale factor is used
      var touchCenter = (0, _handlePinch.getTouchCenter)((0, _handleEvent.getTouches)(e.currentTarget, Array.from(e.touches)));
      var newScale = (0, _handleEvent.calcScale)(e.currentTarget, startTouches, Array.from(e.touches));
      var scaleValue = (0, _handlePinch.calcNewScale)(newScale, lastScale);

      var scale = (0, _handlePinch.getScaleFactor)(scaleValue, zoomFactor, opts);
      zoomFactor = (0, _handlePinch.getZoomFactor)(scaleValue, zoomFactor, opts);

      offset = (0, _handlePinch.addOffset)(offset, {
        x: (scale - 1) * (touchCenter.x + offset.x),
        y: (scale - 1) * (touchCenter.y + offset.y)
      });

      lastScale = newScale;
      offset = (0, _handleDrag.drag)(touchCenter, lastZoomCenter, offset, zoomFactor);
      lastZoomCenter = touchCenter;
    }

    var image = e.currentTarget.querySelector('img');
    (0, _handleElement2.default)(e.target, image, zoomFactor, offset, 0, opts.ease);

    dispatchPinchEvent('touchmove', 'after', e);
  };

  var onTouchend = function onTouchend(e) {
    dispatchPinchEvent('touchend', 'before', e);

    lastDragPosition = false;
    lastZoomCenter = false;
    lastScale = 1;
    if (zoomFactor) {
      if (!(0, _handlePinch.isWithin)(zoomFactor, opts)) {
        var image = e.currentTarget.querySelector('img');
        var isLessThan = (0, _handlePinch.getInitialScale)(e.target, image) * zoomFactor < opts.minScale;
        zoomFactor = isLessThan ? opts.minScale : opts.maxScale;
        offset = (0, _handleDrag.sanitizeOffset)(e.target, offset, zoomFactor);
        (0, _handleElement2.default)(e.target, image, zoomFactor, offset, opts.snapBackSpeed, opts.ease);
      }
    }

    dispatchPinchEvent('touchend', 'after', e);
  };

  var attachEvents = function attachEvents(el) {
    el.addEventListener('touchstart', onTouchstart);
    el.addEventListener('touchmove', onTouchmove);
    el.addEventListener('touchend', onTouchend);
  };

  var detachhEvents = function detachhEvents(el) {
    el.removeEventListener('touchstart', onTouchstart);
    el.removeEventListener('touchmove', onTouchmove);
    el.removeEventListener('touchend', onTouchend);
  };

  /**
   * public
   * reset function:
   * @param { Number } duration
   * @param { String } easing
   * @return { Void }
   */
  var reset = function reset() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (!element) return;
    var image = setTarget(element, opts);
    if (!image) return;

    var _Object$assign = Object.assign({}, opts, opt),
        snapBackSpeed = _Object$assign.snapBackSpeed,
        easing = _Object$assign.easing;

    (0, _handleElement2.default)(element, image, 1, { x: 0, y: 0 }, snapBackSpeed, easing);
    resetGlobals();
  };

  /**
   * public
   * destroy function: called to gracefully destroy the lory instance
   * @return { Void }
   */
  var destroy = function destroy() {
    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    dispatchPinchEvent('destroy', 'before', {});
    if (!element) return;
    reset(opt);
    // remove event listeners
    detachhEvents(element);
    element = null;
    resetGlobals();
    dispatchPinchEvent('destroy', 'after', {});
  };

  /**
   * setup - Init function
   *
   * @param { String, Object }
   * @return { Void }
   **/
  var setup = function setup(target) {
    if (element) destroy();
    dispatchPinchEvent('init', 'before', {});
    // resolve target
    // pinchit allows for both a node or a string to be passed
    switch (typeof target === 'undefined' ? 'undefined' : _typeof(target)) {
      case 'object':
        element = target;
        break;
      case 'string':
        element = document.querySelector(target);
        break;
      default:
        element = null;
        console.warn('missing target, either pass an node or a string');
    }

    if (element) {
      attachEvents(element);
    }

    dispatchPinchEvent('init', 'after', {});
  };

  // trigger initial setup
  setup(targets);

  return {
    setup: setup,
    reset: reset,
    destroy: destroy,
    element: element,
    on: on
  };
};

exports.default = pinchIt;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Detecting prefixes for saving time and bytes
 */
exports.default = function () {
  var transform = void 0;
  var transition = void 0;
  var transitionEnd = void 0;
  var hasScale3d = void 0;

  (function () {
    var el = document.createElement('_');
    var style = el.style;

    if (style.webkitTransition === '') {
      transitionEnd = 'webkitTransitionEnd';
      transition = 'webkitTransition';
    }

    if (style.transition === '') {
      transitionEnd = 'transitionend';
      transition = 'transition';
    }

    if (style.webkitTransform === '') {
      transform = 'webkitTransform';
    }

    if (style.msTransform === '') {
      transform = 'msTransform';
    }

    if (style.transform === '') {
      transform = 'transform';
    }

    document.body.insertBefore(el, null);
    style[transform] = 'translate3d(0, 0, 0)';
    hasScale3d = !!global.getComputedStyle(el).getPropertyValue(transform);
    document.body.removeChild(el);
  })();

  return {
    transform: transform,
    transition: transition,
    transitionEnd: transitionEnd,
    hasScale3d: hasScale3d
  };
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});


/**
 * dispatch custom events
 */

var eventDispatcher = function eventDispatcher() {
  var events = {};

  /**
   * Register a handler for event, to be fired
   * for every event.
   */
  var on = function on(eventName, handler) {
    events[eventName] = events[eventName] || [];
    events[eventName].push(handler);
    return undefined;
  };

  /**
   * Deregister a handler for event.
   */
  var off = function off(eventName, handler) {
    if (events[eventName]) {
      for (var i = 0; i < events[eventName].length; i += 1) {
        if (events[eventName][i] === handler) {
          events[eventName].splice(i, 1);
          break;
        }
      }
    }
  };

  var dispatch = function dispatch(eventName, data) {
    if (events[eventName]) {
      events[eventName].forEach(function (fn) {
        fn(data);
      });
    }
  };

  return {
    on: on,
    off: off,
    dispatch: dispatch
  };
};

exports.default = eventDispatcher;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drag = exports.sanitizeOffset = undefined;

var _handlePinch = __webpack_require__(0);

var calcMax = function calcMax(el, differ, zoomFactor) {
  return {
    maxX: (zoomFactor - differ) * (0, _handlePinch.getX)(el),
    maxY: (zoomFactor - differ) * (0, _handlePinch.getY)(el)
  };
};

var sanitizeOffset = exports.sanitizeOffset = function sanitizeOffset(el, offset, zoomFactor) {
  var _calcMax = calcMax(el, 1, zoomFactor),
      maxX = _calcMax.maxX,
      maxY = _calcMax.maxY;

  var maxOffsetX = Math.max(maxX, 0);
  var maxOffsetY = Math.max(maxY, 0);
  var minOffsetX = Math.min(maxX, 0);
  var minOffsetY = Math.min(maxY, 0);

  return {
    x: Math.min(Math.max(offset.x, minOffsetX), maxOffsetX),
    y: Math.min(Math.max(offset.y, minOffsetY), maxOffsetY)
  };
};

var drag = exports.drag = function drag(center, lastCenter, lastOffset, zoomFactor) {
  return Object.prototype.hasOwnProperty.call(lastCenter, 'x') ? (0, _handlePinch.addOffset)(lastOffset, {
    x: -((center.x - lastCenter.x) * zoomFactor / zoomFactor),
    y: -((center.y - lastCenter.y) * zoomFactor / zoomFactor)
  }) : lastOffset;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _detectPrefixes = __webpack_require__(8);

var _detectPrefixes2 = _interopRequireDefault(_detectPrefixes);

var _handlePinch = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var prefixes = (0, _detectPrefixes2.default)();

var handleAnimation = function handleAnimation(el, transition, duration, ease) {
  var style = el.style;

  style.transformOrigin = '0% 0%';
  style[transition + 'TimingFunction'] = ease;
  style[transition + 'Duration'] = duration + 'ms';
};

/**
 * scaleElement -transdorms to a given position in a given time in milliseconds
 *
 * @param { Object } el element from the events
 * @param { Number } pinch number where to scale to
 * @param { Object } coords object where to translate to
 * @param { Number } duration time in milliseconds for the transistion
 * @param { String } ease easing css property
 * @return { Void }
 */

exports.default = function (el, image, pinch, coords, duration, ease) {
  var transition = prefixes.transition,
      transform = prefixes.transform,
      hasScale3d = prefixes.hasScale3d;
  var style = image.style;


  var zoomFactor = (0, _handlePinch.getInitialScale)(el, image) * pinch;

  var offsetX = -coords.x;
  var offsetY = -coords.y;

  handleAnimation(image, transition, duration, ease);
  var scaleProp = hasScale3d ? 'scale3d(' + zoomFactor + ', ' + zoomFactor + ', 1)' : 'scale(' + zoomFactor + ', ' + zoomFactor + ')';
  var translateProp = 'translate(' + offsetX + 'px, ' + offsetY + 'px)';

  style[transform] = translateProp + ' ' + scaleProp;
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var lastTouchStart = 0;

/**
 * cancelEvent - Cancel Events so we dont bubble up our events to the document
 *
 * @param { Object } event
 * @return { Void }
 **/
var cancelEvent = exports.cancelEvent = function cancelEvent(e) {
  e.stopPropagation();
  e.preventDefault();
};

/**
 * detectDoubleTap - Check if we are double tapping
 *
 * @param { Object } event
 * @return { Boolean }
 **/
var detectDoubleTap = exports.detectDoubleTap = function detectDoubleTap(e) {
  var time = new Date().getTime();

  if (e.touches.length > 1) {
    lastTouchStart = 0;
  }

  if (time - lastTouchStart < 300) {
    cancelEvent(e);
    return true;
  }

  if (e.touches.length === 1) {
    lastTouchStart = time;
  }
  return false;
};

/**
 * Returns the touches of an event relative to the container offset
 *
 * @param event
 * @return array touches
 */
var getTouches = exports.getTouches = function getTouches(el, touches) {
  var position = el.getBoundingClientRect();
  return touches.map(function (touch) {
    return {
      x: touch.pageX - (position.left + document.body.scrollLeft),
      y: touch.pageY - (position.top + document.body.scrollTop)
    };
  });
};

/**
 * getDistance - Calculate the distance between our fingers
 *
 * @param { Array } touches touches passas an array from TouchList
 * @return { Number } the calcualted distance between the fingers
 **/
var getDistance = exports.getDistance = function getDistance(touches) {
  var _touches = _slicedToArray(touches, 2),
      first = _touches[0],
      second = _touches[1];

  return Math.sqrt((first.x - second.x) * (first.x - second.x) + (first.y - second.y) * (first.y - second.y));
};

/**
 * calcScale - Calculate the distance between where we start our pinch
 * to where we end it
 *
 * @param { Array } startTouch The starting point of our touch
 * @param { Array } endTouch The current point of our touch
 * @return { Number }
 */
var calcScale = exports.calcScale = function calcScale(el, startTouch, endTouch) {
  return getDistance(getTouches(el, endTouch)) / getDistance(getTouches(el, startTouch));
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(14)();
// imports


// module
exports.push([module.i, "/**\n * prism.js default theme for JavaScript, CSS and HTML\n * Based on dabblet (http://dabblet.com)\n * @author Lea Verou\n */\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n\tcolor: black;\n\tbackground: none;\n\ttext-shadow: 0 1px white;\n\tfont-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;\n\ttext-align: left;\n\twhite-space: pre;\n\tword-spacing: normal;\n\tword-break: normal;\n\tword-wrap: normal;\n\tline-height: 1.5;\n\n\t-moz-tab-size: 4;\n\t-o-tab-size: 4;\n\ttab-size: 4;\n\n\t-webkit-hyphens: none;\n\t-moz-hyphens: none;\n\t-ms-hyphens: none;\n\thyphens: none;\n}\n\npre[class*=\"language-\"]::-moz-selection, pre[class*=\"language-\"] ::-moz-selection,\ncode[class*=\"language-\"]::-moz-selection, code[class*=\"language-\"] ::-moz-selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\npre[class*=\"language-\"]::selection, pre[class*=\"language-\"] ::selection,\ncode[class*=\"language-\"]::selection, code[class*=\"language-\"] ::selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\n@media print {\n\tcode[class*=\"language-\"],\n\tpre[class*=\"language-\"] {\n\t\ttext-shadow: none;\n\t}\n}\n\n/* Code blocks */\npre[class*=\"language-\"] {\n\tpadding: 1em;\n\tmargin: .5em 0;\n\toverflow: auto;\n}\n\n:not(pre) > code[class*=\"language-\"],\npre[class*=\"language-\"] {\n\tbackground: #f5f2f0;\n}\n\n/* Inline code */\n:not(pre) > code[class*=\"language-\"] {\n\tpadding: .1em;\n\tborder-radius: .3em;\n\twhite-space: normal;\n}\n\n.token.comment,\n.token.prolog,\n.token.doctype,\n.token.cdata {\n\tcolor: slategray;\n}\n\n.token.punctuation {\n\tcolor: #999;\n}\n\n.namespace {\n\topacity: .7;\n}\n\n.token.property,\n.token.tag,\n.token.boolean,\n.token.number,\n.token.constant,\n.token.symbol,\n.token.deleted {\n\tcolor: #905;\n}\n\n.token.selector,\n.token.attr-name,\n.token.string,\n.token.char,\n.token.builtin,\n.token.inserted {\n\tcolor: #690;\n}\n\n.token.operator,\n.token.entity,\n.token.url,\n.language-css .token.string,\n.style .token.string {\n\tcolor: #a67f59;\n\tbackground: hsla(0, 0%, 100%, .5);\n}\n\n.token.atrule,\n.token.attr-value,\n.token.keyword {\n\tcolor: #07a;\n}\n\n.token.function {\n\tcolor: #DD4A68;\n}\n\n.token.regex,\n.token.important,\n.token.variable {\n\tcolor: #e90;\n}\n\n.token.important,\n.token.bold {\n\tfont-weight: bold;\n}\n.token.italic {\n\tfont-style: italic;\n}\n\n.token.entity {\n\tcursor: help;\n}\n", ""]);

// exports


/***/ }),
/* 14 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function() {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		var result = [];
		for(var i = 0; i < this.length; i++) {
			var item = this[i];
			if(item[2]) {
				result.push("@media " + item[2] + "{" + item[1] + "}");
			} else {
				result.push(item[1]);
			}
		}
		return result.join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
	}),
	getHeadElement = memoize(function () {
		return document.head || document.getElementsByTagName("head")[0];
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [];

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the bottom of <head>.
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
}

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var head = getHeadElement();
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			head.insertBefore(styleElement, head.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			head.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		head.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	styleElement.type = "text/css";
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	linkElement.rel = "stylesheet";
	insertStyleElement(options, linkElement);
	return linkElement;
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _prismjs = __webpack_require__(4);

var _prismjs2 = _interopRequireDefault(_prismjs);

__webpack_require__(5);

var _handleEvent = __webpack_require__(2);

var _handleEvent2 = _interopRequireDefault(_handleEvent);

var _src = __webpack_require__(3);

var _src2 = _interopRequireDefault(_src);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _src2.default)('.example-one .img-wrapper');
(0, _src2.default)('.example-tree .img-wrapper', {
  maxScale: 4,
  minScale: 0.5,
  snapBackSpeed: 500
});

var pinchImage = (0, _src2.default)('.example-four .img-wrapper', {
  snapBackSpeed: 1000
});

document.querySelector('.reset-button').addEventListener('click', function () {
  pinchImage.reset();
});

var target = document.querySelector('.event-target');
var handleEventExample = (0, _handleEvent2.default)(target);
var pinchEvent = (0, _src2.default)('.example-five .img-wrapper', {
  target: 'img',
  snapBackSpeed: 1000
});

pinchEvent.on('touchstart', handleEventExample);
pinchEvent.on('touchmove', handleEventExample);

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzc3ZTdlZTZiNDZlOWU2OTc3ODgiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2hhbmRsZS1waW5jaC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL2RvY3MvaGFuZGxlLWV2ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaXNtanMvcHJpc20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmlzbWpzL3RoZW1lcy9wcmlzbS5jc3M/NjgwZCIsIndlYnBhY2s6Ly8vLi9zcmMvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BpbmNoLWl0LmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9kZXRlY3QtcHJlZml4ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2Rpc3BhdGNoLWV2ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9oYW5kbGUtZHJhZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvaGFuZGxlLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2hhbmRsZS1ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaXNtanMvdGhlbWVzL3ByaXNtLmNzcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9kb2NzL2FwcC5qcyJdLCJuYW1lcyI6WyJzdW0iLCJhY2MiLCJuZXh0IiwiZ2V0VmVjdG9yQXZnIiwidmVjdG9ycyIsIngiLCJtYXAiLCJ2IiwicmVkdWNlIiwibGVuZ3RoIiwieSIsImdldEVsZW1lbnQiLCJ0eXBlIiwiZWwiLCJIVE1MSW1hZ2VFbGVtZW50IiwiaXNXaXRoaW4iLCJzY2FsZSIsIm9wdHMiLCJtYXhTY2FsZSIsIm1pblNjYWxlIiwiYWRkT2Zmc2V0IiwibGFzdE9mZnNldCIsIm9mZnNldCIsImdldFgiLCJnZXRZIiwiZ2V0SW5pdGlhbFNjYWxlIiwiaW1hZ2UiLCJvZmZzZXRXaWR0aCIsImdldFNjYWxlRmFjdG9yIiwiZmFjdG9yIiwib3JpZ2luYWxGYWN0b3IiLCJ6b29tRmFjdG9yIiwibWF4U2NhbGVUaW1lcyIsIm1pblNjYWxlVGltZXMiLCJNYXRoIiwibWluIiwibWF4IiwiZ2V0Wm9vbUZhY3RvciIsImdldFRvdWNoQ2VudGVyIiwidG91Y2hlcyIsImNhbGNOZXdTY2FsZSIsInRvIiwibGFzdFNjYWxlIiwiZSIsIm5ld1NwYW4iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ0aW1lIiwiRGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJuZXdDb250ZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJhcHBlbmRDaGlsZCIsInRhcmdldCIsImJhc2VTY2FsZSIsInNuYXBCYWNrU3BlZWQiLCJlYXNlIiwiZmlyc3QiLCJpdGVtcyIsInNldFRhcmdldCIsInF1ZXJ5U2VsZWN0b3IiLCJwaW5jaEl0IiwidGFyZ2V0cyIsIm9wdGlvbnMiLCJlbGVtZW50Iiwic2NhbGluZyIsInN0YXJ0VG91Y2hlcyIsImxhc3Rab29tQ2VudGVyIiwibGFzdERyYWdQb3NpdGlvbiIsIm9uIiwiZGlzcGF0Y2giLCJkaXNwYXRjaFBpbmNoRXZlbnQiLCJldmVudE5hbWUiLCJwaGFzZSIsImRhdGEiLCJPYmplY3QiLCJhc3NpZ24iLCJyZXNldEdsb2JhbHMiLCJ1bmRlZmluZWQiLCJvblRvdWNoc3RhcnQiLCJBcnJheSIsImZyb20iLCJjdXJyZW50VGFyZ2V0Iiwib25Ub3VjaG1vdmUiLCJ0b3VjaCIsImRyYWdPZmZzZXQiLCJ0b3VjaENlbnRlciIsIm5ld1NjYWxlIiwic2NhbGVWYWx1ZSIsIm9uVG91Y2hlbmQiLCJpc0xlc3NUaGFuIiwiYXR0YWNoRXZlbnRzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImRldGFjaGhFdmVudHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVzZXQiLCJvcHQiLCJlYXNpbmciLCJkZXN0cm95Iiwic2V0dXAiLCJjb25zb2xlIiwid2FybiIsInRyYW5zZm9ybSIsInRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uRW5kIiwiaGFzU2NhbGUzZCIsInN0eWxlIiwid2Via2l0VHJhbnNpdGlvbiIsIndlYmtpdFRyYW5zZm9ybSIsIm1zVHJhbnNmb3JtIiwiYm9keSIsImluc2VydEJlZm9yZSIsImdsb2JhbCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicmVtb3ZlQ2hpbGQiLCJldmVudERpc3BhdGNoZXIiLCJldmVudHMiLCJoYW5kbGVyIiwicHVzaCIsIm9mZiIsImkiLCJzcGxpY2UiLCJmb3JFYWNoIiwiZm4iLCJjYWxjTWF4IiwiZGlmZmVyIiwibWF4WCIsIm1heFkiLCJzYW5pdGl6ZU9mZnNldCIsIm1heE9mZnNldFgiLCJtYXhPZmZzZXRZIiwibWluT2Zmc2V0WCIsIm1pbk9mZnNldFkiLCJkcmFnIiwiY2VudGVyIiwibGFzdENlbnRlciIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInByZWZpeGVzIiwiaGFuZGxlQW5pbWF0aW9uIiwiZHVyYXRpb24iLCJ0cmFuc2Zvcm1PcmlnaW4iLCJwaW5jaCIsImNvb3JkcyIsIm9mZnNldFgiLCJvZmZzZXRZIiwic2NhbGVQcm9wIiwidHJhbnNsYXRlUHJvcCIsImxhc3RUb3VjaFN0YXJ0IiwiY2FuY2VsRXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsImRldGVjdERvdWJsZVRhcCIsImdldFRpbWUiLCJnZXRUb3VjaGVzIiwicG9zaXRpb24iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYWdlWCIsImxlZnQiLCJzY3JvbGxMZWZ0IiwicGFnZVkiLCJ0b3AiLCJzY3JvbGxUb3AiLCJnZXREaXN0YW5jZSIsInNlY29uZCIsInNxcnQiLCJjYWxjU2NhbGUiLCJzdGFydFRvdWNoIiwiZW5kVG91Y2giLCJwaW5jaEltYWdlIiwiaGFuZGxlRXZlbnRFeGFtcGxlIiwicGluY2hFdmVudCJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5REEsSUFBTUEsTUFBTSxTQUFOQSxHQUFNLENBQUNDLEdBQUQsRUFBTUMsSUFBTjtBQUFBLFNBQWVELE1BQU1DLElBQXJCO0FBQUEsQ0FBWjs7QUFFQTs7O0FBR0EsSUFBTUMsZUFBZSxTQUFmQSxZQUFlLENBQUNDLE9BQUQ7QUFBQSxTQUFxQztBQUN4REMsT0FBR0QsUUFBUUUsR0FBUixDQUFZO0FBQUEsYUFBTUMsRUFBRUYsQ0FBUjtBQUFBLEtBQVosRUFBd0JHLE1BQXhCLENBQStCUixHQUEvQixJQUFzQ0ksUUFBUUssTUFETztBQUV4REMsT0FBR04sUUFBUUUsR0FBUixDQUFZO0FBQUEsYUFBTUMsRUFBRUcsQ0FBUjtBQUFBLEtBQVosRUFBd0JGLE1BQXhCLENBQStCUixHQUEvQixJQUFzQ0ksUUFBUUs7QUFGTyxHQUFyQztBQUFBLENBQXJCOztBQUtBLElBQU1FLGFBQWEsU0FBYkEsVUFBYSxDQUFDQyxJQUFEO0FBQUEsU0FBa0IsVUFBQ0MsRUFBRDtBQUFBLFdBQ2xDQSxjQUFjQyxnQkFBZixHQUNFRCxH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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFO0FBQ3pFLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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YnVuZGxlLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9qcy9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYzc3ZTdlZTZiNDZlOWU2OTc3ODgiLCIvLyBAZmxvd1xuXG5jb25zdCBzdW0gPSAoYWNjLCBuZXh0KSA9PiBhY2MgKyBuZXh0O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGF2ZXJhZ2Ugb2YgbXVsdGlwbGUgdmVjdG9ycyAoeCwgeSB2YWx1ZXMpXG4gKi9cbmNvbnN0IGdldFZlY3RvckF2ZyA9ICh2ZWN0b3JzOiBBcnJheTxPYmplY3Q+KTogT2JqZWN0ID0+ICh7XG4gIHg6IHZlY3RvcnMubWFwKHYgPT4gKHYueCkpLnJlZHVjZShzdW0pIC8gdmVjdG9ycy5sZW5ndGgsXG4gIHk6IHZlY3RvcnMubWFwKHYgPT4gKHYueSkpLnJlZHVjZShzdW0pIC8gdmVjdG9ycy5sZW5ndGgsXG59KTtcblxuY29uc3QgZ2V0RWxlbWVudCA9ICh0eXBlOiBzdHJpbmcpID0+IChlbDogRXZlbnRUYXJnZXQpOiBudW1iZXIgPT4gKFxuICAoZWwgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KVxuICA/IGVsW3R5cGVdXG4gIDogMVxuKTtcblxuLyoqXG4gKiBpc1dpdGhpbiAtIENoZWNrIGlmIHZhbHVlIGlzIGJldHdlZW4gdHdvIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7IE51bWJlciB9IHNjYWxlIGN1cnJlbnQgc2NhbGUgdmFsdWVcbiAqIEBwYXJhbSB7IE9iamVjdCB9IG1pblBpbmNoLCBtYXhQaW5oXG4gKiBAcmV0dXJuIHsgQm9vbGVhbiB9XG4gKiovXG5leHBvcnQgY29uc3QgaXNXaXRoaW4gPSAoc2NhbGU6IG51bWJlciwgb3B0czogT2JqZWN0KTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IHsgbWF4U2NhbGUsIG1pblNjYWxlIH0gPSBvcHRzO1xuICByZXR1cm4gKHNjYWxlID49IG1pblNjYWxlKSAmJiAoc2NhbGUgPD0gbWF4U2NhbGUpO1xufTtcblxuLyoqXG4gKiBhZGRPZmZzZXQgLSBDb21iaW5lIGN1cnJlbnQgb2Zmc2V0IHdpdGggb2xkIG9mZnNldCBhbmQgcmV0dXJucyBhIG5ldyBvZmZzZXRcbiAqXG4gKiBAcGFyYW0geyBPYmplY3QgfSBsYXN0T2Zmc2V0IGxhc3Qgb2Zmc2V0XG4gKiBAcGFyYW0geyBPYmplY3QgfSBvZmZzZXQsIG5ldyBvZmZzZXRcbiAqIEByZXR1cm4geyBPYmplY3QgfVxuICoqL1xuZXhwb3J0IGNvbnN0IGFkZE9mZnNldCA9IChsYXN0T2Zmc2V0OiBPYmplY3QsIG9mZnNldDogT2JqZWN0KTogT2JqZWN0ID0+ICh7XG4gIHg6IGxhc3RPZmZzZXQueCArIG9mZnNldC54LFxuICB5OiBsYXN0T2Zmc2V0LnkgKyBvZmZzZXQueSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZ2V0WCA9IGdldEVsZW1lbnQoJ29mZnNldFdpZHRoJyk7XG5leHBvcnQgY29uc3QgZ2V0WSA9IGdldEVsZW1lbnQoJ29mZnNldEhlaWdodCcpO1xuXG4vKipcbiAqIGdldFNjYWxlIC0gQ2hlY2sgaWYgdmFsdWUgaXMgYmV0d2VlbiB0d28gdmFsdWVzXG4gKlxuICogQHBhcmFtIHsgTm9kZSB9IGVsIGN1cnJlbnQgc2NhbGUgdmFsdWVcbiAqIEByZXR1cm4geyBOdW1iZXIgfVxuICoqL1xuZXhwb3J0IGNvbnN0IGdldEluaXRpYWxTY2FsZSA9IChlbDogRXZlbnRUYXJnZXQsIGltYWdlOiBIVE1MRWxlbWVudCk6IG51bWJlciA9PiAoXG4gIChlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpXG4gID8gZ2V0WChlbCkgLyBpbWFnZS5vZmZzZXRXaWR0aFxuICA6IDFcbik7XG5cbi8qKlxuICogU2NhbGVzIHRoZSB6b29tIGZhY3RvciByZWxhdGl2ZSB0byBjdXJyZW50IHN0YXRlXG4gKlxuICogQHBhcmFtIHNjYWxlXG4gKiBAcmV0dXJuIHRoZSBhY3R1YWwgc2NhbGUgKGNhbiBkaWZmZXIgYmVjYXVzZSBvZiBtYXggbWluIHpvb20gZmFjdG9yKVxuICovXG5leHBvcnQgY29uc3QgZ2V0U2NhbGVGYWN0b3IgPSAoc2NhbGU6IG51bWJlciwgZmFjdG9yOiBudW1iZXIsIG9wdHM6IE9iamVjdCk6IE9iamVjdCA9PiB7XG4gIGNvbnN0IG9yaWdpbmFsRmFjdG9yID0gZmFjdG9yO1xuICBsZXQgem9vbUZhY3RvciA9IGZhY3RvciAqIHNjYWxlO1xuICBjb25zdCB7IG1heFNjYWxlVGltZXMsIG1pblNjYWxlVGltZXMgfSA9IG9wdHM7XG4gIHpvb21GYWN0b3IgPSBNYXRoLm1pbihtYXhTY2FsZVRpbWVzLCBNYXRoLm1heCh6b29tRmFjdG9yLCBtaW5TY2FsZVRpbWVzKSk7XG4gIHJldHVybiB6b29tRmFjdG9yIC8gb3JpZ2luYWxGYWN0b3I7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgem9vbSBmYWN0b3IgcmVsYXRpdmUgdG8gY3VycmVudCBzdGF0ZVxuICpcbiAqIEBwYXJhbSBzY2FsZVxuICogQHJldHVybiB0aGUgYWN0dWFsIHNjYWxlIChjYW4gZGlmZmVyIGJlY2F1c2Ugb2YgbWF4IG1pbiB6b29tIGZhY3RvcilcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFpvb21GYWN0b3IgPSAoc2NhbGU6IG51bWJlciwgZmFjdG9yOiBudW1iZXIsIG9wdHM6IE9iamVjdCk6IE9iamVjdCA9PiB7XG4gIGNvbnN0IHsgbWF4U2NhbGVUaW1lcywgbWluU2NhbGVUaW1lcyB9ID0gb3B0cztcbiAgcmV0dXJuIE1hdGgubWluKG1heFNjYWxlVGltZXMsIE1hdGgubWF4KGZhY3RvciAqIHNjYWxlLCBtaW5TY2FsZVRpbWVzKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VG91Y2hDZW50ZXIgPSAodG91Y2hlczogQXJyYXk8T2JqZWN0PikgPT4gZ2V0VmVjdG9yQXZnKHRvdWNoZXMpO1xuXG5leHBvcnQgY29uc3QgY2FsY05ld1NjYWxlID0gKHRvOiBudW1iZXIsIGxhc3RTY2FsZTogbnVtYmVyID0gMSk6IG51bWJlciA9PiAoXG4gIHRvIC8gbGFzdFNjYWxlXG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL2hhbmRsZS1waW5jaC5qcyIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZGVmYXVsdCB0YXJnZXQgPT4gKGUpID0+IHtcbiAgY29uc3QgbmV3U3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgbGV0IHRpbWUgPSBuZXcgRGF0ZSgpO1xuICB0aW1lID0gdGltZS5nZXRIb3VycygpICsgJzonICsgdGltZS5nZXRNaW51dGVzKCkgKyAnOicgKyB0aW1lLmdldFNlY29uZHMoKSArICcsJyArIHRpbWUuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gIGNvbnN0IG5ld0NvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnWycgKyB0aW1lICsgJ10gRXZlbnQgZGlzcGF0Y2hlZDogXCInICsgZS50eXBlICsgJ1wiJyk7XG4gIG5ld1NwYW4uYXBwZW5kQ2hpbGQobmV3Q29udGVudCk7XG4gIHRhcmdldC5hcHBlbmRDaGlsZChuZXdTcGFuKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kb2NzL2hhbmRsZS1ldmVudC5qcyIsImltcG9ydCBwaW5jaEl0IGZyb20gJy4vcGluY2gtaXQnO1xuXG5leHBvcnQgZGVmYXVsdCBwaW5jaEl0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2luZGV4LmpzIiwiXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNvcmUuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxudmFyIF9zZWxmID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuXHQ/IHdpbmRvdyAgIC8vIGlmIGluIGJyb3dzZXJcblx0OiAoXG5cdFx0KHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKVxuXHRcdD8gc2VsZiAvLyBpZiBpbiB3b3JrZXJcblx0XHQ6IHt9ICAgLy8gaWYgaW4gbm9kZSBqc1xuXHQpO1xuXG4vKipcbiAqIFByaXNtOiBMaWdodHdlaWdodCwgcm9idXN0LCBlbGVnYW50IHN5bnRheCBoaWdobGlnaHRpbmdcbiAqIE1JVCBsaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwL1xuICogQGF1dGhvciBMZWEgVmVyb3UgaHR0cDovL2xlYS52ZXJvdS5tZVxuICovXG5cbnZhciBQcmlzbSA9IChmdW5jdGlvbigpe1xuXG4vLyBQcml2YXRlIGhlbHBlciB2YXJzXG52YXIgbGFuZyA9IC9cXGJsYW5nKD86dWFnZSk/LShcXHcrKVxcYi9pO1xudmFyIHVuaXF1ZUlkID0gMDtcblxudmFyIF8gPSBfc2VsZi5QcmlzbSA9IHtcblx0dXRpbDoge1xuXHRcdGVuY29kZTogZnVuY3Rpb24gKHRva2Vucykge1xuXHRcdFx0aWYgKHRva2VucyBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgVG9rZW4odG9rZW5zLnR5cGUsIF8udXRpbC5lbmNvZGUodG9rZW5zLmNvbnRlbnQpLCB0b2tlbnMuYWxpYXMpO1xuXHRcdFx0fSBlbHNlIGlmIChfLnV0aWwudHlwZSh0b2tlbnMpID09PSAnQXJyYXknKSB7XG5cdFx0XHRcdHJldHVybiB0b2tlbnMubWFwKF8udXRpbC5lbmNvZGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRva2Vucy5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC9cXHUwMGEwL2csICcgJyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHR5cGU6IGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLm1hdGNoKC9cXFtvYmplY3QgKFxcdyspXFxdLylbMV07XG5cdFx0fSxcblxuXHRcdG9iaklkOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRpZiAoIW9ialsnX19pZCddKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICdfX2lkJywgeyB2YWx1ZTogKyt1bmlxdWVJZCB9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmpbJ19faWQnXTtcblx0XHR9LFxuXG5cdFx0Ly8gRGVlcCBjbG9uZSBhIGxhbmd1YWdlIGRlZmluaXRpb24gKGUuZy4gdG8gZXh0ZW5kIGl0KVxuXHRcdGNsb25lOiBmdW5jdGlvbiAobykge1xuXHRcdFx0dmFyIHR5cGUgPSBfLnV0aWwudHlwZShvKTtcblxuXHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRcdFx0dmFyIGNsb25lID0ge307XG5cblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbykge1xuXHRcdFx0XHRcdFx0aWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0XHRjbG9uZVtrZXldID0gXy51dGlsLmNsb25lKG9ba2V5XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGNsb25lO1xuXG5cdFx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0XHQvLyBDaGVjayBmb3IgZXhpc3RlbmNlIGZvciBJRThcblx0XHRcdFx0XHRyZXR1cm4gby5tYXAgJiYgby5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gXy51dGlsLmNsb25lKHYpOyB9KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG87XG5cdFx0fVxuXHR9LFxuXG5cdGxhbmd1YWdlczoge1xuXHRcdGV4dGVuZDogZnVuY3Rpb24gKGlkLCByZWRlZikge1xuXHRcdFx0dmFyIGxhbmcgPSBfLnV0aWwuY2xvbmUoXy5sYW5ndWFnZXNbaWRdKTtcblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIHJlZGVmKSB7XG5cdFx0XHRcdGxhbmdba2V5XSA9IHJlZGVmW2tleV07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBsYW5nO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBJbnNlcnQgYSB0b2tlbiBiZWZvcmUgYW5vdGhlciB0b2tlbiBpbiBhIGxhbmd1YWdlIGxpdGVyYWxcblx0XHQgKiBBcyB0aGlzIG5lZWRzIHRvIHJlY3JlYXRlIHRoZSBvYmplY3QgKHdlIGNhbm5vdCBhY3R1YWxseSBpbnNlcnQgYmVmb3JlIGtleXMgaW4gb2JqZWN0IGxpdGVyYWxzKSxcblx0XHQgKiB3ZSBjYW5ub3QganVzdCBwcm92aWRlIGFuIG9iamVjdCwgd2UgbmVlZCBhbm9iamVjdCBhbmQgYSBrZXkuXG5cdFx0ICogQHBhcmFtIGluc2lkZSBUaGUga2V5IChvciBsYW5ndWFnZSBpZCkgb2YgdGhlIHBhcmVudFxuXHRcdCAqIEBwYXJhbSBiZWZvcmUgVGhlIGtleSB0byBpbnNlcnQgYmVmb3JlLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBmdW5jdGlvbiBhcHBlbmRzIGluc3RlYWQuXG5cdFx0ICogQHBhcmFtIGluc2VydCBPYmplY3Qgd2l0aCB0aGUga2V5L3ZhbHVlIHBhaXJzIHRvIGluc2VydFxuXHRcdCAqIEBwYXJhbSByb290IFRoZSBvYmplY3QgdGhhdCBjb250YWlucyBgaW5zaWRlYC4gSWYgZXF1YWwgdG8gUHJpc20ubGFuZ3VhZ2VzLCBpdCBjYW4gYmUgb21pdHRlZC5cblx0XHQgKi9cblx0XHRpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChpbnNpZGUsIGJlZm9yZSwgaW5zZXJ0LCByb290KSB7XG5cdFx0XHRyb290ID0gcm9vdCB8fCBfLmxhbmd1YWdlcztcblx0XHRcdHZhciBncmFtbWFyID0gcm9vdFtpbnNpZGVdO1xuXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG5cdFx0XHRcdGluc2VydCA9IGFyZ3VtZW50c1sxXTtcblxuXHRcdFx0XHRmb3IgKHZhciBuZXdUb2tlbiBpbiBpbnNlcnQpIHtcblx0XHRcdFx0XHRpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuXHRcdFx0XHRcdFx0Z3JhbW1hcltuZXdUb2tlbl0gPSBpbnNlcnRbbmV3VG9rZW5dO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBncmFtbWFyO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmV0ID0ge307XG5cblx0XHRcdGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcblxuXHRcdFx0XHRpZiAoZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcblxuXHRcdFx0XHRcdGlmICh0b2tlbiA9PSBiZWZvcmUpIHtcblxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgbmV3VG9rZW4gaW4gaW5zZXJ0KSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGluc2VydC5oYXNPd25Qcm9wZXJ0eShuZXdUb2tlbikpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXRbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldFt0b2tlbl0gPSBncmFtbWFyW3Rva2VuXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgcmVmZXJlbmNlcyBpbiBvdGhlciBsYW5ndWFnZSBkZWZpbml0aW9uc1xuXHRcdFx0Xy5sYW5ndWFnZXMuREZTKF8ubGFuZ3VhZ2VzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gcm9vdFtpbnNpZGVdICYmIGtleSAhPSBpbnNpZGUpIHtcblx0XHRcdFx0XHR0aGlzW2tleV0gPSByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gcm9vdFtpbnNpZGVdID0gcmV0O1xuXHRcdH0sXG5cblx0XHQvLyBUcmF2ZXJzZSBhIGxhbmd1YWdlIGRlZmluaXRpb24gd2l0aCBEZXB0aCBGaXJzdCBTZWFyY2hcblx0XHRERlM6IGZ1bmN0aW9uKG8sIGNhbGxiYWNrLCB0eXBlLCB2aXNpdGVkKSB7XG5cdFx0XHR2aXNpdGVkID0gdmlzaXRlZCB8fCB7fTtcblx0XHRcdGZvciAodmFyIGkgaW4gbykge1xuXHRcdFx0XHRpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwobywgaSwgb1tpXSwgdHlwZSB8fCBpKTtcblxuXHRcdFx0XHRcdGlmIChfLnV0aWwudHlwZShvW2ldKSA9PT0gJ09iamVjdCcgJiYgIXZpc2l0ZWRbXy51dGlsLm9iaklkKG9baV0pXSkge1xuXHRcdFx0XHRcdFx0dmlzaXRlZFtfLnV0aWwub2JqSWQob1tpXSldID0gdHJ1ZTtcblx0XHRcdFx0XHRcdF8ubGFuZ3VhZ2VzLkRGUyhvW2ldLCBjYWxsYmFjaywgbnVsbCwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKF8udXRpbC50eXBlKG9baV0pID09PSAnQXJyYXknICYmICF2aXNpdGVkW18udXRpbC5vYmpJZChvW2ldKV0pIHtcblx0XHRcdFx0XHRcdHZpc2l0ZWRbXy51dGlsLm9iaklkKG9baV0pXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRfLmxhbmd1YWdlcy5ERlMob1tpXSwgY2FsbGJhY2ssIGksIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0cGx1Z2luczoge30sXG5cblx0aGlnaGxpZ2h0QWxsOiBmdW5jdGlvbihhc3luYywgY2FsbGJhY2spIHtcblx0XHR2YXIgZW52ID0ge1xuXHRcdFx0Y2FsbGJhY2s6IGNhbGxiYWNrLFxuXHRcdFx0c2VsZWN0b3I6ICdjb2RlW2NsYXNzKj1cImxhbmd1YWdlLVwiXSwgW2NsYXNzKj1cImxhbmd1YWdlLVwiXSBjb2RlLCBjb2RlW2NsYXNzKj1cImxhbmctXCJdLCBbY2xhc3MqPVwibGFuZy1cIl0gY29kZSdcblx0XHR9O1xuXG5cdFx0Xy5ob29rcy5ydW4oXCJiZWZvcmUtaGlnaGxpZ2h0YWxsXCIsIGVudik7XG5cblx0XHR2YXIgZWxlbWVudHMgPSBlbnYuZWxlbWVudHMgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbnYuc2VsZWN0b3IpO1xuXG5cdFx0Zm9yICh2YXIgaT0wLCBlbGVtZW50OyBlbGVtZW50ID0gZWxlbWVudHNbaSsrXTspIHtcblx0XHRcdF8uaGlnaGxpZ2h0RWxlbWVudChlbGVtZW50LCBhc3luYyA9PT0gdHJ1ZSwgZW52LmNhbGxiYWNrKTtcblx0XHR9XG5cdH0sXG5cblx0aGlnaGxpZ2h0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgYXN5bmMsIGNhbGxiYWNrKSB7XG5cdFx0Ly8gRmluZCBsYW5ndWFnZVxuXHRcdHZhciBsYW5ndWFnZSwgZ3JhbW1hciwgcGFyZW50ID0gZWxlbWVudDtcblxuXHRcdHdoaWxlIChwYXJlbnQgJiYgIWxhbmcudGVzdChwYXJlbnQuY2xhc3NOYW1lKSkge1xuXHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0bGFuZ3VhZ2UgPSAocGFyZW50LmNsYXNzTmFtZS5tYXRjaChsYW5nKSB8fCBbLCcnXSlbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdGdyYW1tYXIgPSBfLmxhbmd1YWdlc1tsYW5ndWFnZV07XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IGxhbmd1YWdlIG9uIHRoZSBlbGVtZW50LCBpZiBub3QgcHJlc2VudFxuXHRcdGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShsYW5nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpICsgJyBsYW5ndWFnZS0nICsgbGFuZ3VhZ2U7XG5cblx0XHQvLyBTZXQgbGFuZ3VhZ2Ugb24gdGhlIHBhcmVudCwgZm9yIHN0eWxpbmdcblx0XHRwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cblx0XHRpZiAoL3ByZS9pLnRlc3QocGFyZW50Lm5vZGVOYW1lKSkge1xuXHRcdFx0cGFyZW50LmNsYXNzTmFtZSA9IHBhcmVudC5jbGFzc05hbWUucmVwbGFjZShsYW5nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpICsgJyBsYW5ndWFnZS0nICsgbGFuZ3VhZ2U7XG5cdFx0fVxuXG5cdFx0dmFyIGNvZGUgPSBlbGVtZW50LnRleHRDb250ZW50O1xuXG5cdFx0dmFyIGVudiA9IHtcblx0XHRcdGVsZW1lbnQ6IGVsZW1lbnQsXG5cdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2UsXG5cdFx0XHRncmFtbWFyOiBncmFtbWFyLFxuXHRcdFx0Y29kZTogY29kZVxuXHRcdH07XG5cblx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLXNhbml0eS1jaGVjaycsIGVudik7XG5cblx0XHRpZiAoIWVudi5jb2RlIHx8ICFlbnYuZ3JhbW1hcikge1xuXHRcdFx0aWYgKGVudi5jb2RlKSB7XG5cdFx0XHRcdGVudi5lbGVtZW50LnRleHRDb250ZW50ID0gZW52LmNvZGU7XG5cdFx0XHR9XG5cdFx0XHRfLmhvb2tzLnJ1bignY29tcGxldGUnLCBlbnYpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdF8uaG9va3MucnVuKCdiZWZvcmUtaGlnaGxpZ2h0JywgZW52KTtcblxuXHRcdGlmIChhc3luYyAmJiBfc2VsZi5Xb3JrZXIpIHtcblx0XHRcdHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKF8uZmlsZW5hbWUpO1xuXG5cdFx0XHR3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHRcdGVudi5oaWdobGlnaHRlZENvZGUgPSBldnQuZGF0YTtcblxuXHRcdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWluc2VydCcsIGVudik7XG5cblx0XHRcdFx0ZW52LmVsZW1lbnQuaW5uZXJIVE1MID0gZW52LmhpZ2hsaWdodGVkQ29kZTtcblxuXHRcdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVudi5lbGVtZW50KTtcblx0XHRcdFx0Xy5ob29rcy5ydW4oJ2FmdGVyLWhpZ2hsaWdodCcsIGVudik7XG5cdFx0XHRcdF8uaG9va3MucnVuKCdjb21wbGV0ZScsIGVudik7XG5cdFx0XHR9O1xuXG5cdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuXHRcdFx0XHRsYW5ndWFnZTogZW52Lmxhbmd1YWdlLFxuXHRcdFx0XHRjb2RlOiBlbnYuY29kZSxcblx0XHRcdFx0aW1tZWRpYXRlQ2xvc2U6IHRydWVcblx0XHRcdH0pKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRlbnYuaGlnaGxpZ2h0ZWRDb2RlID0gXy5oaWdobGlnaHQoZW52LmNvZGUsIGVudi5ncmFtbWFyLCBlbnYubGFuZ3VhZ2UpO1xuXG5cdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWluc2VydCcsIGVudik7XG5cblx0XHRcdGVudi5lbGVtZW50LmlubmVySFRNTCA9IGVudi5oaWdobGlnaHRlZENvZGU7XG5cblx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZWxlbWVudCk7XG5cblx0XHRcdF8uaG9va3MucnVuKCdhZnRlci1oaWdobGlnaHQnLCBlbnYpO1xuXHRcdFx0Xy5ob29rcy5ydW4oJ2NvbXBsZXRlJywgZW52KTtcblx0XHR9XG5cdH0sXG5cblx0aGlnaGxpZ2h0OiBmdW5jdGlvbiAodGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcblx0XHR2YXIgdG9rZW5zID0gXy50b2tlbml6ZSh0ZXh0LCBncmFtbWFyKTtcblx0XHRyZXR1cm4gVG9rZW4uc3RyaW5naWZ5KF8udXRpbC5lbmNvZGUodG9rZW5zKSwgbGFuZ3VhZ2UpO1xuXHR9LFxuXG5cdHRva2VuaXplOiBmdW5jdGlvbih0ZXh0LCBncmFtbWFyLCBsYW5ndWFnZSkge1xuXHRcdHZhciBUb2tlbiA9IF8uVG9rZW47XG5cblx0XHR2YXIgc3RyYXJyID0gW3RleHRdO1xuXG5cdFx0dmFyIHJlc3QgPSBncmFtbWFyLnJlc3Q7XG5cblx0XHRpZiAocmVzdCkge1xuXHRcdFx0Zm9yICh2YXIgdG9rZW4gaW4gcmVzdCkge1xuXHRcdFx0XHRncmFtbWFyW3Rva2VuXSA9IHJlc3RbdG9rZW5dO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWxldGUgZ3JhbW1hci5yZXN0O1xuXHRcdH1cblxuXHRcdHRva2VubG9vcDogZm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuXHRcdFx0aWYoIWdyYW1tYXIuaGFzT3duUHJvcGVydHkodG9rZW4pIHx8ICFncmFtbWFyW3Rva2VuXSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHBhdHRlcm5zID0gZ3JhbW1hclt0b2tlbl07XG5cdFx0XHRwYXR0ZXJucyA9IChfLnV0aWwudHlwZShwYXR0ZXJucykgPT09IFwiQXJyYXlcIikgPyBwYXR0ZXJucyA6IFtwYXR0ZXJuc107XG5cblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgcGF0dGVybnMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0dmFyIHBhdHRlcm4gPSBwYXR0ZXJuc1tqXSxcblx0XHRcdFx0XHRpbnNpZGUgPSBwYXR0ZXJuLmluc2lkZSxcblx0XHRcdFx0XHRsb29rYmVoaW5kID0gISFwYXR0ZXJuLmxvb2tiZWhpbmQsXG5cdFx0XHRcdFx0Z3JlZWR5ID0gISFwYXR0ZXJuLmdyZWVkeSxcblx0XHRcdFx0XHRsb29rYmVoaW5kTGVuZ3RoID0gMCxcblx0XHRcdFx0XHRhbGlhcyA9IHBhdHRlcm4uYWxpYXM7XG5cblx0XHRcdFx0aWYgKGdyZWVkeSAmJiAhcGF0dGVybi5wYXR0ZXJuLmdsb2JhbCkge1xuXHRcdFx0XHRcdC8vIFdpdGhvdXQgdGhlIGdsb2JhbCBmbGFnLCBsYXN0SW5kZXggd29uJ3Qgd29ya1xuXHRcdFx0XHRcdHZhciBmbGFncyA9IHBhdHRlcm4ucGF0dGVybi50b1N0cmluZygpLm1hdGNoKC9baW11eV0qJC8pWzBdO1xuXHRcdFx0XHRcdHBhdHRlcm4ucGF0dGVybiA9IFJlZ0V4cChwYXR0ZXJuLnBhdHRlcm4uc291cmNlLCBmbGFncyArIFwiZ1wiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBhdHRlcm4gPSBwYXR0ZXJuLnBhdHRlcm4gfHwgcGF0dGVybjtcblxuXHRcdFx0XHQvLyBEb27igJl0IGNhY2hlIGxlbmd0aCBhcyBpdCBjaGFuZ2VzIGR1cmluZyB0aGUgbG9vcFxuXHRcdFx0XHRmb3IgKHZhciBpPTAsIHBvcyA9IDA7IGk8c3RyYXJyLmxlbmd0aDsgcG9zICs9IHN0cmFycltpXS5sZW5ndGgsICsraSkge1xuXG5cdFx0XHRcdFx0dmFyIHN0ciA9IHN0cmFycltpXTtcblxuXHRcdFx0XHRcdGlmIChzdHJhcnIubGVuZ3RoID4gdGV4dC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdC8vIFNvbWV0aGluZyB3ZW50IHRlcnJpYmx5IHdyb25nLCBBQk9SVCwgQUJPUlQhXG5cdFx0XHRcdFx0XHRicmVhayB0b2tlbmxvb3A7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHN0ciBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG5cblx0XHRcdFx0XHR2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyKSxcblx0XHRcdFx0XHQgICAgZGVsTnVtID0gMTtcblxuXHRcdFx0XHRcdC8vIEdyZWVkeSBwYXR0ZXJucyBjYW4gb3ZlcnJpZGUvcmVtb3ZlIHVwIHRvIHR3byBwcmV2aW91c2x5IG1hdGNoZWQgdG9rZW5zXG5cdFx0XHRcdFx0aWYgKCFtYXRjaCAmJiBncmVlZHkgJiYgaSAhPSBzdHJhcnIubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0cGF0dGVybi5sYXN0SW5kZXggPSBwb3M7XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHBhdHRlcm4uZXhlYyh0ZXh0KTtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBmcm9tID0gbWF0Y2guaW5kZXggKyAobG9va2JlaGluZCA/IG1hdGNoWzFdLmxlbmd0aCA6IDApLFxuXHRcdFx0XHRcdFx0ICAgIHRvID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgsXG5cdFx0XHRcdFx0XHQgICAgayA9IGksXG5cdFx0XHRcdFx0XHQgICAgcCA9IHBvcztcblxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgbGVuID0gc3RyYXJyLmxlbmd0aDsgayA8IGxlbiAmJiBwIDwgdG87ICsraykge1xuXHRcdFx0XHRcdFx0XHRwICs9IHN0cmFycltrXS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdC8vIE1vdmUgdGhlIGluZGV4IGkgdG8gdGhlIGVsZW1lbnQgaW4gc3RyYXJyIHRoYXQgaXMgY2xvc2VzdCB0byBmcm9tXG5cdFx0XHRcdFx0XHRcdGlmIChmcm9tID49IHApIHtcblx0XHRcdFx0XHRcdFx0XHQrK2k7XG5cdFx0XHRcdFx0XHRcdFx0cG9zID0gcDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFx0ICogSWYgc3RyYXJyW2ldIGlzIGEgVG9rZW4sIHRoZW4gdGhlIG1hdGNoIHN0YXJ0cyBpbnNpZGUgYW5vdGhlciBUb2tlbiwgd2hpY2ggaXMgaW52YWxpZFxuXHRcdFx0XHRcdFx0ICogSWYgc3RyYXJyW2sgLSAxXSBpcyBncmVlZHkgd2UgYXJlIGluIGNvbmZsaWN0IHdpdGggYW5vdGhlciBncmVlZHkgcGF0dGVyblxuXHRcdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0XHRpZiAoc3RyYXJyW2ldIGluc3RhbmNlb2YgVG9rZW4gfHwgc3RyYXJyW2sgLSAxXS5ncmVlZHkpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE51bWJlciBvZiB0b2tlbnMgdG8gZGVsZXRlIGFuZCByZXBsYWNlIHdpdGggdGhlIG5ldyBtYXRjaFxuXHRcdFx0XHRcdFx0ZGVsTnVtID0gayAtIGk7XG5cdFx0XHRcdFx0XHRzdHIgPSB0ZXh0LnNsaWNlKHBvcywgcCk7XG5cdFx0XHRcdFx0XHRtYXRjaC5pbmRleCAtPSBwb3M7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCFtYXRjaCkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYobG9va2JlaGluZCkge1xuXHRcdFx0XHRcdFx0bG9va2JlaGluZExlbmd0aCA9IG1hdGNoWzFdLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgZnJvbSA9IG1hdGNoLmluZGV4ICsgbG9va2JlaGluZExlbmd0aCxcblx0XHRcdFx0XHQgICAgbWF0Y2ggPSBtYXRjaFswXS5zbGljZShsb29rYmVoaW5kTGVuZ3RoKSxcblx0XHRcdFx0XHQgICAgdG8gPSBmcm9tICsgbWF0Y2gubGVuZ3RoLFxuXHRcdFx0XHRcdCAgICBiZWZvcmUgPSBzdHIuc2xpY2UoMCwgZnJvbSksXG5cdFx0XHRcdFx0ICAgIGFmdGVyID0gc3RyLnNsaWNlKHRvKTtcblxuXHRcdFx0XHRcdHZhciBhcmdzID0gW2ksIGRlbE51bV07XG5cblx0XHRcdFx0XHRpZiAoYmVmb3JlKSB7XG5cdFx0XHRcdFx0XHRhcmdzLnB1c2goYmVmb3JlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgd3JhcHBlZCA9IG5ldyBUb2tlbih0b2tlbiwgaW5zaWRlPyBfLnRva2VuaXplKG1hdGNoLCBpbnNpZGUpIDogbWF0Y2gsIGFsaWFzLCBtYXRjaCwgZ3JlZWR5KTtcblxuXHRcdFx0XHRcdGFyZ3MucHVzaCh3cmFwcGVkKTtcblxuXHRcdFx0XHRcdGlmIChhZnRlcikge1xuXHRcdFx0XHRcdFx0YXJncy5wdXNoKGFmdGVyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KHN0cmFyciwgYXJncyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyYXJyO1xuXHR9LFxuXG5cdGhvb2tzOiB7XG5cdFx0YWxsOiB7fSxcblxuXHRcdGFkZDogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgaG9va3MgPSBfLmhvb2tzLmFsbDtcblxuXHRcdFx0aG9va3NbbmFtZV0gPSBob29rc1tuYW1lXSB8fCBbXTtcblxuXHRcdFx0aG9va3NbbmFtZV0ucHVzaChjYWxsYmFjayk7XG5cdFx0fSxcblxuXHRcdHJ1bjogZnVuY3Rpb24gKG5hbWUsIGVudikge1xuXHRcdFx0dmFyIGNhbGxiYWNrcyA9IF8uaG9va3MuYWxsW25hbWVdO1xuXG5cdFx0XHRpZiAoIWNhbGxiYWNrcyB8fCAhY2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGk9MCwgY2FsbGJhY2s7IGNhbGxiYWNrID0gY2FsbGJhY2tzW2krK107KSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVudik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgVG9rZW4gPSBfLlRva2VuID0gZnVuY3Rpb24odHlwZSwgY29udGVudCwgYWxpYXMsIG1hdGNoZWRTdHIsIGdyZWVkeSkge1xuXHR0aGlzLnR5cGUgPSB0eXBlO1xuXHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXHR0aGlzLmFsaWFzID0gYWxpYXM7XG5cdC8vIENvcHkgb2YgdGhlIGZ1bGwgc3RyaW5nIHRoaXMgdG9rZW4gd2FzIGNyZWF0ZWQgZnJvbVxuXHR0aGlzLmxlbmd0aCA9IChtYXRjaGVkU3RyIHx8IFwiXCIpLmxlbmd0aHwwO1xuXHR0aGlzLmdyZWVkeSA9ICEhZ3JlZWR5O1xufTtcblxuVG9rZW4uc3RyaW5naWZ5ID0gZnVuY3Rpb24obywgbGFuZ3VhZ2UsIHBhcmVudCkge1xuXHRpZiAodHlwZW9mIG8gPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gbztcblx0fVxuXG5cdGlmIChfLnV0aWwudHlwZShvKSA9PT0gJ0FycmF5Jykge1xuXHRcdHJldHVybiBvLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gVG9rZW4uc3RyaW5naWZ5KGVsZW1lbnQsIGxhbmd1YWdlLCBvKTtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdHZhciBlbnYgPSB7XG5cdFx0dHlwZTogby50eXBlLFxuXHRcdGNvbnRlbnQ6IFRva2VuLnN0cmluZ2lmeShvLmNvbnRlbnQsIGxhbmd1YWdlLCBwYXJlbnQpLFxuXHRcdHRhZzogJ3NwYW4nLFxuXHRcdGNsYXNzZXM6IFsndG9rZW4nLCBvLnR5cGVdLFxuXHRcdGF0dHJpYnV0ZXM6IHt9LFxuXHRcdGxhbmd1YWdlOiBsYW5ndWFnZSxcblx0XHRwYXJlbnQ6IHBhcmVudFxuXHR9O1xuXG5cdGlmIChlbnYudHlwZSA9PSAnY29tbWVudCcpIHtcblx0XHRlbnYuYXR0cmlidXRlc1snc3BlbGxjaGVjayddID0gJ3RydWUnO1xuXHR9XG5cblx0aWYgKG8uYWxpYXMpIHtcblx0XHR2YXIgYWxpYXNlcyA9IF8udXRpbC50eXBlKG8uYWxpYXMpID09PSAnQXJyYXknID8gby5hbGlhcyA6IFtvLmFsaWFzXTtcblx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbnYuY2xhc3NlcywgYWxpYXNlcyk7XG5cdH1cblxuXHRfLmhvb2tzLnJ1bignd3JhcCcsIGVudik7XG5cblx0dmFyIGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhlbnYuYXR0cmlidXRlcykubWFwKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRyZXR1cm4gbmFtZSArICc9XCInICsgKGVudi5hdHRyaWJ1dGVzW25hbWVdIHx8ICcnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykgKyAnXCInO1xuXHR9KS5qb2luKCcgJyk7XG5cblx0cmV0dXJuICc8JyArIGVudi50YWcgKyAnIGNsYXNzPVwiJyArIGVudi5jbGFzc2VzLmpvaW4oJyAnKSArICdcIicgKyAoYXR0cmlidXRlcyA/ICcgJyArIGF0dHJpYnV0ZXMgOiAnJykgKyAnPicgKyBlbnYuY29udGVudCArICc8LycgKyBlbnYudGFnICsgJz4nO1xuXG59O1xuXG5pZiAoIV9zZWxmLmRvY3VtZW50KSB7XG5cdGlmICghX3NlbGYuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdC8vIGluIE5vZGUuanNcblx0XHRyZXR1cm4gX3NlbGYuUHJpc207XG5cdH1cbiBcdC8vIEluIHdvcmtlclxuXHRfc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZXZ0KSB7XG5cdFx0dmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2dC5kYXRhKSxcblx0XHQgICAgbGFuZyA9IG1lc3NhZ2UubGFuZ3VhZ2UsXG5cdFx0ICAgIGNvZGUgPSBtZXNzYWdlLmNvZGUsXG5cdFx0ICAgIGltbWVkaWF0ZUNsb3NlID0gbWVzc2FnZS5pbW1lZGlhdGVDbG9zZTtcblxuXHRcdF9zZWxmLnBvc3RNZXNzYWdlKF8uaGlnaGxpZ2h0KGNvZGUsIF8ubGFuZ3VhZ2VzW2xhbmddLCBsYW5nKSk7XG5cdFx0aWYgKGltbWVkaWF0ZUNsb3NlKSB7XG5cdFx0XHRfc2VsZi5jbG9zZSgpO1xuXHRcdH1cblx0fSwgZmFsc2UpO1xuXG5cdHJldHVybiBfc2VsZi5QcmlzbTtcbn1cblxuLy9HZXQgY3VycmVudCBzY3JpcHQgYW5kIGhpZ2hsaWdodFxudmFyIHNjcmlwdCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgfHwgW10uc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKSkucG9wKCk7XG5cbmlmIChzY3JpcHQpIHtcblx0Xy5maWxlbmFtZSA9IHNjcmlwdC5zcmM7XG5cblx0aWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgJiYgIXNjcmlwdC5oYXNBdHRyaWJ1dGUoJ2RhdGEtbWFudWFsJykpIHtcblx0XHRpZihkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIikge1xuXHRcdFx0aWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShfLmhpZ2hsaWdodEFsbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dChfLmhpZ2hsaWdodEFsbCwgMTYpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBfLmhpZ2hsaWdodEFsbCk7XG5cdFx0fVxuXHR9XG59XG5cbnJldHVybiBfc2VsZi5QcmlzbTtcblxufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gUHJpc207XG59XG5cbi8vIGhhY2sgZm9yIGNvbXBvbmVudHMgdG8gd29yayBjb3JyZWN0bHkgaW4gbm9kZS5qc1xuaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdGdsb2JhbC5QcmlzbSA9IFByaXNtO1xufVxuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tbWFya3VwLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5tYXJrdXAgPSB7XG5cdCdjb21tZW50JzogLzwhLS1bXFx3XFxXXSo/LS0+Lyxcblx0J3Byb2xvZyc6IC88XFw/W1xcd1xcV10rP1xcPz4vLFxuXHQnZG9jdHlwZSc6IC88IURPQ1RZUEVbXFx3XFxXXSs/Pi9pLFxuXHQnY2RhdGEnOiAvPCFcXFtDREFUQVxcW1tcXHdcXFddKj9dXT4vaSxcblx0J3RhZyc6IHtcblx0XHRwYXR0ZXJuOiAvPFxcLz8oPyFcXGQpW15cXHM+XFwvPSQ8XSsoPzpcXHMrW15cXHM+XFwvPV0rKD86PSg/OihcInwnKSg/OlxcXFxcXDF8XFxcXD8oPyFcXDEpW1xcd1xcV10pKlxcMXxbXlxccydcIj49XSspKT8pKlxccypcXC8/Pi9pLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J3RhZyc6IHtcblx0XHRcdFx0cGF0dGVybjogL148XFwvP1teXFxzPlxcL10rL2ksXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9ePFxcLz8vLFxuXHRcdFx0XHRcdCduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQnYXR0ci12YWx1ZSc6IHtcblx0XHRcdFx0cGF0dGVybjogLz0oPzooJ3xcIilbXFx3XFxXXSo/KFxcMSl8W15cXHM+XSspL2ksXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9bPT5cIiddL1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0J3B1bmN0dWF0aW9uJzogL1xcLz8+Lyxcblx0XHRcdCdhdHRyLW5hbWUnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9bXlxccz5cXC9dKy8sXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblx0fSxcblx0J2VudGl0eSc6IC8mIz9bXFxkYS16XXsxLDh9Oy9pXG59O1xuXG4vLyBQbHVnaW4gdG8gbWFrZSBlbnRpdHkgdGl0bGUgc2hvdyB0aGUgcmVhbCBlbnRpdHksIGlkZWEgYnkgUm9tYW4gS29tYXJvdlxuUHJpc20uaG9va3MuYWRkKCd3cmFwJywgZnVuY3Rpb24oZW52KSB7XG5cblx0aWYgKGVudi50eXBlID09PSAnZW50aXR5Jykge1xuXHRcdGVudi5hdHRyaWJ1dGVzWyd0aXRsZSddID0gZW52LmNvbnRlbnQucmVwbGFjZSgvJmFtcDsvLCAnJicpO1xuXHR9XG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLnhtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMuaHRtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMubWF0aG1sID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblByaXNtLmxhbmd1YWdlcy5zdmcgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY3NzLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5jc3MgPSB7XG5cdCdjb21tZW50JzogL1xcL1xcKltcXHdcXFddKj9cXCpcXC8vLFxuXHQnYXRydWxlJzoge1xuXHRcdHBhdHRlcm46IC9AW1xcdy1dKz8uKj8oO3woPz1cXHMqXFx7KSkvaSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdydWxlJzogL0BbXFx3LV0rL1xuXHRcdFx0Ly8gU2VlIHJlc3QgYmVsb3dcblx0XHR9XG5cdH0sXG5cdCd1cmwnOiAvdXJsXFwoKD86KFtcIiddKShcXFxcKD86XFxyXFxufFtcXHdcXFddKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxfC4qPylcXCkvaSxcblx0J3NlbGVjdG9yJzogL1teXFx7XFx9XFxzXVteXFx7XFx9O10qPyg/PVxccypcXHspLyxcblx0J3N0cmluZyc6IHtcblx0XHRwYXR0ZXJuOiAvKFwifCcpKFxcXFwoPzpcXHJcXG58W1xcd1xcV10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQncHJvcGVydHknOiAvKFxcYnxcXEIpW1xcdy1dKyg/PVxccyo6KS9pLFxuXHQnaW1wb3J0YW50JzogL1xcQiFpbXBvcnRhbnRcXGIvaSxcblx0J2Z1bmN0aW9uJzogL1stYS16MC05XSsoPz1cXCgpL2ksXG5cdCdwdW5jdHVhdGlvbic6IC9bKCl7fTs6XS9cbn07XG5cblByaXNtLmxhbmd1YWdlcy5jc3NbJ2F0cnVsZSddLmluc2lkZS5yZXN0ID0gUHJpc20udXRpbC5jbG9uZShQcmlzbS5sYW5ndWFnZXMuY3NzKTtcblxuaWYgKFByaXNtLmxhbmd1YWdlcy5tYXJrdXApIHtcblx0UHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ3RhZycsIHtcblx0XHQnc3R5bGUnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKDxzdHlsZVtcXHdcXFddKj8+KVtcXHdcXFddKj8oPz08XFwvc3R5bGU+KS9pLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmNzcyxcblx0XHRcdGFsaWFzOiAnbGFuZ3VhZ2UtY3NzJ1xuXHRcdH1cblx0fSk7XG5cdFxuXHRQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdpbnNpZGUnLCAnYXR0ci12YWx1ZScsIHtcblx0XHQnc3R5bGUtYXR0cic6IHtcblx0XHRcdHBhdHRlcm46IC9cXHMqc3R5bGU9KFwifCcpLio/XFwxL2ksXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J2F0dHItbmFtZSc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvXlxccypzdHlsZS9pLFxuXHRcdFx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9eXFxzKj1cXHMqWydcIl18WydcIl1cXHMqJC8sXG5cdFx0XHRcdCdhdHRyLXZhbHVlJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC8uKy9pLFxuXHRcdFx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmNzc1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YWxpYXM6ICdsYW5ndWFnZS1jc3MnXG5cdFx0fVxuXHR9LCBQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZyk7XG59XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY2xpa2UuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmNsaWtlID0ge1xuXHQnY29tbWVudCc6IFtcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXCpbXFx3XFxXXSo/XFwqXFwvLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXlxcXFw6XSlcXC9cXC8uKi8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fVxuXHRdLFxuXHQnc3RyaW5nJzoge1xuXHRcdHBhdHRlcm46IC8oW1wiJ10pKFxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQnY2xhc3MtbmFtZSc6IHtcblx0XHRwYXR0ZXJuOiAvKCg/OlxcYig/OmNsYXNzfGludGVyZmFjZXxleHRlbmRzfGltcGxlbWVudHN8dHJhaXR8aW5zdGFuY2VvZnxuZXcpXFxzKyl8KD86Y2F0Y2hcXHMrXFwoKSlbYS16MC05X1xcLlxcXFxdKy9pLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHRwdW5jdHVhdGlvbjogLyhcXC58XFxcXCkvXG5cdFx0fVxuXHR9LFxuXHQna2V5d29yZCc6IC9cXGIoaWZ8ZWxzZXx3aGlsZXxkb3xmb3J8cmV0dXJufGlufGluc3RhbmNlb2Z8ZnVuY3Rpb258bmV3fHRyeXx0aHJvd3xjYXRjaHxmaW5hbGx5fG51bGx8YnJlYWt8Y29udGludWUpXFxiLyxcblx0J2Jvb2xlYW4nOiAvXFxiKHRydWV8ZmFsc2UpXFxiLyxcblx0J2Z1bmN0aW9uJzogL1thLXowLTlfXSsoPz1cXCgpL2ksXG5cdCdudW1iZXInOiAvXFxiLT8oPzoweFtcXGRhLWZdK3xcXGQqXFwuP1xcZCsoPzplWystXT9cXGQrKT8pXFxiL2ksXG5cdCdvcGVyYXRvcic6IC8tLT98XFwrXFwrP3whPT89P3w8PT98Pj0/fD09Pz0/fCYmP3xcXHxcXHw/fFxcP3xcXCp8XFwvfH58XFxefCUvLFxuXHQncHVuY3R1YXRpb24nOiAvW3t9W1xcXTsoKSwuOl0vXG59O1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tamF2YXNjcmlwdC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuXHQna2V5d29yZCc6IC9cXGIoYXN8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseXxmb3J8ZnJvbXxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvLFxuXHQnbnVtYmVyJzogL1xcYi0/KDB4W1xcZEEtRmEtZl0rfDBiWzAxXSt8MG9bMC03XSt8XFxkKlxcLj9cXGQrKFtFZV1bKy1dP1xcZCspP3xOYU58SW5maW5pdHkpXFxiLyxcblx0Ly8gQWxsb3cgZm9yIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycyAoU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMDg0NDQpXG5cdCdmdW5jdGlvbic6IC9bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKig/PVxcKCkvaSxcblx0J29wZXJhdG9yJzogLy0tP3xcXCtcXCs/fCE9Pz0/fDw9P3w+PT98PT0/PT98JiY/fFxcfFxcfD98XFw/fFxcKlxcKj98XFwvfH58XFxefCV8XFwuezN9L1xufSk7XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAna2V5d29yZCcsIHtcblx0J3JlZ2V4Jzoge1xuXHRcdHBhdHRlcm46IC8oXnxbXi9dKVxcLyg/IVxcLykoXFxbLis/XXxcXFxcLnxbXi9cXFxcXFxyXFxuXSkrXFwvW2dpbXl1XXswLDV9KD89XFxzKigkfFtcXHJcXG4sLjt9KV0pKS8sXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRncmVlZHk6IHRydWVcblx0fVxufSk7XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnc3RyaW5nJywge1xuXHQndGVtcGxhdGUtc3RyaW5nJzoge1xuXHRcdHBhdHRlcm46IC9gKD86XFxcXFxcXFx8XFxcXD9bXlxcXFxdKSo/YC8sXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J2ludGVycG9sYXRpb24nOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9cXCRcXHtbXn1dK1xcfS8sXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJzoge1xuXHRcdFx0XHRcdFx0cGF0dGVybjogL15cXCRcXHt8XFx9JC8sXG5cdFx0XHRcdFx0XHRhbGlhczogJ3B1bmN0dWF0aW9uJ1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVzdDogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdzdHJpbmcnOiAvW1xcc1xcU10rL1xuXHRcdH1cblx0fVxufSk7XG5cbmlmIChQcmlzbS5sYW5ndWFnZXMubWFya3VwKSB7XG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICd0YWcnLCB7XG5cdFx0J3NjcmlwdCc6IHtcblx0XHRcdHBhdHRlcm46IC8oPHNjcmlwdFtcXHdcXFddKj8+KVtcXHdcXFddKj8oPz08XFwvc2NyaXB0PikvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0LFxuXHRcdFx0YWxpYXM6ICdsYW5ndWFnZS1qYXZhc2NyaXB0J1xuXHRcdH1cblx0fSk7XG59XG5cblByaXNtLmxhbmd1YWdlcy5qcyA9IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0O1xuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWZpbGUtaGlnaGxpZ2h0LmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgfHwgIXNlbGYuUHJpc20gfHwgIXNlbGYuZG9jdW1lbnQgfHwgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRzZWxmLlByaXNtLmZpbGVIaWdobGlnaHQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBFeHRlbnNpb25zID0ge1xuXHRcdFx0J2pzJzogJ2phdmFzY3JpcHQnLFxuXHRcdFx0J3B5JzogJ3B5dGhvbicsXG5cdFx0XHQncmInOiAncnVieScsXG5cdFx0XHQncHMxJzogJ3Bvd2Vyc2hlbGwnLFxuXHRcdFx0J3BzbTEnOiAncG93ZXJzaGVsbCcsXG5cdFx0XHQnc2gnOiAnYmFzaCcsXG5cdFx0XHQnYmF0JzogJ2JhdGNoJyxcblx0XHRcdCdoJzogJ2MnLFxuXHRcdFx0J3RleCc6ICdsYXRleCdcblx0XHR9O1xuXG5cdFx0aWYoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHsgLy8gQ2hlY2sgdG8gcHJldmVudCBlcnJvciBpbiBJRThcblx0XHRcdEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3ByZVtkYXRhLXNyY10nKSkuZm9yRWFjaChmdW5jdGlvbiAocHJlKSB7XG5cdFx0XHRcdHZhciBzcmMgPSBwcmUuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpO1xuXG5cdFx0XHRcdHZhciBsYW5ndWFnZSwgcGFyZW50ID0gcHJlO1xuXHRcdFx0XHR2YXIgbGFuZyA9IC9cXGJsYW5nKD86dWFnZSk/LSg/IVxcKikoXFx3KylcXGIvaTtcblx0XHRcdFx0d2hpbGUgKHBhcmVudCAmJiAhbGFuZy50ZXN0KHBhcmVudC5jbGFzc05hbWUpKSB7XG5cdFx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRcdFx0bGFuZ3VhZ2UgPSAocHJlLmNsYXNzTmFtZS5tYXRjaChsYW5nKSB8fCBbLCAnJ10pWzFdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFsYW5ndWFnZSkge1xuXHRcdFx0XHRcdHZhciBleHRlbnNpb24gPSAoc3JjLm1hdGNoKC9cXC4oXFx3KykkLykgfHwgWywgJyddKVsxXTtcblx0XHRcdFx0XHRsYW5ndWFnZSA9IEV4dGVuc2lvbnNbZXh0ZW5zaW9uXSB8fCBleHRlbnNpb247XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgY29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvZGUnKTtcblx0XHRcdFx0Y29kZS5jbGFzc05hbWUgPSAnbGFuZ3VhZ2UtJyArIGxhbmd1YWdlO1xuXG5cdFx0XHRcdHByZS50ZXh0Q29udGVudCA9ICcnO1xuXG5cdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSAnTG9hZGluZ+KApic7XG5cblx0XHRcdFx0cHJlLmFwcGVuZENoaWxkKGNvZGUpO1xuXG5cdFx0XHRcdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHRcdFx0XHR4aHIub3BlbignR0VUJywgc3JjLCB0cnVlKTtcblxuXHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XG5cblx0XHRcdFx0XHRcdGlmICh4aHIuc3RhdHVzIDwgNDAwICYmIHhoci5yZXNwb25zZVRleHQpIHtcblx0XHRcdFx0XHRcdFx0Y29kZS50ZXh0Q29udGVudCA9IHhoci5yZXNwb25zZVRleHQ7XG5cblx0XHRcdFx0XHRcdFx0UHJpc20uaGlnaGxpZ2h0RWxlbWVudChjb2RlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKHhoci5zdGF0dXMgPj0gNDAwKSB7XG5cdFx0XHRcdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSAn4pyWIEVycm9yICcgKyB4aHIuc3RhdHVzICsgJyB3aGlsZSBmZXRjaGluZyBmaWxlOiAnICsgeGhyLnN0YXR1c1RleHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29kZS50ZXh0Q29udGVudCA9ICfinJYgRXJyb3I6IEZpbGUgZG9lcyBub3QgZXhpc3Qgb3IgaXMgZW1wdHknO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR4aHIuc2VuZChudWxsKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHR9O1xuXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBzZWxmLlByaXNtLmZpbGVIaWdobGlnaHQpO1xuXG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaXNtanMvcHJpc20uanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3ByaXNtLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJpc20uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9wcmlzbS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmlzbWpzL3RoZW1lcy9wcmlzbS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGRlZmF1bHQge1xuXG4gIC8qKlxuICAgKiBkZWZhdWx0IHNjYWxlIHRoYXQgd2lsbCBiZSBzZXQgb24gZWxlbWVudFxuICAgKiBAbWF4UGluY2gge051bWJlcn1cbiAgICovXG4gIGJhc2VTY2FsZTogMSxcblxuICAvKipcbiAgICogbWF4IHNjYWxlIGEgbm9kZSBjYW4gcmVhY2hcbiAgICogQG1heFBpbmNoIHtOdW1iZXJ9XG4gICAqL1xuICBtYXhTY2FsZTogMyxcblxuICAvKipcbiAgICogbWF4IHNjYWxlIGEgbm9kZSBjYW4gcmVhY2ggYmVmb3JlIGJvdW5jaW5nIGJhY2sgdG8gbWF4U2NhbGVcbiAgICogQG1heFNjYWxlVGltZXMge051bWJlcn1cbiAgICovXG4gIG1heFNjYWxlVGltZXM6IDQsXG5cbiAgLyoqXG4gICAqIG1pbiBzY2FsZSBhIG5vZGUgY2FuIHJlYWNoXG4gICAqIEBtaW5QaW5jaCB7TnVtYmVyfVxuICAgKi9cbiAgbWluU2NhbGU6IDEsXG5cbiAgLyoqXG4gICAqIG1pbiBzY2FsZSBhIG5vZGUgY2FuIHJlYWNoIGJlZm9yZSBib3VuY2luZyBiYWNrIHRvIG1pblNjYWxlXG4gICAqIEBtaW5TY2FsZVRpbWVzIHtOdW1iZXJ9XG4gICAqL1xuICBtaW5TY2FsZVRpbWVzOiAwLjgsXG5cbiAgLyoqXG4gICAqIHRpbWUgZm9yIHRoZSBzbmFwQmFjayBvZiB0aGUgcGluY2ggaWYgdGhlIG5vZGUgaGFzIHJlYWNoIGFib3ZlXG4gICAqIG9yIGJlbG93IGl0cyBwaW5jaCB2YWx1ZVxuICAgKiBAc25hcEJhY2tTcGVlZCB7TnVtYmVyfVxuICAgKi9cbiAgc25hcEJhY2tTcGVlZDogMjAwLFxuXG4gIC8qKlxuICAgKiBCYXNpYyBlYXNpbmcgZnVuY3Rpb25zOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kZS9kb2NzL1dlYi9DU1MvdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cbiAgICogY3ViaWMgYmV6aWVyIGVhc2luZyBmdW5jdGlvbnM6IGh0dHA6Ly9lYXNpbmdzLm5ldC9kZVxuICAgKiBAZWFzZSB7U3RyaW5nfVxuICAgKi9cbiAgZWFzZTogJ2Vhc2UnLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kZWZhdWx0cy5qcyIsIi8vIEBmbG93XG4vL1xuaW1wb3J0IGV2ZW50RGlzcGF0Y2hlciBmcm9tICcuL3V0aWxzL2Rpc3BhdGNoLWV2ZW50JztcbmltcG9ydCB7IGNhbmNlbEV2ZW50LCBnZXRUb3VjaGVzLCBkZXRlY3REb3VibGVUYXAsIGNhbGNTY2FsZSB9IGZyb20gJy4vdXRpbHMvaGFuZGxlLWV2ZW50JztcbmltcG9ydCBzY2FsZUVsZW1lbnQgZnJvbSAnLi91dGlscy9oYW5kbGUtZWxlbWVudCc7XG5pbXBvcnQgeyBpc1dpdGhpbiwgY2FsY05ld1NjYWxlLCBhZGRPZmZzZXQsIGdldEluaXRpYWxTY2FsZSwgZ2V0U2NhbGVGYWN0b3IsIGdldFpvb21GYWN0b3IsIGdldFRvdWNoQ2VudGVyIH0gZnJvbSAnLi91dGlscy9oYW5kbGUtcGluY2gnO1xuaW1wb3J0IHsgZHJhZywgc2FuaXRpemVPZmZzZXQgfSBmcm9tICcuL3V0aWxzL2hhbmRsZS1kcmFnJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRzJztcblxuY29uc3QgZmlyc3QgPSAoaXRlbXM6IEFycmF5PE9iamVjdD4pID0+IGl0ZW1zWzBdO1xuXG5jb25zdCBzZXRUYXJnZXQgPSAoZWwsIG9wdHMpID0+IChcbiAgZWwucXVlcnlTZWxlY3RvcihvcHRzLnRhcmdldCA/IGBpbWcke29wdHMudGFyZ2V0fWAgOiAnaW1nJylcbik7XG5cbmNvbnN0IHBpbmNoSXQgPSAodGFyZ2V0czogc3RyaW5nIHwgT2JqZWN0LCBvcHRpb25zOiBPYmplY3QgPSB7fSkgPT4ge1xuICAvLyBwcml2YXRlIHZhcmlhYmxlIGNhY2hlXG4gIGxldCBlbGVtZW50ID0gbnVsbDtcblxuICBsZXQgc2NhbGluZztcbiAgbGV0IGxhc3RTY2FsZSA9IDE7XG4gIGxldCBzdGFydFRvdWNoZXM7XG5cbiAgbGV0IHpvb21GYWN0b3IgPSAxO1xuXG4gIGxldCBvZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgbGV0IGxhc3Rab29tQ2VudGVyID0gZmFsc2U7XG4gIGxldCBsYXN0RHJhZ1Bvc2l0aW9uID0gZmFsc2U7XG5cbiAgLy8gQmFzZSBjb25maWd1cmF0aW9uIGZvciB0aGUgcGluY2ggaW5zdGFuY2VcbiAgY29uc3Qgb3B0cyA9IHsuLi5kZWZhdWx0cywgLi4ub3B0aW9uc307XG4gIGNvbnN0IHsgb24sIGRpc3BhdGNoIH0gPSBldmVudERpc3BhdGNoZXIoKTtcblxuIC8qKlxuICAqICBkaXNwYXRjaFBpbmNoRXZlbnQgLSBTaG9ydGhhbmQgbWV0aG9kIGZvciBjcmVhdGluZyBldmVudHNcbiAgKlxuICAqICBAcGFyYW0geyBTdHJpbmcgfSBwaGFzZVxuICAqICBAcGFyYW0geyBTdHJpbmcgfSB0eXBlXG4gICogIEBwYXJhbSB7IE9iamVjdCB9IGRldGFpbHNcbiAgKiAgQHJldHVybiB7IFZvaWQgfVxuICAqKi9cbiAgY29uc3QgZGlzcGF0Y2hQaW5jaEV2ZW50ID0gKGV2ZW50TmFtZTogc3RyaW5nLCBwaGFzZTogc3RyaW5nLCBkYXRhOiBPYmplY3QgPSB7fSk6IHZvaWQgPT4ge1xuICAgIGRpc3BhdGNoKGV2ZW50TmFtZSwgT2JqZWN0LmFzc2lnbihkYXRhLCB7XG4gICAgICBwaGFzZVxuICAgIH0pKTtcbiAgfTtcblxuICBjb25zdCByZXNldEdsb2JhbHMgPSAoLyogb3B0cyAqLyk6IHZvaWQgPT4ge1xuICAgIHNjYWxpbmcgPSB1bmRlZmluZWQ7XG4gICAgbGFzdFNjYWxlID0gMTtcbiAgICBzdGFydFRvdWNoZXMgPSBudWxsO1xuICAgIHpvb21GYWN0b3IgPSAxO1xuICAgIGxhc3Rab29tQ2VudGVyID0gZmFsc2U7XG5cbiAgICBsYXN0RHJhZ1Bvc2l0aW9uID0gZmFsc2U7XG4gICAgb2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gIH07XG5cbiAgLy8gZXZlbnQgaGFuZGxpbmdcbiAgLyoqXG4gICAqIFNldCBzY2FsaW5nIGlmIHdlIGFyZSB1c2luZyBtb3JlIHRoZW4gb25lIGZpbmdlclxuICAgKiBhbmQgY2FwdHVyZXMgb3VyIGZpcnN0IHB1bmNoIHBvaW50XG4gICAqXG4gICAqIHByaXZhdGVcbiAgICogQHBhcmFtIHsgT2JqZWN0IH0gZSB0aGUgZXZlbnQgZnJvbSBvdXIgZXZlbnRsaXN0ZW5lclxuICAgKi9cbiAgY29uc3Qgb25Ub3VjaHN0YXJ0ID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ3RvdWNoc3RhcnQnLCAnYmVmb3JlJywgZSk7XG5cblxuICAgIHNjYWxpbmcgPSAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMik7XG4gICAgc3RhcnRUb3VjaGVzID0gQXJyYXkuZnJvbShlLnRvdWNoZXMpO1xuICAgIGxhc3RTY2FsZSA9IDE7XG5cbiAgICBpZiAoZGV0ZWN0RG91YmxlVGFwKGUpKSB7XG4gICAgICBjb25zdCBpbWFnZSA9IGUuY3VycmVudFRhcmdldC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgICAgIHNjYWxlRWxlbWVudChlLnRhcmdldCwgaW1hZ2UsIDEsIHsgeDogMCwgeTogMCB9LCBvcHRzLnNuYXBCYWNrU3BlZWQsIG9wdHMuZWFzZSk7XG4gICAgICByZXNldEdsb2JhbHMoKTtcbiAgICB9XG5cbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ3RvdWNoc3RhcnQnLCAnYWZ0ZXInLCBlKTtcbiAgfTtcblxuICBjb25zdCBvblRvdWNobW92ZSA9IChlOiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCd0b3VjaG1vdmUnLCAnYmVmb3JlJywgZSk7XG5cbiAgICBpZiAoKCFzY2FsaW5nIHx8ICFzdGFydFRvdWNoZXMpICYmIHpvb21GYWN0b3IgPiAxKSB7XG4gICAgICBjYW5jZWxFdmVudChlKTtcblxuICAgICAgY29uc3QgdG91Y2ggPSBmaXJzdChnZXRUb3VjaGVzKGUuY3VycmVudFRhcmdldCwgQXJyYXkuZnJvbShlLnRvdWNoZXMpKSk7XG4gICAgICBjb25zdCBkcmFnT2Zmc2V0ID0gZHJhZyh0b3VjaCwgbGFzdERyYWdQb3NpdGlvbiwgb2Zmc2V0LCB6b29tRmFjdG9yKTtcblxuICAgICAgb2Zmc2V0ID0gc2FuaXRpemVPZmZzZXQoZS50YXJnZXQsIGRyYWdPZmZzZXQsIHpvb21GYWN0b3IpO1xuICAgICAgbGFzdERyYWdQb3NpdGlvbiA9IHRvdWNoO1xuICAgIH0gZWxzZSBpZiAoc2NhbGluZyAmJiBzdGFydFRvdWNoZXMpIHtcbiAgICAgIGNhbmNlbEV2ZW50KGUpO1xuXG4gICAgICAvLyBhIHJlbGF0aXZlIHNjYWxlIGZhY3RvciBpcyB1c2VkXG4gICAgICBjb25zdCB0b3VjaENlbnRlciA9IGdldFRvdWNoQ2VudGVyKGdldFRvdWNoZXMoZS5jdXJyZW50VGFyZ2V0LCBBcnJheS5mcm9tKGUudG91Y2hlcykpKTtcbiAgICAgIGNvbnN0IG5ld1NjYWxlID0gY2FsY1NjYWxlKGUuY3VycmVudFRhcmdldCwgc3RhcnRUb3VjaGVzLCBBcnJheS5mcm9tKGUudG91Y2hlcykpO1xuICAgICAgY29uc3Qgc2NhbGVWYWx1ZSA9IGNhbGNOZXdTY2FsZShuZXdTY2FsZSwgbGFzdFNjYWxlKTtcblxuICAgICAgY29uc3Qgc2NhbGUgPSBnZXRTY2FsZUZhY3RvcihzY2FsZVZhbHVlLCB6b29tRmFjdG9yLCBvcHRzKTtcbiAgICAgIHpvb21GYWN0b3IgPSBnZXRab29tRmFjdG9yKHNjYWxlVmFsdWUsIHpvb21GYWN0b3IsIG9wdHMpO1xuXG4gICAgICBvZmZzZXQgPSBhZGRPZmZzZXQob2Zmc2V0LCB7XG4gICAgICAgIHg6IChzY2FsZSAtIDEpICogKHRvdWNoQ2VudGVyLnggKyBvZmZzZXQueCksXG4gICAgICAgIHk6IChzY2FsZSAtIDEpICogKHRvdWNoQ2VudGVyLnkgKyBvZmZzZXQueSlcbiAgICAgIH0pO1xuXG4gICAgICBsYXN0U2NhbGUgPSBuZXdTY2FsZTtcbiAgICAgIG9mZnNldCA9IGRyYWcodG91Y2hDZW50ZXIsIGxhc3Rab29tQ2VudGVyLCBvZmZzZXQsIHpvb21GYWN0b3IpO1xuICAgICAgbGFzdFpvb21DZW50ZXIgPSB0b3VjaENlbnRlcjtcbiAgICB9XG5cbiAgICBjb25zdCBpbWFnZSA9IGUuY3VycmVudFRhcmdldC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgICBzY2FsZUVsZW1lbnQoZS50YXJnZXQsIGltYWdlLCB6b29tRmFjdG9yLCBvZmZzZXQsIDAsIG9wdHMuZWFzZSk7XG5cbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ3RvdWNobW92ZScsICdhZnRlcicsIGUpO1xuICB9O1xuXG4gIGNvbnN0IG9uVG91Y2hlbmQgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGRpc3BhdGNoUGluY2hFdmVudCgndG91Y2hlbmQnLCAnYmVmb3JlJywgZSk7XG5cbiAgICBsYXN0RHJhZ1Bvc2l0aW9uID0gZmFsc2U7XG4gICAgbGFzdFpvb21DZW50ZXIgPSBmYWxzZTtcbiAgICBsYXN0U2NhbGUgPSAxO1xuICAgIGlmICh6b29tRmFjdG9yKSB7XG4gICAgICBpZiAoIWlzV2l0aGluKHpvb21GYWN0b3IsIG9wdHMpKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gZS5jdXJyZW50VGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICAgICAgICBjb25zdCBpc0xlc3NUaGFuID0gKGdldEluaXRpYWxTY2FsZShlLnRhcmdldCwgaW1hZ2UpICogem9vbUZhY3RvciA8IG9wdHMubWluU2NhbGUpO1xuICAgICAgICB6b29tRmFjdG9yID0gaXNMZXNzVGhhbiA/IG9wdHMubWluU2NhbGUgOiBvcHRzLm1heFNjYWxlO1xuICAgICAgICBvZmZzZXQgPSBzYW5pdGl6ZU9mZnNldChlLnRhcmdldCwgb2Zmc2V0LCB6b29tRmFjdG9yKTtcbiAgICAgICAgc2NhbGVFbGVtZW50KGUudGFyZ2V0LCBpbWFnZSwgem9vbUZhY3Rvciwgb2Zmc2V0LCBvcHRzLnNuYXBCYWNrU3BlZWQsIG9wdHMuZWFzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCd0b3VjaGVuZCcsICdhZnRlcicsIGUpO1xuICB9O1xuXG4gIGNvbnN0IGF0dGFjaEV2ZW50cyA9IChlbDogSFRNTEVsZW1lbnQpID0+IHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaHN0YXJ0KTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNobW92ZSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoZW5kKTtcbiAgfTtcblxuICBjb25zdCBkZXRhY2hoRXZlbnRzID0gKGVsOiBPYmplY3QpID0+IHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0Jywgb25Ub3VjaHN0YXJ0KTtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNobW92ZSk7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoZW5kKTtcbiAgfTtcblxuICAvKipcbiAgICogcHVibGljXG4gICAqIHJlc2V0IGZ1bmN0aW9uOlxuICAgKiBAcGFyYW0geyBOdW1iZXIgfSBkdXJhdGlvblxuICAgKiBAcGFyYW0geyBTdHJpbmcgfSBlYXNpbmdcbiAgICogQHJldHVybiB7IFZvaWQgfVxuICAgKi9cbiAgY29uc3QgcmVzZXQgPSAob3B0OiBPYmplY3QgPSB7fSk6IHZvaWQgPT4ge1xuICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xuICAgIGNvbnN0IGltYWdlID0gc2V0VGFyZ2V0KGVsZW1lbnQsIG9wdHMpO1xuICAgIGlmICghaW1hZ2UpIHJldHVybjtcbiAgICBjb25zdCB7IHNuYXBCYWNrU3BlZWQsIGVhc2luZyB9ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cywgb3B0KTtcbiAgICBzY2FsZUVsZW1lbnQoZWxlbWVudCwgaW1hZ2UsIDEsIHsgeDogMCwgeTogMCB9LCBzbmFwQmFja1NwZWVkLCBlYXNpbmcpO1xuICAgIHJlc2V0R2xvYmFscygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBwdWJsaWNcbiAgICogZGVzdHJveSBmdW5jdGlvbjogY2FsbGVkIHRvIGdyYWNlZnVsbHkgZGVzdHJveSB0aGUgbG9yeSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHsgVm9pZCB9XG4gICAqL1xuICBjb25zdCBkZXN0cm95ID0gKG9wdDogT2JqZWN0ID0ge30pOiB2b2lkID0+IHtcbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ2Rlc3Ryb3knLCAnYmVmb3JlJywge30pO1xuICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xuICAgIHJlc2V0KG9wdCk7XG4gICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgIGRldGFjaGhFdmVudHMoZWxlbWVudCk7XG4gICAgZWxlbWVudCA9IG51bGw7XG4gICAgcmVzZXRHbG9iYWxzKCk7XG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCdkZXN0cm95JywgJ2FmdGVyJywge30pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBzZXR1cCAtIEluaXQgZnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHsgU3RyaW5nLCBPYmplY3QgfVxuICAgKiBAcmV0dXJuIHsgVm9pZCB9XG4gICAqKi9cbiAgY29uc3Qgc2V0dXAgPSAodGFyZ2V0OiBzdHJpbmcgfCBPYmplY3QpOiB2b2lkID0+IHtcbiAgICBpZiAoZWxlbWVudCkgZGVzdHJveSgpO1xuICAgIGRpc3BhdGNoUGluY2hFdmVudCgnaW5pdCcsICdiZWZvcmUnLCB7fSk7XG4gICAgLy8gcmVzb2x2ZSB0YXJnZXRcbiAgICAvLyBwaW5jaGl0IGFsbG93cyBmb3IgYm90aCBhIG5vZGUgb3IgYSBzdHJpbmcgdG8gYmUgcGFzc2VkXG4gICAgc3dpdGNoICh0eXBlb2YgdGFyZ2V0KSB7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBlbGVtZW50ID0gdGFyZ2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgICAgIGNvbnNvbGUud2FybignbWlzc2luZyB0YXJnZXQsIGVpdGhlciBwYXNzIGFuIG5vZGUgb3IgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgYXR0YWNoRXZlbnRzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGRpc3BhdGNoUGluY2hFdmVudCgnaW5pdCcsICdhZnRlcicsIHt9KTtcbiAgfTtcblxuICAvLyB0cmlnZ2VyIGluaXRpYWwgc2V0dXBcbiAgc2V0dXAodGFyZ2V0cyk7XG5cbiAgcmV0dXJuIHtcbiAgICBzZXR1cCxcbiAgICByZXNldCxcbiAgICBkZXN0cm95LFxuICAgIGVsZW1lbnQsXG4gICAgb24sXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwaW5jaEl0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BpbmNoLWl0LmpzIiwiLyoqXG4gKiBEZXRlY3RpbmcgcHJlZml4ZXMgZm9yIHNhdmluZyB0aW1lIGFuZCBieXRlc1xuICovXG5leHBvcnQgZGVmYXVsdCAoKSA9PiB7XG4gIGxldCB0cmFuc2Zvcm07XG4gIGxldCB0cmFuc2l0aW9uO1xuICBsZXQgdHJhbnNpdGlvbkVuZDtcbiAgbGV0IGhhc1NjYWxlM2Q7XG5cbiAgKCgpID0+IHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ18nKTtcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuXG4gICAgaWYgKHN0eWxlLndlYmtpdFRyYW5zaXRpb24gPT09ICcnKSB7XG4gICAgICB0cmFuc2l0aW9uRW5kID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICAgICAgdHJhbnNpdGlvbiA9ICd3ZWJraXRUcmFuc2l0aW9uJztcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUudHJhbnNpdGlvbiA9PT0gJycpIHtcbiAgICAgIHRyYW5zaXRpb25FbmQgPSAndHJhbnNpdGlvbmVuZCc7XG4gICAgICB0cmFuc2l0aW9uID0gJ3RyYW5zaXRpb24nO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPT09ICcnKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAnd2Via2l0VHJhbnNmb3JtJztcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUubXNUcmFuc2Zvcm0gPT09ICcnKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAnbXNUcmFuc2Zvcm0nO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS50cmFuc2Zvcm0gPT09ICcnKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAndHJhbnNmb3JtJztcbiAgICB9XG5cbiAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShlbCwgbnVsbCk7XG4gICAgc3R5bGVbdHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSc7XG4gICAgaGFzU2NhbGUzZCA9ICEhZ2xvYmFsLmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUodHJhbnNmb3JtKTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgfSkoKTtcblxuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybSxcbiAgICB0cmFuc2l0aW9uLFxuICAgIHRyYW5zaXRpb25FbmQsXG4gICAgaGFzU2NhbGUzZFxuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9kZXRlY3QtcHJlZml4ZXMuanMiLCIvLyBAZmxvd1xuXG4vKipcbiAqIGRpc3BhdGNoIGN1c3RvbSBldmVudHNcbiAqL1xuXG5jb25zdCBldmVudERpc3BhdGNoZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGV2ZW50cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGhhbmRsZXIgZm9yIGV2ZW50LCB0byBiZSBmaXJlZFxuICAgKiBmb3IgZXZlcnkgZXZlbnQuXG4gICAqL1xuICBjb25zdCBvbiA9IChldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogRnVuY3Rpb24pID0+IHtcbiAgICBldmVudHNbZXZlbnROYW1lXSA9IGV2ZW50c1tldmVudE5hbWVdIHx8IFtdO1xuICAgIGV2ZW50c1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBoYW5kbGVyIGZvciBldmVudC5cbiAgICovXG4gIGNvbnN0IG9mZiA9IChldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogRnVuY3Rpb24pID0+IHtcbiAgICBpZiAoZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzW2V2ZW50TmFtZV0ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGV2ZW50c1tldmVudE5hbWVdW2ldID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGRpc3BhdGNoID0gKGV2ZW50TmFtZTogc3RyaW5nLCBkYXRhOiBPYmplY3QpID0+IHtcbiAgICBpZiAoZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIGV2ZW50c1tldmVudE5hbWVdLmZvckVhY2goKGZuKSA9PiB7XG4gICAgICAgIGZuKGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgb24sXG4gICAgb2ZmLFxuICAgIGRpc3BhdGNoLFxuICB9O1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBldmVudERpc3BhdGNoZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvZGlzcGF0Y2gtZXZlbnQuanMiLCIvLyBAZmxvd1xuXG5pbXBvcnQgeyBnZXRYLCBnZXRZLCBhZGRPZmZzZXQgfSBmcm9tICcuL2hhbmRsZS1waW5jaCc7XG5cbnR5cGUgQ2VudGVyID0ge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbn07XG5cbmNvbnN0IGNhbGNNYXggPSAoZWw6IEV2ZW50VGFyZ2V0LCBkaWZmZXI6IG51bWJlciwgem9vbUZhY3RvcjogbnVtYmVyKTogT2JqZWN0ID0+ICh7XG4gIG1heFg6ICh6b29tRmFjdG9yIC0gZGlmZmVyKSAqIGdldFgoZWwpLFxuICBtYXhZOiAoem9vbUZhY3RvciAtIGRpZmZlcikgKiBnZXRZKGVsKSxcbn0pO1xuXG5leHBvcnQgY29uc3Qgc2FuaXRpemVPZmZzZXQgPSAoZWw6IEV2ZW50VGFyZ2V0LCBvZmZzZXQ6IENlbnRlciwgem9vbUZhY3RvcjogbnVtYmVyKTogT2JqZWN0ID0+IHtcbiAgY29uc3QgeyBtYXhYLCBtYXhZIH0gPSBjYWxjTWF4KGVsLCAxLCB6b29tRmFjdG9yKTtcbiAgY29uc3QgbWF4T2Zmc2V0WCA9IE1hdGgubWF4KG1heFgsIDApO1xuICBjb25zdCBtYXhPZmZzZXRZID0gTWF0aC5tYXgobWF4WSwgMCk7XG4gIGNvbnN0IG1pbk9mZnNldFggPSBNYXRoLm1pbihtYXhYLCAwKTtcbiAgY29uc3QgbWluT2Zmc2V0WSA9IE1hdGgubWluKG1heFksIDApO1xuXG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5taW4oTWF0aC5tYXgob2Zmc2V0LngsIG1pbk9mZnNldFgpLCBtYXhPZmZzZXRYKSxcbiAgICB5OiBNYXRoLm1pbihNYXRoLm1heChvZmZzZXQueSwgbWluT2Zmc2V0WSksIG1heE9mZnNldFkpXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZHJhZyA9IChjZW50ZXI6IENlbnRlciwgbGFzdENlbnRlcjogQ2VudGVyLCBsYXN0T2Zmc2V0OiBPYmplY3QsIHpvb21GYWN0b3I6IG51bWJlcik6IE9iamVjdCA9PiAoXG4gIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGFzdENlbnRlciwgJ3gnKSlcbiAgPyBhZGRPZmZzZXQobGFzdE9mZnNldCwge1xuICAgIHg6IC0oKChjZW50ZXIueCAtIGxhc3RDZW50ZXIueCkgKiB6b29tRmFjdG9yKSAvIHpvb21GYWN0b3IpLFxuICAgIHk6IC0oKChjZW50ZXIueSAtIGxhc3RDZW50ZXIueSkgKiB6b29tRmFjdG9yKSAvIHpvb21GYWN0b3IpLFxuICB9KVxuICA6IGxhc3RPZmZzZXRcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvaGFuZGxlLWRyYWcuanMiLCIvLyBAZmxvd1xuXG5pbXBvcnQgZGV0ZWN0UHJlZml4ZXMgZnJvbSAnLi9kZXRlY3QtcHJlZml4ZXMnO1xuaW1wb3J0IHsgZ2V0SW5pdGlhbFNjYWxlIH0gZnJvbSAnLi9oYW5kbGUtcGluY2gnO1xuXG5jb25zdCBwcmVmaXhlcyA9IGRldGVjdFByZWZpeGVzKCk7XG5cbmNvbnN0IGhhbmRsZUFuaW1hdGlvbiA9IChlbDogSFRNTEVsZW1lbnQsIHRyYW5zaXRpb246IHN0cmluZywgZHVyYXRpb246IG51bWJlciwgZWFzZTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIGNvbnN0IHsgc3R5bGUgfSA9IGVsO1xuICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCUgMCUnO1xuICBzdHlsZVtgJHt0cmFuc2l0aW9ufVRpbWluZ0Z1bmN0aW9uYF0gPSBlYXNlO1xuICBzdHlsZVtgJHt0cmFuc2l0aW9ufUR1cmF0aW9uYF0gPSBgJHtkdXJhdGlvbn1tc2A7XG59O1xuXG4vKipcbiAqIHNjYWxlRWxlbWVudCAtdHJhbnNkb3JtcyB0byBhIGdpdmVuIHBvc2l0aW9uIGluIGEgZ2l2ZW4gdGltZSBpbiBtaWxsaXNlY29uZHNcbiAqXG4gKiBAcGFyYW0geyBPYmplY3QgfSBlbCBlbGVtZW50IGZyb20gdGhlIGV2ZW50c1xuICogQHBhcmFtIHsgTnVtYmVyIH0gcGluY2ggbnVtYmVyIHdoZXJlIHRvIHNjYWxlIHRvXG4gKiBAcGFyYW0geyBPYmplY3QgfSBjb29yZHMgb2JqZWN0IHdoZXJlIHRvIHRyYW5zbGF0ZSB0b1xuICogQHBhcmFtIHsgTnVtYmVyIH0gZHVyYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2lzdGlvblxuICogQHBhcmFtIHsgU3RyaW5nIH0gZWFzZSBlYXNpbmcgY3NzIHByb3BlcnR5XG4gKiBAcmV0dXJuIHsgVm9pZCB9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgKGVsOiBIVE1MRWxlbWVudCwgaW1hZ2U6IEhUTUxFbGVtZW50LCBwaW5jaDogbnVtYmVyLCBjb29yZHM6IE9iamVjdCwgZHVyYXRpb246IG51bWJlciwgZWFzZTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIGNvbnN0IHsgdHJhbnNpdGlvbiwgdHJhbnNmb3JtLCBoYXNTY2FsZTNkIH0gPSBwcmVmaXhlcztcbiAgY29uc3QgeyBzdHlsZSB9ID0gaW1hZ2U7XG5cbiAgY29uc3Qgem9vbUZhY3RvciA9IGdldEluaXRpYWxTY2FsZShlbCwgaW1hZ2UpICogcGluY2g7XG5cbiAgY29uc3Qgb2Zmc2V0WCA9IC1jb29yZHMueDtcbiAgY29uc3Qgb2Zmc2V0WSA9IC1jb29yZHMueTtcblxuICBoYW5kbGVBbmltYXRpb24oaW1hZ2UsIHRyYW5zaXRpb24sIGR1cmF0aW9uLCBlYXNlKTtcbiAgY29uc3Qgc2NhbGVQcm9wID0gKGhhc1NjYWxlM2QpXG4gICAgPyBgc2NhbGUzZCgke3pvb21GYWN0b3J9LCAke3pvb21GYWN0b3J9LCAxKWBcbiAgICA6IGBzY2FsZSgke3pvb21GYWN0b3J9LCAke3pvb21GYWN0b3J9KWA7XG4gIGNvbnN0IHRyYW5zbGF0ZVByb3AgPSBgdHJhbnNsYXRlKCR7b2Zmc2V0WH1weCwgJHtvZmZzZXRZfXB4KWA7XG5cbiAgc3R5bGVbdHJhbnNmb3JtXSA9IGAke3RyYW5zbGF0ZVByb3B9ICR7c2NhbGVQcm9wfWA7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL2hhbmRsZS1lbGVtZW50LmpzIiwiLy8gQGZsb3dcbmxldCBsYXN0VG91Y2hTdGFydCA9IDA7XG5cbnR5cGUgVG9jaFBhZ2UgPSB7XG4gIHBhZ2VYOiBudW1iZXI7XG4gIHBhZ2VZOiBudW1iZXI7XG59XG5cbnR5cGUgVG91Y2ggPSB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBjYW5jZWxFdmVudCAtIENhbmNlbCBFdmVudHMgc28gd2UgZG9udCBidWJibGUgdXAgb3VyIGV2ZW50cyB0byB0aGUgZG9jdW1lbnRcbiAqXG4gKiBAcGFyYW0geyBPYmplY3QgfSBldmVudFxuICogQHJldHVybiB7IFZvaWQgfVxuICoqL1xuZXhwb3J0IGNvbnN0IGNhbmNlbEV2ZW50ID0gKGU6IEV2ZW50KTogdm9pZCA9PiB7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn07XG5cbi8qKlxuICogZGV0ZWN0RG91YmxlVGFwIC0gQ2hlY2sgaWYgd2UgYXJlIGRvdWJsZSB0YXBwaW5nXG4gKlxuICogQHBhcmFtIHsgT2JqZWN0IH0gZXZlbnRcbiAqIEByZXR1cm4geyBCb29sZWFuIH1cbiAqKi9cbmV4cG9ydCBjb25zdCBkZXRlY3REb3VibGVUYXAgPSAoZTogVG91Y2hFdmVudCk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCB0aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICBsYXN0VG91Y2hTdGFydCA9IDA7XG4gIH1cblxuICBpZiAodGltZSAtIGxhc3RUb3VjaFN0YXJ0IDwgMzAwKSB7XG4gICAgY2FuY2VsRXZlbnQoZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGxhc3RUb3VjaFN0YXJ0ID0gdGltZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHRvdWNoZXMgb2YgYW4gZXZlbnQgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBvZmZzZXRcbiAqXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEByZXR1cm4gYXJyYXkgdG91Y2hlc1xuICovXG5leHBvcnQgY29uc3QgZ2V0VG91Y2hlcyA9IChlbDogRXZlbnRUYXJnZXQsIHRvdWNoZXM6IEFycmF5PFRvY2hQYWdlPik6IEFycmF5PFRvdWNoPiA9PiB7XG4gIGNvbnN0IHBvc2l0aW9uID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB0b3VjaGVzLm1hcCh0b3VjaCA9PiAoe1xuICAgIHg6IHRvdWNoLnBhZ2VYIC0gKHBvc2l0aW9uLmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQpLFxuICAgIHk6IHRvdWNoLnBhZ2VZIC0gKHBvc2l0aW9uLnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKSxcbiAgfSkpO1xufTtcblxuLyoqXG4gKiBnZXREaXN0YW5jZSAtIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBvdXIgZmluZ2Vyc1xuICpcbiAqIEBwYXJhbSB7IEFycmF5IH0gdG91Y2hlcyB0b3VjaGVzIHBhc3NhcyBhbiBhcnJheSBmcm9tIFRvdWNoTGlzdFxuICogQHJldHVybiB7IE51bWJlciB9IHRoZSBjYWxjdWFsdGVkIGRpc3RhbmNlIGJldHdlZW4gdGhlIGZpbmdlcnNcbiAqKi9cbmV4cG9ydCBjb25zdCBnZXREaXN0YW5jZSA9ICh0b3VjaGVzOiBBcnJheTxUb3VjaD4pOiBudW1iZXIgPT4ge1xuICBjb25zdCBbZmlyc3QsIHNlY29uZF0gPSB0b3VjaGVzO1xuICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICgoZmlyc3QueCAtIHNlY29uZC54KSAqIChmaXJzdC54IC0gc2Vjb25kLngpKSArXG4gICAgKChmaXJzdC55IC0gc2Vjb25kLnkpICogKGZpcnN0LnkgLSBzZWNvbmQueSkpXG4gICk7XG59O1xuXG4vKipcbiAqIGNhbGNTY2FsZSAtIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB3aGVyZSB3ZSBzdGFydCBvdXIgcGluY2hcbiAqIHRvIHdoZXJlIHdlIGVuZCBpdFxuICpcbiAqIEBwYXJhbSB7IEFycmF5IH0gc3RhcnRUb3VjaCBUaGUgc3RhcnRpbmcgcG9pbnQgb2Ygb3VyIHRvdWNoXG4gKiBAcGFyYW0geyBBcnJheSB9IGVuZFRvdWNoIFRoZSBjdXJyZW50IHBvaW50IG9mIG91ciB0b3VjaFxuICogQHJldHVybiB7IE51bWJlciB9XG4gKi9cbmV4cG9ydCBjb25zdCBjYWxjU2NhbGUgPSAoZWw6IEV2ZW50VGFyZ2V0LCBzdGFydFRvdWNoOiBBcnJheTxPYmplY3Q+LCBlbmRUb3VjaDogQXJyYXk8T2JqZWN0Pik6IG51bWJlciA9PiAoXG4gIGdldERpc3RhbmNlKGdldFRvdWNoZXMoZWwsIGVuZFRvdWNoKSkgLyBnZXREaXN0YW5jZShnZXRUb3VjaGVzKGVsLCBzdGFydFRvdWNoKSlcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvaGFuZGxlLWV2ZW50LmpzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qKlxcbiAqIHByaXNtLmpzIGRlZmF1bHQgdGhlbWUgZm9yIEphdmFTY3JpcHQsIENTUyBhbmQgSFRNTFxcbiAqIEJhc2VkIG9uIGRhYmJsZXQgKGh0dHA6Ly9kYWJibGV0LmNvbSlcXG4gKiBAYXV0aG9yIExlYSBWZXJvdVxcbiAqL1xcblxcbmNvZGVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSxcXG5wcmVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSB7XFxuXFx0Y29sb3I6IGJsYWNrO1xcblxcdGJhY2tncm91bmQ6IG5vbmU7XFxuXFx0dGV4dC1zaGFkb3c6IDAgMXB4IHdoaXRlO1xcblxcdGZvbnQtZmFtaWx5OiBDb25zb2xhcywgTW9uYWNvLCAnQW5kYWxlIE1vbm8nLCAnVWJ1bnR1IE1vbm8nLCBtb25vc3BhY2U7XFxuXFx0dGV4dC1hbGlnbjogbGVmdDtcXG5cXHR3aGl0ZS1zcGFjZTogcHJlO1xcblxcdHdvcmQtc3BhY2luZzogbm9ybWFsO1xcblxcdHdvcmQtYnJlYWs6IG5vcm1hbDtcXG5cXHR3b3JkLXdyYXA6IG5vcm1hbDtcXG5cXHRsaW5lLWhlaWdodDogMS41O1xcblxcblxcdC1tb3otdGFiLXNpemU6IDQ7XFxuXFx0LW8tdGFiLXNpemU6IDQ7XFxuXFx0dGFiLXNpemU6IDQ7XFxuXFxuXFx0LXdlYmtpdC1oeXBoZW5zOiBub25lO1xcblxcdC1tb3otaHlwaGVuczogbm9uZTtcXG5cXHQtbXMtaHlwaGVuczogbm9uZTtcXG5cXHRoeXBoZW5zOiBub25lO1xcbn1cXG5cXG5wcmVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXTo6LW1vei1zZWxlY3Rpb24sIHByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIDo6LW1vei1zZWxlY3Rpb24sXFxuY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdOjotbW96LXNlbGVjdGlvbiwgY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIDo6LW1vei1zZWxlY3Rpb24ge1xcblxcdHRleHQtc2hhZG93OiBub25lO1xcblxcdGJhY2tncm91bmQ6ICNiM2Q0ZmM7XFxufVxcblxcbnByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdOjpzZWxlY3Rpb24sIHByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIDo6c2VsZWN0aW9uLFxcbmNvZGVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXTo6c2VsZWN0aW9uLCBjb2RlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0gOjpzZWxlY3Rpb24ge1xcblxcdHRleHQtc2hhZG93OiBub25lO1xcblxcdGJhY2tncm91bmQ6ICNiM2Q0ZmM7XFxufVxcblxcbkBtZWRpYSBwcmludCB7XFxuXFx0Y29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdLFxcblxcdHByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIHtcXG5cXHRcXHR0ZXh0LXNoYWRvdzogbm9uZTtcXG5cXHR9XFxufVxcblxcbi8qIENvZGUgYmxvY2tzICovXFxucHJlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0ge1xcblxcdHBhZGRpbmc6IDFlbTtcXG5cXHRtYXJnaW46IC41ZW0gMDtcXG5cXHRvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuOm5vdChwcmUpID4gY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdLFxcbnByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIHtcXG5cXHRiYWNrZ3JvdW5kOiAjZjVmMmYwO1xcbn1cXG5cXG4vKiBJbmxpbmUgY29kZSAqL1xcbjpub3QocHJlKSA+IGNvZGVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSB7XFxuXFx0cGFkZGluZzogLjFlbTtcXG5cXHRib3JkZXItcmFkaXVzOiAuM2VtO1xcblxcdHdoaXRlLXNwYWNlOiBub3JtYWw7XFxufVxcblxcbi50b2tlbi5jb21tZW50LFxcbi50b2tlbi5wcm9sb2csXFxuLnRva2VuLmRvY3R5cGUsXFxuLnRva2VuLmNkYXRhIHtcXG5cXHRjb2xvcjogc2xhdGVncmF5O1xcbn1cXG5cXG4udG9rZW4ucHVuY3R1YXRpb24ge1xcblxcdGNvbG9yOiAjOTk5O1xcbn1cXG5cXG4ubmFtZXNwYWNlIHtcXG5cXHRvcGFjaXR5OiAuNztcXG59XFxuXFxuLnRva2VuLnByb3BlcnR5LFxcbi50b2tlbi50YWcsXFxuLnRva2VuLmJvb2xlYW4sXFxuLnRva2VuLm51bWJlcixcXG4udG9rZW4uY29uc3RhbnQsXFxuLnRva2VuLnN5bWJvbCxcXG4udG9rZW4uZGVsZXRlZCB7XFxuXFx0Y29sb3I6ICM5MDU7XFxufVxcblxcbi50b2tlbi5zZWxlY3RvcixcXG4udG9rZW4uYXR0ci1uYW1lLFxcbi50b2tlbi5zdHJpbmcsXFxuLnRva2VuLmNoYXIsXFxuLnRva2VuLmJ1aWx0aW4sXFxuLnRva2VuLmluc2VydGVkIHtcXG5cXHRjb2xvcjogIzY5MDtcXG59XFxuXFxuLnRva2VuLm9wZXJhdG9yLFxcbi50b2tlbi5lbnRpdHksXFxuLnRva2VuLnVybCxcXG4ubGFuZ3VhZ2UtY3NzIC50b2tlbi5zdHJpbmcsXFxuLnN0eWxlIC50b2tlbi5zdHJpbmcge1xcblxcdGNvbG9yOiAjYTY3ZjU5O1xcblxcdGJhY2tncm91bmQ6IGhzbGEoMCwgMCUsIDEwMCUsIC41KTtcXG59XFxuXFxuLnRva2VuLmF0cnVsZSxcXG4udG9rZW4uYXR0ci12YWx1ZSxcXG4udG9rZW4ua2V5d29yZCB7XFxuXFx0Y29sb3I6ICMwN2E7XFxufVxcblxcbi50b2tlbi5mdW5jdGlvbiB7XFxuXFx0Y29sb3I6ICNERDRBNjg7XFxufVxcblxcbi50b2tlbi5yZWdleCxcXG4udG9rZW4uaW1wb3J0YW50LFxcbi50b2tlbi52YXJpYWJsZSB7XFxuXFx0Y29sb3I6ICNlOTA7XFxufVxcblxcbi50b2tlbi5pbXBvcnRhbnQsXFxuLnRva2VuLmJvbGQge1xcblxcdGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4udG9rZW4uaXRhbGljIHtcXG5cXHRmb250LXN0eWxlOiBpdGFsaWM7XFxufVxcblxcbi50b2tlbi5lbnRpdHkge1xcblxcdGN1cnNvcjogaGVscDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3ByaXNtanMvdGhlbWVzL3ByaXNtLmNzc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cclxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXHJcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xyXG5cdFx0XHRpZihpdGVtWzJdKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHByaXNtIGZyb20gJ3ByaXNtanMnO1xuaW1wb3J0ICdwcmlzbWpzL3RoZW1lcy9wcmlzbS5jc3MnO1xuXG5pbXBvcnQgaGFuZGxlRXZlbnQgZnJvbSAnLi9oYW5kbGUtZXZlbnQnO1xuaW1wb3J0IHBpbmNoSXQgZnJvbSAnLi4vc3JjLyc7XG5cbnBpbmNoSXQoJy5leGFtcGxlLW9uZSAuaW1nLXdyYXBwZXInKTtcbnBpbmNoSXQoJy5leGFtcGxlLXRyZWUgLmltZy13cmFwcGVyJywge1xuICBtYXhTY2FsZTogNCxcbiAgbWluU2NhbGU6IDAuNSxcbiAgc25hcEJhY2tTcGVlZDogNTAwLFxufSk7XG5cbmNvbnN0IHBpbmNoSW1hZ2UgPSBwaW5jaEl0KCcuZXhhbXBsZS1mb3VyIC5pbWctd3JhcHBlcicsIHtcbiAgc25hcEJhY2tTcGVlZDogMTAwMCxcbn0pO1xuXG5kb2N1bWVudFxuICAucXVlcnlTZWxlY3RvcignLnJlc2V0LWJ1dHRvbicpXG4gIC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBwaW5jaEltYWdlLnJlc2V0KCk7XG4gIH0pO1xuXG5jb25zdCB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZXZlbnQtdGFyZ2V0Jyk7XG5jb25zdCBoYW5kbGVFdmVudEV4YW1wbGUgPSBoYW5kbGVFdmVudCh0YXJnZXQpO1xuY29uc3QgcGluY2hFdmVudCA9IHBpbmNoSXQoJy5leGFtcGxlLWZpdmUgLmltZy13cmFwcGVyJywge1xuICB0YXJnZXQ6ICdpbWcnLFxuICBzbmFwQmFja1NwZWVkOiAxMDAwLFxufSk7XG5cbnBpbmNoRXZlbnQub24oJ3RvdWNoc3RhcnQnLCBoYW5kbGVFdmVudEV4YW1wbGUpO1xucGluY2hFdmVudC5vbigndG91Y2htb3ZlJywgaGFuZGxlRXZlbnRFeGFtcGxlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3MvYXBwLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==