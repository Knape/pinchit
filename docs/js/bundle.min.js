/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 16);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calcNewScale = exports.calcScale = exports.getTouchCenter = exports.getCurrentPinchCenter = exports.scaleFactor = exports.getInitialScale = exports.getParentY = exports.getParentX = exports.addOffset = exports.isWithin = undefined;

var _handleEvent = __webpack_require__(1);

var sum = function sum(acc, next) {
  return acc + next;
};

/**
 * Calculates the average of multiple vectors (x, y values)
 */


var getVectorAvg = function getVectorAvg(vectors) {
  return {
    x: vectors.map(function (v) {
      return v.x;
    }).reduce(sum) / vectors.length,
    y: vectors.map(function (v) {
      return v.y;
    }).reduce(sum) / vectors.length
  };
};

var getParentElement = function getParentElement(type) {
  return function (el) {
    return el instanceof HTMLImageElement && el.parentElement instanceof HTMLDivElement ? el.parentElement[type] : 1;
  };
};

/**
 * isWithin - Check if value is between two values
 *
 * @param { Number } scale current scale value
 * @param { Object } minPinch, maxPinh
 * @return { Boolean }
 **/
var isWithin = exports.isWithin = function isWithin(scale, opts) {
  var maxScale = opts.maxScale,
      minScale = opts.minScale;

  return scale >= minScale && scale <= maxScale;
};

/**
 * addOffset - Combine current offset with old offset and returns a new offset
 *
 * @param { Object } lastOffset last offset
 * @param { Object } offset, new offset
 * @return { Object }
 **/
var addOffset = exports.addOffset = function addOffset(lastOffset, offset) {
  return {
    x: lastOffset.x + offset.x,
    y: lastOffset.y + offset.y
  };
};

var getParentX = exports.getParentX = getParentElement('offsetWidth');
var getParentY = exports.getParentY = getParentElement('offsetHeight');

/**
 * getScale - Check if value is between two values
 *
 * @param { Node } el current scale value
 * @return { Number }
 **/
var getInitialScale = exports.getInitialScale = function getInitialScale(el) {
  return el instanceof HTMLImageElement ? getParentX(el) / el.offsetWidth : 1;
};

/**
 * Scales the zoom factor relative to current state
 *
 * @param scale
 * @return the actual scale (can differ because of max min zoom factor)
 */
var scaleFactor = exports.scaleFactor = function scaleFactor(scale, factor, opts) {
  var originalFactor = factor;
  var zoomFactor = factor * scale;
  var maxScaleTimes = opts.maxScaleTimes,
      minScaleTimes = opts.minScaleTimes;

  zoomFactor = Math.min(maxScaleTimes, Math.max(zoomFactor, minScaleTimes));
  return {
    zoomFactor: zoomFactor,
    scale: zoomFactor / originalFactor
  };
};

/**
 * Calculates the virtual zoom center for the current offset and zoom factor
 * (used for reverse zoom)
 * @return {Object} the current zoom center
 */
var getCurrentPinchCenter = exports.getCurrentPinchCenter = function getCurrentPinchCenter(el, zoomFactor, offset) {
  var length = getParentX(el) * zoomFactor;
  var offsetLeft = offset.x;
  var offsetRight = length - offsetLeft - getParentX(el);
  var widthOffsetRatio = offsetLeft / offsetRight;
  var centerX = widthOffsetRatio * getParentX(el) / (widthOffsetRatio + 1);

  // the same for the zoomcenter y
  var height = getParentY(el) * zoomFactor;
  var offsetTop = offset.y;
  var offsetBottom = height - offsetTop - getParentY(el);
  var heightOffsetRatio = offsetTop / offsetBottom;
  var centerY = heightOffsetRatio * getParentY(el) / (heightOffsetRatio + 1);

  // prevents division by zero
  if (offsetRight === 0) {
    centerX = getParentX(el);
  }
  if (offsetBottom === 0) {
    centerY = getParentY(el);
  }

  return {
    x: centerX,
    y: centerY
  };
};

var getTouchCenter = exports.getTouchCenter = function getTouchCenter(touches) {
  return getVectorAvg(touches);
};

/**
 * calcScale - Calculate the distance between where we start our pinch
 * to where we end it
 *
 * @param { Array } startTouch The starting point of our touch
 * @param { Array } endTouch The current point of our touch
 * @return { Number }
 */
var calcScale = exports.calcScale = function calcScale(el, startTouch, endTouch) {
  return (0, _handleEvent.getDistance)((0, _handleEvent.getTouches)(el, endTouch)) / (0, _handleEvent.getDistance)((0, _handleEvent.getTouches)(el, startTouch));
};

var calcNewScale = exports.calcNewScale = function calcNewScale(to) {
  var lastScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return to / lastScale;
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var lastTouchStart = 0;

/**
 * cancelEvent - Cancel Events so we dont bubble up our events to the document
 *
 * @param { Object } event
 * @return { Void }
 **/
var cancelEvent = exports.cancelEvent = function cancelEvent(e) {
  e.stopPropagation();
  e.preventDefault();
};

/**
 * detectDoubleTap - Check if we are double tapping
 *
 * @param { Object } event
 * @return { Boolean }
 **/
var detectDoubleTap = exports.detectDoubleTap = function detectDoubleTap(e) {
  var time = new Date().getTime();

  if (e.touches.length > 1) {
    lastTouchStart = 0;
  }

  if (time - lastTouchStart < 300) {
    cancelEvent(event);
    return true;
  }

  if (e.touches.length === 1) {
    lastTouchStart = time;
  }
  return false;
};

/**
 * Returns the touches of an event relative to the container offset
 *
 * @param event
 * @return array touches
 */
var getTouches = exports.getTouches = function getTouches(el, touches) {
  var position = el.parentElement.getBoundingClientRect();
  return touches.map(function (touch) {
    return {
      x: touch.pageX - (position.left + document.body.scrollLeft),
      y: touch.pageY - (position.top + document.body.scrollTop)
    };
  });
};

/**
 * getDistance - Calculate the distance between our fingers
 *
 * @param { Array } touches touches passas an array from TouchList
 * @return { Number } the calcualted distance between the fingers
 **/
var getDistance = exports.getDistance = function getDistance(touches) {
  var _touches = _slicedToArray(touches, 2),
      first = _touches[0],
      second = _touches[1];

  return Math.sqrt((first.x - second.x) * (first.x - second.x) + (first.y - second.y) * (first.y - second.y));
};

/***/ }),
/* 2 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (target) {
  return function (e) {
    var newSpan = document.createElement('span');
    var time = new Date();
    time = time.getHours() + ':' + time.getMinutes() + ':' + time.getSeconds() + ',' + time.getMilliseconds();
    var newContent = document.createTextNode('[' + time + '] Event dispatched: "' + e.type + '"');
    newSpan.appendChild(newContent);
    target.appendChild(newSpan);
  };
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pinchIt = __webpack_require__(8);

var _pinchIt2 = _interopRequireDefault(_pinchIt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _pinchIt2.default;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/* **********************************************
     Begin prism-core.js
********************************************** */

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function(){

// Private helper vars
var lang = /\blang(?:uage)?-(\w+)\b/i;
var uniqueId = 0;

var _ = _self.Prism = {
	util: {
		encode: function (tokens) {
			if (tokens instanceof Token) {
				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
			} else if (_.util.type(tokens) === 'Array') {
				return tokens.map(_.util.encode);
			} else {
				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
			}
		},

		type: function (o) {
			return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
		},

		objId: function (obj) {
			if (!obj['__id']) {
				Object.defineProperty(obj, '__id', { value: ++uniqueId });
			}
			return obj['__id'];
		},

		// Deep clone a language definition (e.g. to extend it)
		clone: function (o) {
			var type = _.util.type(o);

			switch (type) {
				case 'Object':
					var clone = {};

					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = _.util.clone(o[key]);
						}
					}

					return clone;

				case 'Array':
					// Check for existence for IE8
					return o.map && o.map(function(v) { return _.util.clone(v); });
			}

			return o;
		}
	},

	languages: {
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);

			for (var key in redef) {
				lang[key] = redef[key];
			}

			return lang;
		},

		/**
		 * Insert a token before another token in a language literal
		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
		 * we cannot just provide an object, we need anobject and a key.
		 * @param inside The key (or language id) of the parent
		 * @param before The key to insert before. If not provided, the function appends instead.
		 * @param insert Object with the key/value pairs to insert
		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
		 */
		insertBefore: function (inside, before, insert, root) {
			root = root || _.languages;
			var grammar = root[inside];

			if (arguments.length == 2) {
				insert = arguments[1];

				for (var newToken in insert) {
					if (insert.hasOwnProperty(newToken)) {
						grammar[newToken] = insert[newToken];
					}
				}

				return grammar;
			}

			var ret = {};

			for (var token in grammar) {

				if (grammar.hasOwnProperty(token)) {

					if (token == before) {

						for (var newToken in insert) {

							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}

					ret[token] = grammar[token];
				}
			}

			// Update references in other language definitions
			_.languages.DFS(_.languages, function(key, value) {
				if (value === root[inside] && key != inside) {
					this[key] = ret;
				}
			});

			return root[inside] = ret;
		},

		// Traverse a language definition with Depth First Search
		DFS: function(o, callback, type, visited) {
			visited = visited || {};
			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					callback.call(o, i, o[i], type || i);

					if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, null, visited);
					}
					else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, i, visited);
					}
				}
			}
		}
	},
	plugins: {},

	highlightAll: function(async, callback) {
		var env = {
			callback: callback,
			selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
		};

		_.hooks.run("before-highlightall", env);

		var elements = env.elements || document.querySelectorAll(env.selector);

		for (var i=0, element; element = elements[i++];) {
			_.highlightElement(element, async === true, env.callback);
		}
	},

	highlightElement: function(element, async, callback) {
		// Find language
		var language, grammar, parent = element;

		while (parent && !lang.test(parent.className)) {
			parent = parent.parentNode;
		}

		if (parent) {
			language = (parent.className.match(lang) || [,''])[1].toLowerCase();
			grammar = _.languages[language];
		}

		// Set language on the element, if not present
		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

		// Set language on the parent, for styling
		parent = element.parentNode;

		if (/pre/i.test(parent.nodeName)) {
			parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
		}

		var code = element.textContent;

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};

		_.hooks.run('before-sanity-check', env);

		if (!env.code || !env.grammar) {
			if (env.code) {
				env.element.textContent = env.code;
			}
			_.hooks.run('complete', env);
			return;
		}

		_.hooks.run('before-highlight', env);

		if (async && _self.Worker) {
			var worker = new Worker(_.filename);

			worker.onmessage = function(evt) {
				env.highlightedCode = evt.data;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				callback && callback.call(env.element);
				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			};

			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code,
				immediateClose: true
			}));
		}
		else {
			env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

			_.hooks.run('before-insert', env);

			env.element.innerHTML = env.highlightedCode;

			callback && callback.call(element);

			_.hooks.run('after-highlight', env);
			_.hooks.run('complete', env);
		}
	},

	highlight: function (text, grammar, language) {
		var tokens = _.tokenize(text, grammar);
		return Token.stringify(_.util.encode(tokens), language);
	},

	tokenize: function(text, grammar, language) {
		var Token = _.Token;

		var strarr = [text];

		var rest = grammar.rest;

		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}

			delete grammar.rest;
		}

		tokenloop: for (var token in grammar) {
			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				var pattern = patterns[j],
					inside = pattern.inside,
					lookbehind = !!pattern.lookbehind,
					greedy = !!pattern.greedy,
					lookbehindLength = 0,
					alias = pattern.alias;

				if (greedy && !pattern.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
					pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
				}

				pattern = pattern.pattern || pattern;

				// Don’t cache length as it changes during the loop
				for (var i=0, pos = 0; i<strarr.length; pos += strarr[i].length, ++i) {

					var str = strarr[i];

					if (strarr.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						break tokenloop;
					}

					if (str instanceof Token) {
						continue;
					}

					pattern.lastIndex = 0;

					var match = pattern.exec(str),
					    delNum = 1;

					// Greedy patterns can override/remove up to two previously matched tokens
					if (!match && greedy && i != strarr.length - 1) {
						pattern.lastIndex = pos;
						match = pattern.exec(text);
						if (!match) {
							break;
						}

						var from = match.index + (lookbehind ? match[1].length : 0),
						    to = match.index + match[0].length,
						    k = i,
						    p = pos;

						for (var len = strarr.length; k < len && p < to; ++k) {
							p += strarr[k].length;
							// Move the index i to the element in strarr that is closest to from
							if (from >= p) {
								++i;
								pos = p;
							}
						}

						/*
						 * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
						 * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
						 */
						if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
							continue;
						}

						// Number of tokens to delete and replace with the new match
						delNum = k - i;
						str = text.slice(pos, p);
						match.index -= pos;
					}

					if (!match) {
						continue;
					}

					if(lookbehind) {
						lookbehindLength = match[1].length;
					}

					var from = match.index + lookbehindLength,
					    match = match[0].slice(lookbehindLength),
					    to = from + match.length,
					    before = str.slice(0, from),
					    after = str.slice(to);

					var args = [i, delNum];

					if (before) {
						args.push(before);
					}

					var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

					args.push(wrapped);

					if (after) {
						args.push(after);
					}

					Array.prototype.splice.apply(strarr, args);
				}
			}
		}

		return strarr;
	},

	hooks: {
		all: {},

		add: function (name, callback) {
			var hooks = _.hooks.all;

			hooks[name] = hooks[name] || [];

			hooks[name].push(callback);
		},

		run: function (name, env) {
			var callbacks = _.hooks.all[name];

			if (!callbacks || !callbacks.length) {
				return;
			}

			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	}
};

var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
	this.type = type;
	this.content = content;
	this.alias = alias;
	// Copy of the full string this token was created from
	this.length = (matchedStr || "").length|0;
	this.greedy = !!greedy;
};

Token.stringify = function(o, language, parent) {
	if (typeof o == 'string') {
		return o;
	}

	if (_.util.type(o) === 'Array') {
		return o.map(function(element) {
			return Token.stringify(element, language, o);
		}).join('');
	}

	var env = {
		type: o.type,
		content: Token.stringify(o.content, language, parent),
		tag: 'span',
		classes: ['token', o.type],
		attributes: {},
		language: language,
		parent: parent
	};

	if (env.type == 'comment') {
		env.attributes['spellcheck'] = 'true';
	}

	if (o.alias) {
		var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
		Array.prototype.push.apply(env.classes, aliases);
	}

	_.hooks.run('wrap', env);

	var attributes = Object.keys(env.attributes).map(function(name) {
		return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
	}).join(' ');

	return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';

};

if (!_self.document) {
	if (!_self.addEventListener) {
		// in Node.js
		return _self.Prism;
	}
 	// In worker
	_self.addEventListener('message', function(evt) {
		var message = JSON.parse(evt.data),
		    lang = message.language,
		    code = message.code,
		    immediateClose = message.immediateClose;

		_self.postMessage(_.highlight(code, _.languages[lang], lang));
		if (immediateClose) {
			_self.close();
		}
	}, false);

	return _self.Prism;
}

//Get current script and highlight
var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

if (script) {
	_.filename = script.src;

	if (document.addEventListener && !script.hasAttribute('data-manual')) {
		if(document.readyState !== "loading") {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(_.highlightAll);
			} else {
				window.setTimeout(_.highlightAll, 16);
			}
		}
		else {
			document.addEventListener('DOMContentLoaded', _.highlightAll);
		}
	}
}

return _self.Prism;

})();

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== 'undefined') {
	global.Prism = Prism;
}


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': /<!--[\w\W]*?-->/,
	'prolog': /<\?[\w\W]+?\?>/,
	'doctype': /<!DOCTYPE[\w\W]+?>/i,
	'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/i,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'attr-value': {
				pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
				inside: {
					'punctuation': /[=>"']/
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': /&#?[\da-z]{1,8};/i
};

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function(env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;


/* **********************************************
     Begin prism-css.js
********************************************** */

Prism.languages.css = {
	'comment': /\/\*[\w\W]*?\*\//,
	'atrule': {
		pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
		inside: {
			'rule': /@[\w-]+/
			// See rest below
		}
	},
	'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
	'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
	'string': {
		pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'property': /(\b|\B)[\w-]+(?=\s*:)/i,
	'important': /\B!important\b/i,
	'function': /[-a-z0-9]+(?=\()/i,
	'punctuation': /[(){};:]/
};

Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'style': {
			pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
			lookbehind: true,
			inside: Prism.languages.css,
			alias: 'language-css'
		}
	});
	
	Prism.languages.insertBefore('inside', 'attr-value', {
		'style-attr': {
			pattern: /\s*style=("|').*?\1/i,
			inside: {
				'attr-name': {
					pattern: /^\s*style/i,
					inside: Prism.languages.markup.tag.inside
				},
				'punctuation': /^\s*=\s*['"]|['"]\s*$/,
				'attr-value': {
					pattern: /.+/i,
					inside: Prism.languages.css
				}
			},
			alias: 'language-css'
		}
	}, Prism.languages.markup.tag);
}

/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
			lookbehind: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true
		}
	],
	'string': {
		pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
		lookbehind: true,
		inside: {
			punctuation: /(\.|\\)/
		}
	},
	'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(true|false)\b/,
	'function': /[a-z0-9_]+(?=\()/i,
	'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
	'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
});

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
		lookbehind: true,
		greedy: true
	}
});

Prism.languages.insertBefore('javascript', 'string', {
	'template-string': {
		pattern: /`(?:\\\\|\\?[^\\])*?`/,
		greedy: true,
		inside: {
			'interpolation': {
				pattern: /\$\{[^}]+\}/,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'script': {
			pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript,
			alias: 'language-javascript'
		}
	});
}

Prism.languages.js = Prism.languages.javascript;

/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
	if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
		return;
	}

	self.Prism.fileHighlight = function() {

		var Extensions = {
			'js': 'javascript',
			'py': 'python',
			'rb': 'ruby',
			'ps1': 'powershell',
			'psm1': 'powershell',
			'sh': 'bash',
			'bat': 'batch',
			'h': 'c',
			'tex': 'latex'
		};

		if(Array.prototype.forEach) { // Check to prevent error in IE8
			Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
				var src = pre.getAttribute('data-src');

				var language, parent = pre;
				var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
				while (parent && !lang.test(parent.className)) {
					parent = parent.parentNode;
				}

				if (parent) {
					language = (pre.className.match(lang) || [, ''])[1];
				}

				if (!language) {
					var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
					language = Extensions[extension] || extension;
				}

				var code = document.createElement('code');
				code.className = 'language-' + language;

				pre.textContent = '';

				code.textContent = 'Loading…';

				pre.appendChild(code);

				var xhr = new XMLHttpRequest();

				xhr.open('GET', src, true);

				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {

						if (xhr.status < 400 && xhr.responseText) {
							code.textContent = xhr.responseText;

							Prism.highlightElement(code);
						}
						else if (xhr.status >= 400) {
							code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
						}
						else {
							code.textContent = '✖ Error: File does not exist or is empty';
						}
					}
				};

				xhr.send(null);
			});
		}

	};

	document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(13);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(15)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!./../../css-loader/index.js!./prism.css", function() {
			var newContent = require("!!./../../css-loader/index.js!./prism.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {

  /**
   * default scale that will be set on element
   * @maxPinch {Number}
   */
  baseScale: 1,

  /**
   * max scale a node can reach
   * @maxPinch {Number}
   */
  maxScale: 3,

  /**
   * max scale a node can reach before bouncing back to maxScale
   * @maxScaleTimes {Number}
   */
  maxScaleTimes: 4,

  /**
   * min scale a node can reach
   * @minPinch {Number}
   */
  minScale: 1,

  /**
   * min scale a node can reach before bouncing back to minScale
   * @minScaleTimes {Number}
   */
  minScaleTimes: 0.8,

  /**
   * time for the snapBack of the pinch if the node has reach above
   * or below its pinch value
   * @snapBackSpeed {Number}
   */
  snapBackSpeed: 200,

  /**
   * Basic easing functions: https://developer.mozilla.org/de/docs/Web/CSS/transition-timing-function
   * cubic bezier easing functions: http://easings.net/de
   * @ease {String}
   */
  ease: 'ease'
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
//


var _dispatchEvent = __webpack_require__(10);

var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

var _handleEvent = __webpack_require__(1);

var _handleElement = __webpack_require__(12);

var _handleElement2 = _interopRequireDefault(_handleElement);

var _handlePinch = __webpack_require__(0);

var _handleDrag = __webpack_require__(11);

var _defaults = __webpack_require__(7);

var _defaults2 = _interopRequireDefault(_defaults);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var first = function first(items) {
  return items[0];
};

var pinchIt = function pinchIt(targets) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // private variable cache
  var elements = [];
  var opts = {};

  var scaling = void 0;
  var lastScale = 1;
  var startTouches = void 0;

  var zoomFactor = 1;

  var offset = { x: 0, y: 0 };
  var lastZoomCenter = false;
  var lastDragPosition = false;

  var _eventDispatcher = (0, _dispatchEvent2.default)(),
      on = _eventDispatcher.on,
      dispatch = _eventDispatcher.dispatch;

  /**
   *  dispatchPinchEvent - Shorthand method for creating events
   *
   *  @param { String } phase
   *  @param { String } type
   *  @param { Object } details
   *  @return { Void }
   **/


  var dispatchPinchEvent = function dispatchPinchEvent(eventName, phase) {
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    dispatch(eventName, Object.assign(data, {
      phase: phase
    }));
  };

  var resetGlobals = function resetGlobals() {
    scaling = undefined;
    lastScale = 1;
    startTouches = null;
    zoomFactor = 1;
    lastZoomCenter = false;

    lastDragPosition = false;
    offset = { x: 0, y: 0 };
  };

  // event handling
  /**
   * Set scaling if we are using more then one finger
   * and captures our first punch point
   *
   * private
   * @param { Object } e the event from our eventlistener
   */
  var onTouchstart = function onTouchstart(e) {
    dispatchPinchEvent('touchstart', 'before', e);

    scaling = e.touches.length === 2;
    startTouches = Array.from(e.touches);
    lastScale = 1;

    if ((0, _handleEvent.detectDoubleTap)(e)) {
      (0, _handleElement2.default)(e.target, 1, { x: 0, y: 0 }, opts.snapBackSpeed, opts.ease);
      resetGlobals();
    }

    dispatchPinchEvent('touchstart', 'after', e);
  };

  var onTouchmove = function onTouchmove(e) {
    dispatchPinchEvent('touchmove', 'before', e);

    if ((!scaling || !startTouches) && zoomFactor > 1) {
      (0, _handleEvent.cancelEvent)(e);

      var touch = first((0, _handleEvent.getTouches)(e.target, Array.from(e.touches)));
      var dragOffset = (0, _handleDrag.drag)(touch, lastDragPosition, offset, zoomFactor);

      offset = (0, _handleDrag.sanitizeOffset)(e.target, dragOffset, zoomFactor);
      lastDragPosition = touch;
    } else if (scaling && startTouches) {
      (0, _handleEvent.cancelEvent)(e);

      // a relative scale factor is used
      var touchCenter = (0, _handlePinch.getTouchCenter)((0, _handleEvent.getTouches)(e.target, Array.from(e.touches)));
      var newScale = (0, _handlePinch.calcScale)(e.target, startTouches, Array.from(e.touches));
      var scale = (0, _handlePinch.calcNewScale)(newScale, lastScale);

      var factor = (0, _handlePinch.scaleFactor)(scale, zoomFactor, opts);

      offset = (0, _handlePinch.addOffset)(offset, {
        x: (factor.scale - 1) * (touchCenter.x + offset.x),
        y: (factor.scale - 1) * (touchCenter.y + offset.y)
      });

      zoomFactor = factor.zoomFactor;
      lastScale = newScale;
      offset = (0, _handleDrag.drag)(touchCenter, lastZoomCenter, offset, zoomFactor);
      lastZoomCenter = touchCenter;
    }

    (0, _handleElement2.default)(e.target, zoomFactor, offset, 0, opts.ease);

    dispatchPinchEvent('touchmove', 'after', e);
  };

  var onTouchend = function onTouchend(e) {
    dispatchPinchEvent('touchend', 'before', e);

    lastDragPosition = false;
    lastZoomCenter = false;
    lastScale = 1;
    if (zoomFactor) {
      if (!(0, _handlePinch.isWithin)(zoomFactor, opts)) {
        var isLessThan = (0, _handlePinch.getInitialScale)(e.target) * zoomFactor < opts.minScale;
        zoomFactor = isLessThan ? opts.minScale : opts.maxScale;
        offset = (0, _handleDrag.sanitizeOffset)(e.target, offset, zoomFactor);
        (0, _handleElement2.default)(e.target, zoomFactor, offset, opts.snapBackSpeed, opts.ease);
      }
    }

    dispatchPinchEvent('touchend', 'after', e);
  };

  var attachEvents = function attachEvents(el) {
    el.addEventListener('touchstart', onTouchstart);
    el.addEventListener('touchmove', onTouchmove);
    el.addEventListener('touchend', onTouchend);
  };

  var detachhEvents = function detachhEvents(el) {
    el.removeEventListener('touchstart', onTouchstart);
    el.removeEventListener('touchmove', onTouchmove);
    el.removeEventListener('touchend', onTouchend);
  };

  /**
   * public
   * reset function:
   * @param { Number } duration
   * @param { String } easing
   * @return { Void }
   */
  var reset = function reset(opt) {
    return function (item) {
      var _defaults$opt = _extends({}, _defaults2.default, opt),
          snapBackSpeed = _defaults$opt.snapBackSpeed,
          easing = _defaults$opt.easing;

      if (item && !isNaN(item) && elements[item]) {
        (0, _handleElement2.default)(elements[item], 1, { x: 0, y: 0 }, snapBackSpeed, easing);
      } else {
        Array.from(elements).forEach(function (el) {
          return (0, _handleElement2.default)(el, 1, { x: 0, y: 0 }, snapBackSpeed, easing);
        });
      }

      resetGlobals();
    };
  };

  /**
   * public
   * destroy function: called to gracefully destroy the lory instance
   * @return { Void }
   */
  var destroy = function destroy() {
    dispatchPinchEvent('destroy', 'before', {});
    // remove event listeners
    Array.from(elements).forEach(detachhEvents);
    elements = [];
    resetGlobals();
    dispatchPinchEvent('destroy', 'after', {});
  };

  /**
   * setup - Init function
   *
   * @param { String, Object }
   * @return { Void }
   **/

  var setup = function setup(target, opt) {
    if (elements) destroy();
    dispatchPinchEvent('init', 'before', {});

    // Base configuration for the pinch instance
    opts = _extends({}, _defaults2.default, opt);

    // resolve target
    // pinchit allows for both a node or a string to be passed
    switch (typeof target === 'undefined' ? 'undefined' : _typeof(target)) {
      case 'object':
        elements = Array.isArray(target) ? target : [target];
        break;
      case 'string':
        elements = document.querySelectorAll(target);
        break;
      default:
        elements = [];
        console.warn('missing target, either pass an node or a string');
    }

    Array.from(elements).forEach(attachEvents);

    dispatchPinchEvent('init', 'after', {});
  };

  // trigger initial setup
  setup(targets, options);

  return {
    setup: setup,
    reset: reset(options),
    destroy: destroy,
    elements: elements,
    on: on
  };
};

exports.default = pinchIt;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Detecting prefixes for saving time and bytes
 */
exports.default = function () {
  var transform = void 0;
  var transition = void 0;
  var transitionEnd = void 0;
  var hasScale3d = void 0;

  (function () {
    var el = document.createElement('_');
    var style = el.style;

    if (style.webkitTransition === '') {
      transitionEnd = 'webkitTransitionEnd';
      transition = 'webkitTransition';
    }

    if (style.transition === '') {
      transitionEnd = 'transitionend';
      transition = 'transition';
    }

    if (style.webkitTransform === '') {
      transform = 'webkitTransform';
    }

    if (style.msTransform === '') {
      transform = 'msTransform';
    }

    if (style.transform === '') {
      transform = 'transform';
    }

    document.body.insertBefore(el, null);
    style[transform] = 'translate3d(0, 0, 0)';
    hasScale3d = !!global.getComputedStyle(el).getPropertyValue(transform);
    document.body.removeChild(el);
  })();

  return {
    transform: transform,
    transition: transition,
    transitionEnd: transitionEnd,
    hasScale3d: hasScale3d
  };
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});


/**
 * dispatch custom events
 */

var eventDispatcher = function eventDispatcher() {
  var events = {};

  /**
   * Register a handler for event, to be fired
   * for every event.
   */
  var on = function on(eventName, handler) {
    events[eventName] = events[eventName] || [];
    events[eventName].push(handler);
    return undefined;
  };

  /**
   * Deregister a handler for event.
   */
  var off = function off(eventName, handler) {
    if (events[eventName]) {
      for (var i = 0; i < events[eventName].length; i += 1) {
        if (events[eventName][i] === handler) {
          events[eventName].splice(i, 1);
          break;
        }
      }
    }
  };

  var dispatch = function dispatch(eventName, data) {
    if (events[eventName]) {
      events[eventName].forEach(function (fn) {
        fn(data);
      });
    }
  };

  return {
    on: on,
    off: off,
    dispatch: dispatch
  };
};

exports.default = eventDispatcher;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drag = exports.sanitizeOffset = undefined;

var _handlePinch = __webpack_require__(0);

var calcMax = function calcMax(el, differ, zoomFactor) {
  return {
    maxX: (zoomFactor - differ) * (0, _handlePinch.getParentX)(el),
    maxY: (zoomFactor - differ) * (0, _handlePinch.getParentY)(el)
  };
};

var sanitizeOffset = exports.sanitizeOffset = function sanitizeOffset(el, offset, zoomFactor) {
  var _calcMax = calcMax(el, 1, zoomFactor),
      maxX = _calcMax.maxX,
      maxY = _calcMax.maxY;

  var maxOffsetX = Math.max(maxX, 0);
  var maxOffsetY = Math.max(maxY, 0);
  var minOffsetX = Math.min(maxX, 0);
  var minOffsetY = Math.min(maxY, 0);

  return {
    x: Math.min(Math.max(offset.x, minOffsetX), maxOffsetX),
    y: Math.min(Math.max(offset.y, minOffsetY), maxOffsetY)
  };
};

var drag = exports.drag = function drag(center, lastCenter, lastOffset, zoomFactor) {
  return Object.prototype.hasOwnProperty.call(lastCenter, 'x') ? (0, _handlePinch.addOffset)(lastOffset, {
    x: -((center.x - lastCenter.x) * zoomFactor / zoomFactor),
    y: -((center.y - lastCenter.y) * zoomFactor / zoomFactor)
  }) : lastOffset;
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _detectPrefixes = __webpack_require__(9);

var _detectPrefixes2 = _interopRequireDefault(_detectPrefixes);

var _handlePinch = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var prefixes = (0, _detectPrefixes2.default)();

var handleAnimation = function handleAnimation(el, transition, duration, ease) {
  var style = el.style;

  style.transformOrigin = '0% 0%';
  style[transition + 'TimingFunction'] = ease;
  style[transition + 'Duration'] = duration + 'ms';
};

/**
 * scaleElement -transdorms to a given position in a given time in milliseconds
 *
 * @param { Object } el element from the events
 * @param { Number } pinch number where to scale to
 * @param { Object } coords object where to translate to
 * @param { Number } duration time in milliseconds for the transistion
 * @param { String } ease easing css property
 * @return { Void }
 */

exports.default = function (el, pinch, coords, duration, ease) {
  var transition = prefixes.transition,
      transform = prefixes.transform,
      hasScale3d = prefixes.hasScale3d;
  var style = el.style;


  var zoomFactor = (0, _handlePinch.getInitialScale)(el) * pinch;

  var offsetX = -coords.x;
  var offsetY = -coords.y;

  handleAnimation(el, transition, duration, ease);
  var scaleProp = hasScale3d ? 'scale3d(' + zoomFactor + ', ' + zoomFactor + ', 1)' : 'scale(' + zoomFactor + ', ' + zoomFactor + ')';
  var translateProp = 'translate(' + offsetX + 'px, ' + offsetY + 'px)';

  style[transform] = translateProp + ' ' + scaleProp;
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(14)();
// imports


// module
exports.push([module.i, "/**\n * prism.js default theme for JavaScript, CSS and HTML\n * Based on dabblet (http://dabblet.com)\n * @author Lea Verou\n */\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n\tcolor: black;\n\tbackground: none;\n\ttext-shadow: 0 1px white;\n\tfont-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;\n\ttext-align: left;\n\twhite-space: pre;\n\tword-spacing: normal;\n\tword-break: normal;\n\tword-wrap: normal;\n\tline-height: 1.5;\n\n\t-moz-tab-size: 4;\n\t-o-tab-size: 4;\n\ttab-size: 4;\n\n\t-webkit-hyphens: none;\n\t-moz-hyphens: none;\n\t-ms-hyphens: none;\n\thyphens: none;\n}\n\npre[class*=\"language-\"]::-moz-selection, pre[class*=\"language-\"] ::-moz-selection,\ncode[class*=\"language-\"]::-moz-selection, code[class*=\"language-\"] ::-moz-selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\npre[class*=\"language-\"]::selection, pre[class*=\"language-\"] ::selection,\ncode[class*=\"language-\"]::selection, code[class*=\"language-\"] ::selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\n@media print {\n\tcode[class*=\"language-\"],\n\tpre[class*=\"language-\"] {\n\t\ttext-shadow: none;\n\t}\n}\n\n/* Code blocks */\npre[class*=\"language-\"] {\n\tpadding: 1em;\n\tmargin: .5em 0;\n\toverflow: auto;\n}\n\n:not(pre) > code[class*=\"language-\"],\npre[class*=\"language-\"] {\n\tbackground: #f5f2f0;\n}\n\n/* Inline code */\n:not(pre) > code[class*=\"language-\"] {\n\tpadding: .1em;\n\tborder-radius: .3em;\n\twhite-space: normal;\n}\n\n.token.comment,\n.token.prolog,\n.token.doctype,\n.token.cdata {\n\tcolor: slategray;\n}\n\n.token.punctuation {\n\tcolor: #999;\n}\n\n.namespace {\n\topacity: .7;\n}\n\n.token.property,\n.token.tag,\n.token.boolean,\n.token.number,\n.token.constant,\n.token.symbol,\n.token.deleted {\n\tcolor: #905;\n}\n\n.token.selector,\n.token.attr-name,\n.token.string,\n.token.char,\n.token.builtin,\n.token.inserted {\n\tcolor: #690;\n}\n\n.token.operator,\n.token.entity,\n.token.url,\n.language-css .token.string,\n.style .token.string {\n\tcolor: #a67f59;\n\tbackground: hsla(0, 0%, 100%, .5);\n}\n\n.token.atrule,\n.token.attr-value,\n.token.keyword {\n\tcolor: #07a;\n}\n\n.token.function {\n\tcolor: #DD4A68;\n}\n\n.token.regex,\n.token.important,\n.token.variable {\n\tcolor: #e90;\n}\n\n.token.important,\n.token.bold {\n\tfont-weight: bold;\n}\n.token.italic {\n\tfont-style: italic;\n}\n\n.token.entity {\n\tcursor: help;\n}\n", ""]);

// exports


/***/ }),
/* 14 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function() {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		var result = [];
		for(var i = 0; i < this.length; i++) {
			var item = this[i];
			if(item[2]) {
				result.push("@media " + item[2] + "{" + item[1] + "}");
			} else {
				result.push(item[1]);
			}
		}
		return result.join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
	}),
	getHeadElement = memoize(function () {
		return document.head || document.getElementsByTagName("head")[0];
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [];

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the bottom of <head>.
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
}

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var head = getHeadElement();
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			head.insertBefore(styleElement, head.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			head.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		head.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	styleElement.type = "text/css";
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	linkElement.rel = "stylesheet";
	insertStyleElement(options, linkElement);
	return linkElement;
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _prismjs = __webpack_require__(5);

var _prismjs2 = _interopRequireDefault(_prismjs);

__webpack_require__(6);

var _handleEvent = __webpack_require__(3);

var _handleEvent2 = _interopRequireDefault(_handleEvent);

var _src = __webpack_require__(4);

var _src2 = _interopRequireDefault(_src);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _src2.default)('.example-one img');
(0, _src2.default)('.example-two img');
(0, _src2.default)('.example-tree img', {
  maxScale: 4,
  minScale: 0.5,
  snapBackSpeed: 500
});

var pinchImage = (0, _src2.default)('.example-four img', {
  snapBackSpeed: 1000
});

document.querySelector('.reset-button').addEventListener('click', function () {
  pinchImage.reset();
});

var target = document.querySelector('.event-target');
var handleEventExample = (0, _handleEvent2.default)(target);
var pinchEvent = (0, _src2.default)('.example-five img', {
  snapBackSpeed: 1000
});

pinchEvent.on('touchstart', handleEventExample);
pinchEvent.on('touchmove', handleEventExample);

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZjMyMGQyNmU4MzQwM2U1YzNlNDMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2hhbmRsZS1waW5jaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvaGFuZGxlLWV2ZW50LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vZG9jcy9oYW5kbGUtZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcHJpc21qcy9wcmlzbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaXNtanMvdGhlbWVzL3ByaXNtLmNzcz82ODBkIiwid2VicGFjazovLy8uL3NyYy9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGluY2gtaXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2RldGVjdC1wcmVmaXhlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvZGlzcGF0Y2gtZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2hhbmRsZS1kcmFnLmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9oYW5kbGUtZWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaXNtanMvdGhlbWVzL3ByaXNtLmNzcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9kb2NzL2FwcC5qcyJdLCJuYW1lcyI6WyJzdW0iLCJhY2MiLCJuZXh0IiwiZ2V0VmVjdG9yQXZnIiwidmVjdG9ycyIsIngiLCJtYXAiLCJ2IiwicmVkdWNlIiwibGVuZ3RoIiwieSIsImdldFBhcmVudEVsZW1lbnQiLCJ0eXBlIiwiZWwiLCJIVE1MSW1hZ2VFbGVtZW50IiwicGFyZW50RWxlbWVudCIsIkhUTUxEaXZFbGVtZW50IiwiaXNXaXRoaW4iLCJzY2FsZSIsIm9wdHMiLCJtYXhTY2FsZSIsIm1pblNjYWxlIiwiYWRkT2Zmc2V0IiwibGFzdE9mZnNldCIsIm9mZnNldCIsImdldFBhcmVudFgiLCJnZXRQYXJlbnRZIiwiZ2V0SW5pdGlhbFNjYWxlIiwib2Zmc2V0V2lkdGgiLCJzY2FsZUZhY3RvciIsImZhY3RvciIsIm9yaWdpbmFsRmFjdG9yIiwiem9vbUZhY3RvciIsIm1heFNjYWxlVGltZXMiLCJtaW5TY2FsZVRpbWVzIiwiTWF0aCIsIm1pbiIsIm1heCIsImdldEN1cnJlbnRQaW5jaENlbnRlciIsIm9mZnNldExlZnQiLCJvZmZzZXRSaWdodCIsIndpZHRoT2Zmc2V0UmF0aW8iLCJjZW50ZXJYIiwiaGVpZ2h0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0Qm90dG9tIiwiaGVpZ2h0T2Zmc2V0UmF0aW8iLCJjZW50ZXJZIiwiZ2V0VG91Y2hDZW50ZXIiLCJ0b3VjaGVzIiwiY2FsY1NjYWxlIiwic3RhcnRUb3VjaCIsImVuZFRvdWNoIiwiY2FsY05ld1NjYWxlIiwidG8iLCJsYXN0U2NhbGUiLCJsYXN0VG91Y2hTdGFydCIsImNhbmNlbEV2ZW50IiwiZSIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiZGV0ZWN0RG91YmxlVGFwIiwidGltZSIsIkRhdGUiLCJnZXRUaW1lIiwiZXZlbnQiLCJnZXRUb3VjaGVzIiwicG9zaXRpb24iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3VjaCIsInBhZ2VYIiwibGVmdCIsImRvY3VtZW50IiwiYm9keSIsInNjcm9sbExlZnQiLCJwYWdlWSIsInRvcCIsInNjcm9sbFRvcCIsImdldERpc3RhbmNlIiwiZmlyc3QiLCJzZWNvbmQiLCJzcXJ0IiwibmV3U3BhbiIsImNyZWF0ZUVsZW1lbnQiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwibmV3Q29udGVudCIsImNyZWF0ZVRleHROb2RlIiwiYXBwZW5kQ2hpbGQiLCJ0YXJnZXQiLCJiYXNlU2NhbGUiLCJzbmFwQmFja1NwZWVkIiwiZWFzZSIsIml0ZW1zIiwicGluY2hJdCIsInRhcmdldHMiLCJvcHRpb25zIiwiZWxlbWVudHMiLCJzY2FsaW5nIiwic3RhcnRUb3VjaGVzIiwibGFzdFpvb21DZW50ZXIiLCJsYXN0RHJhZ1Bvc2l0aW9uIiwib24iLCJkaXNwYXRjaCIsImRpc3BhdGNoUGluY2hFdmVudCIsImV2ZW50TmFtZSIsInBoYXNlIiwiZGF0YSIsIk9iamVjdCIsImFzc2lnbiIsInJlc2V0R2xvYmFscyIsInVuZGVmaW5lZCIsIm9uVG91Y2hzdGFydCIsIkFycmF5IiwiZnJvbSIsIm9uVG91Y2htb3ZlIiwiZHJhZ09mZnNldCIsInRvdWNoQ2VudGVyIiwibmV3U2NhbGUiLCJvblRvdWNoZW5kIiwiaXNMZXNzVGhhbiIsImF0dGFjaEV2ZW50cyIsImFkZEV2ZW50TGlzdGVuZXIiLCJkZXRhY2hoRXZlbnRzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlc2V0Iiwib3B0IiwiaXRlbSIsImVhc2luZyIsImlzTmFOIiwiZm9yRWFjaCIsImRlc3Ryb3kiLCJzZXR1cCIsImlzQXJyYXkiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY29uc29sZSIsIndhcm4iLCJ0cmFuc2Zvcm0iLCJ0cmFuc2l0aW9uIiwidHJhbnNpdGlvbkVuZCIsImhhc1NjYWxlM2QiLCJzdHlsZSIsIndlYmtpdFRyYW5zaXRpb24iLCJ3ZWJraXRUcmFuc2Zvcm0iLCJtc1RyYW5zZm9ybSIsImluc2VydEJlZm9yZSIsImdsb2JhbCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicmVtb3ZlQ2hpbGQiLCJldmVudERpc3BhdGNoZXIiLCJldmVudHMiLCJoYW5kbGVyIiwicHVzaCIsIm9mZiIsImkiLCJzcGxpY2UiLCJmbiIsImNhbGNNYXgiLCJkaWZmZXIiLCJtYXhYIiwibWF4WSIsInNhbml0aXplT2Zmc2V0IiwibWF4T2Zmc2V0WCIsIm1heE9mZnNldFkiLCJtaW5PZmZzZXRYIiwibWluT2Zmc2V0WSIsImRyYWciLCJjZW50ZXIiLCJsYXN0Q2VudGVyIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwicHJlZml4ZXMiLCJoYW5kbGVBbmltYXRpb24iLCJkdXJhdGlvbiIsInRyYW5zZm9ybU9yaWdpbiIsInBpbmNoIiwiY29vcmRzIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJzY2FsZVByb3AiLCJ0cmFuc2xhdGVQcm9wIiwicGluY2hJbWFnZSIsInF1ZXJ5U2VsZWN0b3IiLCJoYW5kbGVFdmVudEV4YW1wbGUiLCJwaW5jaEV2ZW50Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDOURBOztBQUVBLElBQU1BLE1BQU0sU0FBTkEsR0FBTSxDQUFDQyxHQUFELEVBQU1DLElBQU47QUFBQSxTQUFlRCxNQUFNQyxJQUFyQjtBQUFBLENBQVo7O0FBRUE7Ozs7O0FBR0EsSUFBTUMsZUFBZSxTQUFmQSxZQUFlLENBQUNDLE9BQUQ7QUFBQSxTQUFxQztBQUN4REMsT0FBR0QsUUFBUUUsR0FBUixDQUFZO0FBQUEsYUFBTUMsRUFBRUYsQ0FBUjtBQUFBLEtBQVosRUFBd0JHLE1BQXhCLENBQStCUixHQUEvQixJQUFzQ0ksUUFBUUssTUFETztBQUV4REMsT0FBR04sUUFBUUUsR0FB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RUE7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0IsRUFBRTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFF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QSxtQkFBUSxrQkFBUjtBQUNBLG1CQUFRLGtCQUFSO0FBQ0EsbUJBQVEsbUJBQVIsRUFBNkI7QUFDM0JuSyxZQUFVLENBRGlCO0FBRTNCQyxZQUFVLEdBRmlCO0FBRzNCd0UsaUJBQWU7QUFIWSxDQUE3Qjs7QUFNQSxJQUFNNEYsYUFBYSxtQkFBUSxtQkFBUixFQUE2QjtBQUM5QzVGLGlCQUFlO0FBRCtCLENBQTdCLENBQW5COztBQUlBckIsU0FDR2tILGFBREgsQ0FDaUIsZUFEakIsRUFFRzlELGdCQUZILENBRW9CLE9BRnBCLEVBRTZCLFlBQU07QUFDL0I2RCxhQUFXMUQsS0FBWDtBQUNELENBSkg7O0FBTUEsSUFBTXBDLFNBQVNuQixTQUFTa0gsYUFBVCxDQUF1QixlQUF2QixDQUFmO0FBQ0EsSUFBTUMscUJBQXFCLDJCQUFZaEcsTUFBWixDQUEzQjtBQUNBLElBQU1pRyxhQUFhLG1CQUFRLG1CQUFSLEVBQTZCO0FBQzlDL0YsaUJBQWU7QUFEK0IsQ0FBN0IsQ0FBbkI7O0FBSUErRixXQUFXcEYsRUFBWCxDQUFjLFlBQWQsRUFBNEJtRixrQkFBNUI7QUFDQUMsV0FBV3BGLEVBQVgsQ0FBYyxXQUFkLEVBQTJCbUYsa0JBQTNCLEUiLCJmaWxlIjoiYnVuZGxlLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9qcy9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZjMyMGQyNmU4MzQwM2U1YzNlNDMiLCIvLyBAZmxvd1xuXG5pbXBvcnQgeyBnZXREaXN0YW5jZSwgZ2V0VG91Y2hlcyB9IGZyb20gJy4vaGFuZGxlLWV2ZW50JztcblxuY29uc3Qgc3VtID0gKGFjYywgbmV4dCkgPT4gYWNjICsgbmV4dDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhdmVyYWdlIG9mIG11bHRpcGxlIHZlY3RvcnMgKHgsIHkgdmFsdWVzKVxuICovXG5jb25zdCBnZXRWZWN0b3JBdmcgPSAodmVjdG9yczogQXJyYXk8T2JqZWN0Pik6IE9iamVjdCA9PiAoe1xuICB4OiB2ZWN0b3JzLm1hcCh2ID0+ICh2LngpKS5yZWR1Y2Uoc3VtKSAvIHZlY3RvcnMubGVuZ3RoLFxuICB5OiB2ZWN0b3JzLm1hcCh2ID0+ICh2LnkpKS5yZWR1Y2Uoc3VtKSAvIHZlY3RvcnMubGVuZ3RoLFxufSk7XG5cbmNvbnN0IGdldFBhcmVudEVsZW1lbnQgPSAodHlwZTogc3RyaW5nKSA9PiAoZWw6IEV2ZW50VGFyZ2V0KTogbnVtYmVyID0+IChcbiAgKGVsIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCAmJiBlbC5wYXJlbnRFbGVtZW50IGluc3RhbmNlb2YgSFRNTERpdkVsZW1lbnQpXG4gID8gZWwucGFyZW50RWxlbWVudFt0eXBlXVxuICA6IDFcbik7XG5cbi8qKlxuICogaXNXaXRoaW4gLSBDaGVjayBpZiB2YWx1ZSBpcyBiZXR3ZWVuIHR3byB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0geyBOdW1iZXIgfSBzY2FsZSBjdXJyZW50IHNjYWxlIHZhbHVlXG4gKiBAcGFyYW0geyBPYmplY3QgfSBtaW5QaW5jaCwgbWF4UGluaFxuICogQHJldHVybiB7IEJvb2xlYW4gfVxuICoqL1xuZXhwb3J0IGNvbnN0IGlzV2l0aGluID0gKHNjYWxlOiBudW1iZXIsIG9wdHM6IE9iamVjdCk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCB7IG1heFNjYWxlLCBtaW5TY2FsZSB9ID0gb3B0cztcbiAgcmV0dXJuIChzY2FsZSA+PSBtaW5TY2FsZSkgJiYgKHNjYWxlIDw9IG1heFNjYWxlKTtcbn07XG5cbi8qKlxuICogYWRkT2Zmc2V0IC0gQ29tYmluZSBjdXJyZW50IG9mZnNldCB3aXRoIG9sZCBvZmZzZXQgYW5kIHJldHVybnMgYSBuZXcgb2Zmc2V0XG4gKlxuICogQHBhcmFtIHsgT2JqZWN0IH0gbGFzdE9mZnNldCBsYXN0IG9mZnNldFxuICogQHBhcmFtIHsgT2JqZWN0IH0gb2Zmc2V0LCBuZXcgb2Zmc2V0XG4gKiBAcmV0dXJuIHsgT2JqZWN0IH1cbiAqKi9cbmV4cG9ydCBjb25zdCBhZGRPZmZzZXQgPSAobGFzdE9mZnNldDogT2JqZWN0LCBvZmZzZXQ6IE9iamVjdCk6IE9iamVjdCA9PiAoe1xuICB4OiBsYXN0T2Zmc2V0LnggKyBvZmZzZXQueCxcbiAgeTogbGFzdE9mZnNldC55ICsgb2Zmc2V0LnksXG59KTtcblxuZXhwb3J0IGNvbnN0IGdldFBhcmVudFggPSBnZXRQYXJlbnRFbGVtZW50KCdvZmZzZXRXaWR0aCcpO1xuZXhwb3J0IGNvbnN0IGdldFBhcmVudFkgPSBnZXRQYXJlbnRFbGVtZW50KCdvZmZzZXRIZWlnaHQnKTtcblxuLyoqXG4gKiBnZXRTY2FsZSAtIENoZWNrIGlmIHZhbHVlIGlzIGJldHdlZW4gdHdvIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7IE5vZGUgfSBlbCBjdXJyZW50IHNjYWxlIHZhbHVlXG4gKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAqKi9cbmV4cG9ydCBjb25zdCBnZXRJbml0aWFsU2NhbGUgPSAoZWw6IEV2ZW50VGFyZ2V0KTogbnVtYmVyID0+IChcbiAgKGVsIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudClcbiAgPyBnZXRQYXJlbnRYKGVsKSAvIGVsLm9mZnNldFdpZHRoXG4gIDogMVxuKTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIHpvb20gZmFjdG9yIHJlbGF0aXZlIHRvIGN1cnJlbnQgc3RhdGVcbiAqXG4gKiBAcGFyYW0gc2NhbGVcbiAqIEByZXR1cm4gdGhlIGFjdHVhbCBzY2FsZSAoY2FuIGRpZmZlciBiZWNhdXNlIG9mIG1heCBtaW4gem9vbSBmYWN0b3IpXG4gKi9cbmV4cG9ydCBjb25zdCBzY2FsZUZhY3RvciA9IChzY2FsZTogbnVtYmVyLCBmYWN0b3I6IG51bWJlciwgb3B0czogT2JqZWN0KTogT2JqZWN0ID0+IHtcbiAgY29uc3Qgb3JpZ2luYWxGYWN0b3IgPSBmYWN0b3I7XG4gIGxldCB6b29tRmFjdG9yID0gZmFjdG9yICogc2NhbGU7XG4gIGNvbnN0IHsgbWF4U2NhbGVUaW1lcywgbWluU2NhbGVUaW1lcyB9ID0gb3B0cztcbiAgem9vbUZhY3RvciA9IE1hdGgubWluKG1heFNjYWxlVGltZXMsIE1hdGgubWF4KHpvb21GYWN0b3IsIG1pblNjYWxlVGltZXMpKTtcbiAgcmV0dXJuIHtcbiAgICB6b29tRmFjdG9yLFxuICAgIHNjYWxlOiB6b29tRmFjdG9yIC8gb3JpZ2luYWxGYWN0b3IsXG4gIH07XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHZpcnR1YWwgem9vbSBjZW50ZXIgZm9yIHRoZSBjdXJyZW50IG9mZnNldCBhbmQgem9vbSBmYWN0b3JcbiAqICh1c2VkIGZvciByZXZlcnNlIHpvb20pXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBjdXJyZW50IHpvb20gY2VudGVyXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDdXJyZW50UGluY2hDZW50ZXIgPSAoZWw6IEV2ZW50VGFyZ2V0LCB6b29tRmFjdG9yOiBudW1iZXIsIG9mZnNldDogT2JqZWN0KTogT2JqZWN0ID0+IHtcbiAgY29uc3QgbGVuZ3RoID0gZ2V0UGFyZW50WChlbCkgKiB6b29tRmFjdG9yO1xuICBjb25zdCBvZmZzZXRMZWZ0ID0gb2Zmc2V0Lng7XG4gIGNvbnN0IG9mZnNldFJpZ2h0ID0gbGVuZ3RoIC0gb2Zmc2V0TGVmdCAtIGdldFBhcmVudFgoZWwpO1xuICBjb25zdCB3aWR0aE9mZnNldFJhdGlvID0gb2Zmc2V0TGVmdCAvIG9mZnNldFJpZ2h0O1xuICBsZXQgY2VudGVyWCA9ICh3aWR0aE9mZnNldFJhdGlvICogZ2V0UGFyZW50WChlbCkpIC8gKHdpZHRoT2Zmc2V0UmF0aW8gKyAxKTtcblxuICAvLyB0aGUgc2FtZSBmb3IgdGhlIHpvb21jZW50ZXIgeVxuICBjb25zdCBoZWlnaHQgPSBnZXRQYXJlbnRZKGVsKSAqIHpvb21GYWN0b3I7XG4gIGNvbnN0IG9mZnNldFRvcCA9IG9mZnNldC55O1xuICBjb25zdCBvZmZzZXRCb3R0b20gPSBoZWlnaHQgLSBvZmZzZXRUb3AgLSBnZXRQYXJlbnRZKGVsKTtcbiAgY29uc3QgaGVpZ2h0T2Zmc2V0UmF0aW8gPSBvZmZzZXRUb3AgLyBvZmZzZXRCb3R0b207XG4gIGxldCBjZW50ZXJZID0gKGhlaWdodE9mZnNldFJhdGlvICogZ2V0UGFyZW50WShlbCkpIC8gKGhlaWdodE9mZnNldFJhdGlvICsgMSk7XG5cbiAgLy8gcHJldmVudHMgZGl2aXNpb24gYnkgemVyb1xuICBpZiAob2Zmc2V0UmlnaHQgPT09IDApIHsgY2VudGVyWCA9IGdldFBhcmVudFgoZWwpOyB9XG4gIGlmIChvZmZzZXRCb3R0b20gPT09IDApIHsgY2VudGVyWSA9IGdldFBhcmVudFkoZWwpOyB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBjZW50ZXJYLFxuICAgIHk6IGNlbnRlclksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VG91Y2hDZW50ZXIgPSAodG91Y2hlczogQXJyYXk8T2JqZWN0PikgPT4gZ2V0VmVjdG9yQXZnKHRvdWNoZXMpO1xuXG4vKipcbiAqIGNhbGNTY2FsZSAtIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB3aGVyZSB3ZSBzdGFydCBvdXIgcGluY2hcbiAqIHRvIHdoZXJlIHdlIGVuZCBpdFxuICpcbiAqIEBwYXJhbSB7IEFycmF5IH0gc3RhcnRUb3VjaCBUaGUgc3RhcnRpbmcgcG9pbnQgb2Ygb3VyIHRvdWNoXG4gKiBAcGFyYW0geyBBcnJheSB9IGVuZFRvdWNoIFRoZSBjdXJyZW50IHBvaW50IG9mIG91ciB0b3VjaFxuICogQHJldHVybiB7IE51bWJlciB9XG4gKi9cbmV4cG9ydCBjb25zdCBjYWxjU2NhbGUgPSAoZWw6IEV2ZW50VGFyZ2V0LCBzdGFydFRvdWNoOiBBcnJheTxPYmplY3Q+LCBlbmRUb3VjaDogQXJyYXk8T2JqZWN0Pik6IG51bWJlciA9PiAoXG4gIGdldERpc3RhbmNlKGdldFRvdWNoZXMoZWwsIGVuZFRvdWNoKSkgLyBnZXREaXN0YW5jZShnZXRUb3VjaGVzKGVsLCBzdGFydFRvdWNoKSlcbik7XG5cbmV4cG9ydCBjb25zdCBjYWxjTmV3U2NhbGUgPSAodG86IG51bWJlciwgbGFzdFNjYWxlOiBudW1iZXIgPSAxKTogbnVtYmVyID0+IChcbiAgdG8gLyBsYXN0U2NhbGVcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvaGFuZGxlLXBpbmNoLmpzIiwiLy8gQGZsb3dcbmxldCBsYXN0VG91Y2hTdGFydCA9IDA7XG5cbnR5cGUgVG9jaFBhZ2UgPSB7XG4gIHBhZ2VYOiBudW1iZXI7XG4gIHBhZ2VZOiBudW1iZXI7XG59XG5cbnR5cGUgVG91Y2ggPSB7XG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBjYW5jZWxFdmVudCAtIENhbmNlbCBFdmVudHMgc28gd2UgZG9udCBidWJibGUgdXAgb3VyIGV2ZW50cyB0byB0aGUgZG9jdW1lbnRcbiAqXG4gKiBAcGFyYW0geyBPYmplY3QgfSBldmVudFxuICogQHJldHVybiB7IFZvaWQgfVxuICoqL1xuZXhwb3J0IGNvbnN0IGNhbmNlbEV2ZW50ID0gKGU6IEV2ZW50KTogdm9pZCA9PiB7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn07XG5cbi8qKlxuICogZGV0ZWN0RG91YmxlVGFwIC0gQ2hlY2sgaWYgd2UgYXJlIGRvdWJsZSB0YXBwaW5nXG4gKlxuICogQHBhcmFtIHsgT2JqZWN0IH0gZXZlbnRcbiAqIEByZXR1cm4geyBCb29sZWFuIH1cbiAqKi9cbmV4cG9ydCBjb25zdCBkZXRlY3REb3VibGVUYXAgPSAoZTogVG91Y2hFdmVudCk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCB0aW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICBsYXN0VG91Y2hTdGFydCA9IDA7XG4gIH1cblxuICBpZiAodGltZSAtIGxhc3RUb3VjaFN0YXJ0IDwgMzAwKSB7XG4gICAgY2FuY2VsRXZlbnQoZXZlbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICBsYXN0VG91Y2hTdGFydCA9IHRpbWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0b3VjaGVzIG9mIGFuIGV2ZW50IHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgb2Zmc2V0XG4gKlxuICogQHBhcmFtIGV2ZW50XG4gKiBAcmV0dXJuIGFycmF5IHRvdWNoZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFRvdWNoZXMgPSAoZWw6IEV2ZW50VGFyZ2V0LCB0b3VjaGVzOiBBcnJheTxUb2NoUGFnZT4pOiBBcnJheTxUb3VjaD4gPT4ge1xuICBjb25zdCBwb3NpdGlvbiA9IGVsLnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB0b3VjaGVzLm1hcCh0b3VjaCA9PiAoe1xuICAgIHg6IHRvdWNoLnBhZ2VYIC0gKHBvc2l0aW9uLmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQpLFxuICAgIHk6IHRvdWNoLnBhZ2VZIC0gKHBvc2l0aW9uLnRvcCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKSxcbiAgfSkpO1xufTtcblxuLyoqXG4gKiBnZXREaXN0YW5jZSAtIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBvdXIgZmluZ2Vyc1xuICpcbiAqIEBwYXJhbSB7IEFycmF5IH0gdG91Y2hlcyB0b3VjaGVzIHBhc3NhcyBhbiBhcnJheSBmcm9tIFRvdWNoTGlzdFxuICogQHJldHVybiB7IE51bWJlciB9IHRoZSBjYWxjdWFsdGVkIGRpc3RhbmNlIGJldHdlZW4gdGhlIGZpbmdlcnNcbiAqKi9cbmV4cG9ydCBjb25zdCBnZXREaXN0YW5jZSA9ICh0b3VjaGVzOiBBcnJheTxUb3VjaD4pOiBudW1iZXIgPT4ge1xuICBjb25zdCBbZmlyc3QsIHNlY29uZF0gPSB0b3VjaGVzO1xuICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICgoZmlyc3QueCAtIHNlY29uZC54KSAqIChmaXJzdC54IC0gc2Vjb25kLngpKSArXG4gICAgKChmaXJzdC55IC0gc2Vjb25kLnkpICogKGZpcnN0LnkgLSBzZWNvbmQueSkpXG4gICk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL2hhbmRsZS1ldmVudC5qcyIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZGVmYXVsdCB0YXJnZXQgPT4gKGUpID0+IHtcbiAgY29uc3QgbmV3U3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgbGV0IHRpbWUgPSBuZXcgRGF0ZSgpO1xuICB0aW1lID0gdGltZS5nZXRIb3VycygpICsgJzonICsgdGltZS5nZXRNaW51dGVzKCkgKyAnOicgKyB0aW1lLmdldFNlY29uZHMoKSArICcsJyArIHRpbWUuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gIGNvbnN0IG5ld0NvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnWycgKyB0aW1lICsgJ10gRXZlbnQgZGlzcGF0Y2hlZDogXCInICsgZS50eXBlICsgJ1wiJyk7XG4gIG5ld1NwYW4uYXBwZW5kQ2hpbGQobmV3Q29udGVudCk7XG4gIHRhcmdldC5hcHBlbmRDaGlsZChuZXdTcGFuKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9kb2NzL2hhbmRsZS1ldmVudC5qcyIsImltcG9ydCBwaW5jaEl0IGZyb20gJy4vcGluY2gtaXQnO1xuXG5leHBvcnQgZGVmYXVsdCBwaW5jaEl0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2luZGV4LmpzIiwiXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNvcmUuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxudmFyIF9zZWxmID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuXHQ/IHdpbmRvdyAgIC8vIGlmIGluIGJyb3dzZXJcblx0OiAoXG5cdFx0KHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKVxuXHRcdD8gc2VsZiAvLyBpZiBpbiB3b3JrZXJcblx0XHQ6IHt9ICAgLy8gaWYgaW4gbm9kZSBqc1xuXHQpO1xuXG4vKipcbiAqIFByaXNtOiBMaWdodHdlaWdodCwgcm9idXN0LCBlbGVnYW50IHN5bnRheCBoaWdobGlnaHRpbmdcbiAqIE1JVCBsaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwL1xuICogQGF1dGhvciBMZWEgVmVyb3UgaHR0cDovL2xlYS52ZXJvdS5tZVxuICovXG5cbnZhciBQcmlzbSA9IChmdW5jdGlvbigpe1xuXG4vLyBQcml2YXRlIGhlbHBlciB2YXJzXG52YXIgbGFuZyA9IC9cXGJsYW5nKD86dWFnZSk/LShcXHcrKVxcYi9pO1xudmFyIHVuaXF1ZUlkID0gMDtcblxudmFyIF8gPSBfc2VsZi5QcmlzbSA9IHtcblx0dXRpbDoge1xuXHRcdGVuY29kZTogZnVuY3Rpb24gKHRva2Vucykge1xuXHRcdFx0aWYgKHRva2VucyBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgVG9rZW4odG9rZW5zLnR5cGUsIF8udXRpbC5lbmNvZGUodG9rZW5zLmNvbnRlbnQpLCB0b2tlbnMuYWxpYXMpO1xuXHRcdFx0fSBlbHNlIGlmIChfLnV0aWwudHlwZSh0b2tlbnMpID09PSAnQXJyYXknKSB7XG5cdFx0XHRcdHJldHVybiB0b2tlbnMubWFwKF8udXRpbC5lbmNvZGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRva2Vucy5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC9cXHUwMGEwL2csICcgJyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHR5cGU6IGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLm1hdGNoKC9cXFtvYmplY3QgKFxcdyspXFxdLylbMV07XG5cdFx0fSxcblxuXHRcdG9iaklkOiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRpZiAoIW9ialsnX19pZCddKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICdfX2lkJywgeyB2YWx1ZTogKyt1bmlxdWVJZCB9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmpbJ19faWQnXTtcblx0XHR9LFxuXG5cdFx0Ly8gRGVlcCBjbG9uZSBhIGxhbmd1YWdlIGRlZmluaXRpb24gKGUuZy4gdG8gZXh0ZW5kIGl0KVxuXHRcdGNsb25lOiBmdW5jdGlvbiAobykge1xuXHRcdFx0dmFyIHR5cGUgPSBfLnV0aWwudHlwZShvKTtcblxuXHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRcdFx0dmFyIGNsb25lID0ge307XG5cblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbykge1xuXHRcdFx0XHRcdFx0aWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0XHRjbG9uZVtrZXldID0gXy51dGlsLmNsb25lKG9ba2V5XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGNsb25lO1xuXG5cdFx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0XHQvLyBDaGVjayBmb3IgZXhpc3RlbmNlIGZvciBJRThcblx0XHRcdFx0XHRyZXR1cm4gby5tYXAgJiYgby5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gXy51dGlsLmNsb25lKHYpOyB9KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG87XG5cdFx0fVxuXHR9LFxuXG5cdGxhbmd1YWdlczoge1xuXHRcdGV4dGVuZDogZnVuY3Rpb24gKGlkLCByZWRlZikge1xuXHRcdFx0dmFyIGxhbmcgPSBfLnV0aWwuY2xvbmUoXy5sYW5ndWFnZXNbaWRdKTtcblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIHJlZGVmKSB7XG5cdFx0XHRcdGxhbmdba2V5XSA9IHJlZGVmW2tleV07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBsYW5nO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBJbnNlcnQgYSB0b2tlbiBiZWZvcmUgYW5vdGhlciB0b2tlbiBpbiBhIGxhbmd1YWdlIGxpdGVyYWxcblx0XHQgKiBBcyB0aGlzIG5lZWRzIHRvIHJlY3JlYXRlIHRoZSBvYmplY3QgKHdlIGNhbm5vdCBhY3R1YWxseSBpbnNlcnQgYmVmb3JlIGtleXMgaW4gb2JqZWN0IGxpdGVyYWxzKSxcblx0XHQgKiB3ZSBjYW5ub3QganVzdCBwcm92aWRlIGFuIG9iamVjdCwgd2UgbmVlZCBhbm9iamVjdCBhbmQgYSBrZXkuXG5cdFx0ICogQHBhcmFtIGluc2lkZSBUaGUga2V5IChvciBsYW5ndWFnZSBpZCkgb2YgdGhlIHBhcmVudFxuXHRcdCAqIEBwYXJhbSBiZWZvcmUgVGhlIGtleSB0byBpbnNlcnQgYmVmb3JlLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBmdW5jdGlvbiBhcHBlbmRzIGluc3RlYWQuXG5cdFx0ICogQHBhcmFtIGluc2VydCBPYmplY3Qgd2l0aCB0aGUga2V5L3ZhbHVlIHBhaXJzIHRvIGluc2VydFxuXHRcdCAqIEBwYXJhbSByb290IFRoZSBvYmplY3QgdGhhdCBjb250YWlucyBgaW5zaWRlYC4gSWYgZXF1YWwgdG8gUHJpc20ubGFuZ3VhZ2VzLCBpdCBjYW4gYmUgb21pdHRlZC5cblx0XHQgKi9cblx0XHRpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChpbnNpZGUsIGJlZm9yZSwgaW5zZXJ0LCByb290KSB7XG5cdFx0XHRyb290ID0gcm9vdCB8fCBfLmxhbmd1YWdlcztcblx0XHRcdHZhciBncmFtbWFyID0gcm9vdFtpbnNpZGVdO1xuXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG5cdFx0XHRcdGluc2VydCA9IGFyZ3VtZW50c1sxXTtcblxuXHRcdFx0XHRmb3IgKHZhciBuZXdUb2tlbiBpbiBpbnNlcnQpIHtcblx0XHRcdFx0XHRpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuXHRcdFx0XHRcdFx0Z3JhbW1hcltuZXdUb2tlbl0gPSBpbnNlcnRbbmV3VG9rZW5dO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBncmFtbWFyO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmV0ID0ge307XG5cblx0XHRcdGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcblxuXHRcdFx0XHRpZiAoZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcblxuXHRcdFx0XHRcdGlmICh0b2tlbiA9PSBiZWZvcmUpIHtcblxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgbmV3VG9rZW4gaW4gaW5zZXJ0KSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGluc2VydC5oYXNPd25Qcm9wZXJ0eShuZXdUb2tlbikpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXRbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldFt0b2tlbl0gPSBncmFtbWFyW3Rva2VuXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgcmVmZXJlbmNlcyBpbiBvdGhlciBsYW5ndWFnZSBkZWZpbml0aW9uc1xuXHRcdFx0Xy5sYW5ndWFnZXMuREZTKF8ubGFuZ3VhZ2VzLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gcm9vdFtpbnNpZGVdICYmIGtleSAhPSBpbnNpZGUpIHtcblx0XHRcdFx0XHR0aGlzW2tleV0gPSByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gcm9vdFtpbnNpZGVdID0gcmV0O1xuXHRcdH0sXG5cblx0XHQvLyBUcmF2ZXJzZSBhIGxhbmd1YWdlIGRlZmluaXRpb24gd2l0aCBEZXB0aCBGaXJzdCBTZWFyY2hcblx0XHRERlM6IGZ1bmN0aW9uKG8sIGNhbGxiYWNrLCB0eXBlLCB2aXNpdGVkKSB7XG5cdFx0XHR2aXNpdGVkID0gdmlzaXRlZCB8fCB7fTtcblx0XHRcdGZvciAodmFyIGkgaW4gbykge1xuXHRcdFx0XHRpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwobywgaSwgb1tpXSwgdHlwZSB8fCBpKTtcblxuXHRcdFx0XHRcdGlmIChfLnV0aWwudHlwZShvW2ldKSA9PT0gJ09iamVjdCcgJiYgIXZpc2l0ZWRbXy51dGlsLm9iaklkKG9baV0pXSkge1xuXHRcdFx0XHRcdFx0dmlzaXRlZFtfLnV0aWwub2JqSWQob1tpXSldID0gdHJ1ZTtcblx0XHRcdFx0XHRcdF8ubGFuZ3VhZ2VzLkRGUyhvW2ldLCBjYWxsYmFjaywgbnVsbCwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKF8udXRpbC50eXBlKG9baV0pID09PSAnQXJyYXknICYmICF2aXNpdGVkW18udXRpbC5vYmpJZChvW2ldKV0pIHtcblx0XHRcdFx0XHRcdHZpc2l0ZWRbXy51dGlsLm9iaklkKG9baV0pXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRfLmxhbmd1YWdlcy5ERlMob1tpXSwgY2FsbGJhY2ssIGksIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0cGx1Z2luczoge30sXG5cblx0aGlnaGxpZ2h0QWxsOiBmdW5jdGlvbihhc3luYywgY2FsbGJhY2spIHtcblx0XHR2YXIgZW52ID0ge1xuXHRcdFx0Y2FsbGJhY2s6IGNhbGxiYWNrLFxuXHRcdFx0c2VsZWN0b3I6ICdjb2RlW2NsYXNzKj1cImxhbmd1YWdlLVwiXSwgW2NsYXNzKj1cImxhbmd1YWdlLVwiXSBjb2RlLCBjb2RlW2NsYXNzKj1cImxhbmctXCJdLCBbY2xhc3MqPVwibGFuZy1cIl0gY29kZSdcblx0XHR9O1xuXG5cdFx0Xy5ob29rcy5ydW4oXCJiZWZvcmUtaGlnaGxpZ2h0YWxsXCIsIGVudik7XG5cblx0XHR2YXIgZWxlbWVudHMgPSBlbnYuZWxlbWVudHMgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlbnYuc2VsZWN0b3IpO1xuXG5cdFx0Zm9yICh2YXIgaT0wLCBlbGVtZW50OyBlbGVtZW50ID0gZWxlbWVudHNbaSsrXTspIHtcblx0XHRcdF8uaGlnaGxpZ2h0RWxlbWVudChlbGVtZW50LCBhc3luYyA9PT0gdHJ1ZSwgZW52LmNhbGxiYWNrKTtcblx0XHR9XG5cdH0sXG5cblx0aGlnaGxpZ2h0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgYXN5bmMsIGNhbGxiYWNrKSB7XG5cdFx0Ly8gRmluZCBsYW5ndWFnZVxuXHRcdHZhciBsYW5ndWFnZSwgZ3JhbW1hciwgcGFyZW50ID0gZWxlbWVudDtcblxuXHRcdHdoaWxlIChwYXJlbnQgJiYgIWxhbmcudGVzdChwYXJlbnQuY2xhc3NOYW1lKSkge1xuXHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0bGFuZ3VhZ2UgPSAocGFyZW50LmNsYXNzTmFtZS5tYXRjaChsYW5nKSB8fCBbLCcnXSlbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdGdyYW1tYXIgPSBfLmxhbmd1YWdlc1tsYW5ndWFnZV07XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IGxhbmd1YWdlIG9uIHRoZSBlbGVtZW50LCBpZiBub3QgcHJlc2VudFxuXHRcdGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShsYW5nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpICsgJyBsYW5ndWFnZS0nICsgbGFuZ3VhZ2U7XG5cblx0XHQvLyBTZXQgbGFuZ3VhZ2Ugb24gdGhlIHBhcmVudCwgZm9yIHN0eWxpbmdcblx0XHRwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cblx0XHRpZiAoL3ByZS9pLnRlc3QocGFyZW50Lm5vZGVOYW1lKSkge1xuXHRcdFx0cGFyZW50LmNsYXNzTmFtZSA9IHBhcmVudC5jbGFzc05hbWUucmVwbGFjZShsYW5nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpICsgJyBsYW5ndWFnZS0nICsgbGFuZ3VhZ2U7XG5cdFx0fVxuXG5cdFx0dmFyIGNvZGUgPSBlbGVtZW50LnRleHRDb250ZW50O1xuXG5cdFx0dmFyIGVudiA9IHtcblx0XHRcdGVsZW1lbnQ6IGVsZW1lbnQsXG5cdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2UsXG5cdFx0XHRncmFtbWFyOiBncmFtbWFyLFxuXHRcdFx0Y29kZTogY29kZVxuXHRcdH07XG5cblx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLXNhbml0eS1jaGVjaycsIGVudik7XG5cblx0XHRpZiAoIWVudi5jb2RlIHx8ICFlbnYuZ3JhbW1hcikge1xuXHRcdFx0aWYgKGVudi5jb2RlKSB7XG5cdFx0XHRcdGVudi5lbGVtZW50LnRleHRDb250ZW50ID0gZW52LmNvZGU7XG5cdFx0XHR9XG5cdFx0XHRfLmhvb2tzLnJ1bignY29tcGxldGUnLCBlbnYpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdF8uaG9va3MucnVuKCdiZWZvcmUtaGlnaGxpZ2h0JywgZW52KTtcblxuXHRcdGlmIChhc3luYyAmJiBfc2VsZi5Xb3JrZXIpIHtcblx0XHRcdHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKF8uZmlsZW5hbWUpO1xuXG5cdFx0XHR3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHRcdGVudi5oaWdobGlnaHRlZENvZGUgPSBldnQuZGF0YTtcblxuXHRcdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWluc2VydCcsIGVudik7XG5cblx0XHRcdFx0ZW52LmVsZW1lbnQuaW5uZXJIVE1MID0gZW52LmhpZ2hsaWdodGVkQ29kZTtcblxuXHRcdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVudi5lbGVtZW50KTtcblx0XHRcdFx0Xy5ob29rcy5ydW4oJ2FmdGVyLWhpZ2hsaWdodCcsIGVudik7XG5cdFx0XHRcdF8uaG9va3MucnVuKCdjb21wbGV0ZScsIGVudik7XG5cdFx0XHR9O1xuXG5cdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuXHRcdFx0XHRsYW5ndWFnZTogZW52Lmxhbmd1YWdlLFxuXHRcdFx0XHRjb2RlOiBlbnYuY29kZSxcblx0XHRcdFx0aW1tZWRpYXRlQ2xvc2U6IHRydWVcblx0XHRcdH0pKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRlbnYuaGlnaGxpZ2h0ZWRDb2RlID0gXy5oaWdobGlnaHQoZW52LmNvZGUsIGVudi5ncmFtbWFyLCBlbnYubGFuZ3VhZ2UpO1xuXG5cdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWluc2VydCcsIGVudik7XG5cblx0XHRcdGVudi5lbGVtZW50LmlubmVySFRNTCA9IGVudi5oaWdobGlnaHRlZENvZGU7XG5cblx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZWxlbWVudCk7XG5cblx0XHRcdF8uaG9va3MucnVuKCdhZnRlci1oaWdobGlnaHQnLCBlbnYpO1xuXHRcdFx0Xy5ob29rcy5ydW4oJ2NvbXBsZXRlJywgZW52KTtcblx0XHR9XG5cdH0sXG5cblx0aGlnaGxpZ2h0OiBmdW5jdGlvbiAodGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcblx0XHR2YXIgdG9rZW5zID0gXy50b2tlbml6ZSh0ZXh0LCBncmFtbWFyKTtcblx0XHRyZXR1cm4gVG9rZW4uc3RyaW5naWZ5KF8udXRpbC5lbmNvZGUodG9rZW5zKSwgbGFuZ3VhZ2UpO1xuXHR9LFxuXG5cdHRva2VuaXplOiBmdW5jdGlvbih0ZXh0LCBncmFtbWFyLCBsYW5ndWFnZSkge1xuXHRcdHZhciBUb2tlbiA9IF8uVG9rZW47XG5cblx0XHR2YXIgc3RyYXJyID0gW3RleHRdO1xuXG5cdFx0dmFyIHJlc3QgPSBncmFtbWFyLnJlc3Q7XG5cblx0XHRpZiAocmVzdCkge1xuXHRcdFx0Zm9yICh2YXIgdG9rZW4gaW4gcmVzdCkge1xuXHRcdFx0XHRncmFtbWFyW3Rva2VuXSA9IHJlc3RbdG9rZW5dO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWxldGUgZ3JhbW1hci5yZXN0O1xuXHRcdH1cblxuXHRcdHRva2VubG9vcDogZm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuXHRcdFx0aWYoIWdyYW1tYXIuaGFzT3duUHJvcGVydHkodG9rZW4pIHx8ICFncmFtbWFyW3Rva2VuXSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHBhdHRlcm5zID0gZ3JhbW1hclt0b2tlbl07XG5cdFx0XHRwYXR0ZXJucyA9IChfLnV0aWwudHlwZShwYXR0ZXJucykgPT09IFwiQXJyYXlcIikgPyBwYXR0ZXJucyA6IFtwYXR0ZXJuc107XG5cblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgcGF0dGVybnMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0dmFyIHBhdHRlcm4gPSBwYXR0ZXJuc1tqXSxcblx0XHRcdFx0XHRpbnNpZGUgPSBwYXR0ZXJuLmluc2lkZSxcblx0XHRcdFx0XHRsb29rYmVoaW5kID0gISFwYXR0ZXJuLmxvb2tiZWhpbmQsXG5cdFx0XHRcdFx0Z3JlZWR5ID0gISFwYXR0ZXJuLmdyZWVkeSxcblx0XHRcdFx0XHRsb29rYmVoaW5kTGVuZ3RoID0gMCxcblx0XHRcdFx0XHRhbGlhcyA9IHBhdHRlcm4uYWxpYXM7XG5cblx0XHRcdFx0aWYgKGdyZWVkeSAmJiAhcGF0dGVybi5wYXR0ZXJuLmdsb2JhbCkge1xuXHRcdFx0XHRcdC8vIFdpdGhvdXQgdGhlIGdsb2JhbCBmbGFnLCBsYXN0SW5kZXggd29uJ3Qgd29ya1xuXHRcdFx0XHRcdHZhciBmbGFncyA9IHBhdHRlcm4ucGF0dGVybi50b1N0cmluZygpLm1hdGNoKC9baW11eV0qJC8pWzBdO1xuXHRcdFx0XHRcdHBhdHRlcm4ucGF0dGVybiA9IFJlZ0V4cChwYXR0ZXJuLnBhdHRlcm4uc291cmNlLCBmbGFncyArIFwiZ1wiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBhdHRlcm4gPSBwYXR0ZXJuLnBhdHRlcm4gfHwgcGF0dGVybjtcblxuXHRcdFx0XHQvLyBEb27igJl0IGNhY2hlIGxlbmd0aCBhcyBpdCBjaGFuZ2VzIGR1cmluZyB0aGUgbG9vcFxuXHRcdFx0XHRmb3IgKHZhciBpPTAsIHBvcyA9IDA7IGk8c3RyYXJyLmxlbmd0aDsgcG9zICs9IHN0cmFycltpXS5sZW5ndGgsICsraSkge1xuXG5cdFx0XHRcdFx0dmFyIHN0ciA9IHN0cmFycltpXTtcblxuXHRcdFx0XHRcdGlmIChzdHJhcnIubGVuZ3RoID4gdGV4dC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdC8vIFNvbWV0aGluZyB3ZW50IHRlcnJpYmx5IHdyb25nLCBBQk9SVCwgQUJPUlQhXG5cdFx0XHRcdFx0XHRicmVhayB0b2tlbmxvb3A7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHN0ciBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG5cblx0XHRcdFx0XHR2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyKSxcblx0XHRcdFx0XHQgICAgZGVsTnVtID0gMTtcblxuXHRcdFx0XHRcdC8vIEdyZWVkeSBwYXR0ZXJucyBjYW4gb3ZlcnJpZGUvcmVtb3ZlIHVwIHRvIHR3byBwcmV2aW91c2x5IG1hdGNoZWQgdG9rZW5zXG5cdFx0XHRcdFx0aWYgKCFtYXRjaCAmJiBncmVlZHkgJiYgaSAhPSBzdHJhcnIubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0cGF0dGVybi5sYXN0SW5kZXggPSBwb3M7XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHBhdHRlcm4uZXhlYyh0ZXh0KTtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBmcm9tID0gbWF0Y2guaW5kZXggKyAobG9va2JlaGluZCA/IG1hdGNoWzFdLmxlbmd0aCA6IDApLFxuXHRcdFx0XHRcdFx0ICAgIHRvID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgsXG5cdFx0XHRcdFx0XHQgICAgayA9IGksXG5cdFx0XHRcdFx0XHQgICAgcCA9IHBvcztcblxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgbGVuID0gc3RyYXJyLmxlbmd0aDsgayA8IGxlbiAmJiBwIDwgdG87ICsraykge1xuXHRcdFx0XHRcdFx0XHRwICs9IHN0cmFycltrXS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdC8vIE1vdmUgdGhlIGluZGV4IGkgdG8gdGhlIGVsZW1lbnQgaW4gc3RyYXJyIHRoYXQgaXMgY2xvc2VzdCB0byBmcm9tXG5cdFx0XHRcdFx0XHRcdGlmIChmcm9tID49IHApIHtcblx0XHRcdFx0XHRcdFx0XHQrK2k7XG5cdFx0XHRcdFx0XHRcdFx0cG9zID0gcDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdFx0ICogSWYgc3RyYXJyW2ldIGlzIGEgVG9rZW4sIHRoZW4gdGhlIG1hdGNoIHN0YXJ0cyBpbnNpZGUgYW5vdGhlciBUb2tlbiwgd2hpY2ggaXMgaW52YWxpZFxuXHRcdFx0XHRcdFx0ICogSWYgc3RyYXJyW2sgLSAxXSBpcyBncmVlZHkgd2UgYXJlIGluIGNvbmZsaWN0IHdpdGggYW5vdGhlciBncmVlZHkgcGF0dGVyblxuXHRcdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0XHRpZiAoc3RyYXJyW2ldIGluc3RhbmNlb2YgVG9rZW4gfHwgc3RyYXJyW2sgLSAxXS5ncmVlZHkpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE51bWJlciBvZiB0b2tlbnMgdG8gZGVsZXRlIGFuZCByZXBsYWNlIHdpdGggdGhlIG5ldyBtYXRjaFxuXHRcdFx0XHRcdFx0ZGVsTnVtID0gayAtIGk7XG5cdFx0XHRcdFx0XHRzdHIgPSB0ZXh0LnNsaWNlKHBvcywgcCk7XG5cdFx0XHRcdFx0XHRtYXRjaC5pbmRleCAtPSBwb3M7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCFtYXRjaCkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYobG9va2JlaGluZCkge1xuXHRcdFx0XHRcdFx0bG9va2JlaGluZExlbmd0aCA9IG1hdGNoWzFdLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgZnJvbSA9IG1hdGNoLmluZGV4ICsgbG9va2JlaGluZExlbmd0aCxcblx0XHRcdFx0XHQgICAgbWF0Y2ggPSBtYXRjaFswXS5zbGljZShsb29rYmVoaW5kTGVuZ3RoKSxcblx0XHRcdFx0XHQgICAgdG8gPSBmcm9tICsgbWF0Y2gubGVuZ3RoLFxuXHRcdFx0XHRcdCAgICBiZWZvcmUgPSBzdHIuc2xpY2UoMCwgZnJvbSksXG5cdFx0XHRcdFx0ICAgIGFmdGVyID0gc3RyLnNsaWNlKHRvKTtcblxuXHRcdFx0XHRcdHZhciBhcmdzID0gW2ksIGRlbE51bV07XG5cblx0XHRcdFx0XHRpZiAoYmVmb3JlKSB7XG5cdFx0XHRcdFx0XHRhcmdzLnB1c2goYmVmb3JlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgd3JhcHBlZCA9IG5ldyBUb2tlbih0b2tlbiwgaW5zaWRlPyBfLnRva2VuaXplKG1hdGNoLCBpbnNpZGUpIDogbWF0Y2gsIGFsaWFzLCBtYXRjaCwgZ3JlZWR5KTtcblxuXHRcdFx0XHRcdGFyZ3MucHVzaCh3cmFwcGVkKTtcblxuXHRcdFx0XHRcdGlmIChhZnRlcikge1xuXHRcdFx0XHRcdFx0YXJncy5wdXNoKGFmdGVyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KHN0cmFyciwgYXJncyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyYXJyO1xuXHR9LFxuXG5cdGhvb2tzOiB7XG5cdFx0YWxsOiB7fSxcblxuXHRcdGFkZDogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgaG9va3MgPSBfLmhvb2tzLmFsbDtcblxuXHRcdFx0aG9va3NbbmFtZV0gPSBob29rc1tuYW1lXSB8fCBbXTtcblxuXHRcdFx0aG9va3NbbmFtZV0ucHVzaChjYWxsYmFjayk7XG5cdFx0fSxcblxuXHRcdHJ1bjogZnVuY3Rpb24gKG5hbWUsIGVudikge1xuXHRcdFx0dmFyIGNhbGxiYWNrcyA9IF8uaG9va3MuYWxsW25hbWVdO1xuXG5cdFx0XHRpZiAoIWNhbGxiYWNrcyB8fCAhY2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGk9MCwgY2FsbGJhY2s7IGNhbGxiYWNrID0gY2FsbGJhY2tzW2krK107KSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVudik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgVG9rZW4gPSBfLlRva2VuID0gZnVuY3Rpb24odHlwZSwgY29udGVudCwgYWxpYXMsIG1hdGNoZWRTdHIsIGdyZWVkeSkge1xuXHR0aGlzLnR5cGUgPSB0eXBlO1xuXHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXHR0aGlzLmFsaWFzID0gYWxpYXM7XG5cdC8vIENvcHkgb2YgdGhlIGZ1bGwgc3RyaW5nIHRoaXMgdG9rZW4gd2FzIGNyZWF0ZWQgZnJvbVxuXHR0aGlzLmxlbmd0aCA9IChtYXRjaGVkU3RyIHx8IFwiXCIpLmxlbmd0aHwwO1xuXHR0aGlzLmdyZWVkeSA9ICEhZ3JlZWR5O1xufTtcblxuVG9rZW4uc3RyaW5naWZ5ID0gZnVuY3Rpb24obywgbGFuZ3VhZ2UsIHBhcmVudCkge1xuXHRpZiAodHlwZW9mIG8gPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gbztcblx0fVxuXG5cdGlmIChfLnV0aWwudHlwZShvKSA9PT0gJ0FycmF5Jykge1xuXHRcdHJldHVybiBvLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gVG9rZW4uc3RyaW5naWZ5KGVsZW1lbnQsIGxhbmd1YWdlLCBvKTtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdHZhciBlbnYgPSB7XG5cdFx0dHlwZTogby50eXBlLFxuXHRcdGNvbnRlbnQ6IFRva2VuLnN0cmluZ2lmeShvLmNvbnRlbnQsIGxhbmd1YWdlLCBwYXJlbnQpLFxuXHRcdHRhZzogJ3NwYW4nLFxuXHRcdGNsYXNzZXM6IFsndG9rZW4nLCBvLnR5cGVdLFxuXHRcdGF0dHJpYnV0ZXM6IHt9LFxuXHRcdGxhbmd1YWdlOiBsYW5ndWFnZSxcblx0XHRwYXJlbnQ6IHBhcmVudFxuXHR9O1xuXG5cdGlmIChlbnYudHlwZSA9PSAnY29tbWVudCcpIHtcblx0XHRlbnYuYXR0cmlidXRlc1snc3BlbGxjaGVjayddID0gJ3RydWUnO1xuXHR9XG5cblx0aWYgKG8uYWxpYXMpIHtcblx0XHR2YXIgYWxpYXNlcyA9IF8udXRpbC50eXBlKG8uYWxpYXMpID09PSAnQXJyYXknID8gby5hbGlhcyA6IFtvLmFsaWFzXTtcblx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbnYuY2xhc3NlcywgYWxpYXNlcyk7XG5cdH1cblxuXHRfLmhvb2tzLnJ1bignd3JhcCcsIGVudik7XG5cblx0dmFyIGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhlbnYuYXR0cmlidXRlcykubWFwKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRyZXR1cm4gbmFtZSArICc9XCInICsgKGVudi5hdHRyaWJ1dGVzW25hbWVdIHx8ICcnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykgKyAnXCInO1xuXHR9KS5qb2luKCcgJyk7XG5cblx0cmV0dXJuICc8JyArIGVudi50YWcgKyAnIGNsYXNzPVwiJyArIGVudi5jbGFzc2VzLmpvaW4oJyAnKSArICdcIicgKyAoYXR0cmlidXRlcyA/ICcgJyArIGF0dHJpYnV0ZXMgOiAnJykgKyAnPicgKyBlbnYuY29udGVudCArICc8LycgKyBlbnYudGFnICsgJz4nO1xuXG59O1xuXG5pZiAoIV9zZWxmLmRvY3VtZW50KSB7XG5cdGlmICghX3NlbGYuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdC8vIGluIE5vZGUuanNcblx0XHRyZXR1cm4gX3NlbGYuUHJpc207XG5cdH1cbiBcdC8vIEluIHdvcmtlclxuXHRfc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24oZXZ0KSB7XG5cdFx0dmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2dC5kYXRhKSxcblx0XHQgICAgbGFuZyA9IG1lc3NhZ2UubGFuZ3VhZ2UsXG5cdFx0ICAgIGNvZGUgPSBtZXNzYWdlLmNvZGUsXG5cdFx0ICAgIGltbWVkaWF0ZUNsb3NlID0gbWVzc2FnZS5pbW1lZGlhdGVDbG9zZTtcblxuXHRcdF9zZWxmLnBvc3RNZXNzYWdlKF8uaGlnaGxpZ2h0KGNvZGUsIF8ubGFuZ3VhZ2VzW2xhbmddLCBsYW5nKSk7XG5cdFx0aWYgKGltbWVkaWF0ZUNsb3NlKSB7XG5cdFx0XHRfc2VsZi5jbG9zZSgpO1xuXHRcdH1cblx0fSwgZmFsc2UpO1xuXG5cdHJldHVybiBfc2VsZi5QcmlzbTtcbn1cblxuLy9HZXQgY3VycmVudCBzY3JpcHQgYW5kIGhpZ2hsaWdodFxudmFyIHNjcmlwdCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgfHwgW10uc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKSkucG9wKCk7XG5cbmlmIChzY3JpcHQpIHtcblx0Xy5maWxlbmFtZSA9IHNjcmlwdC5zcmM7XG5cblx0aWYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgJiYgIXNjcmlwdC5oYXNBdHRyaWJ1dGUoJ2RhdGEtbWFudWFsJykpIHtcblx0XHRpZihkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIikge1xuXHRcdFx0aWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShfLmhpZ2hsaWdodEFsbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dChfLmhpZ2hsaWdodEFsbCwgMTYpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBfLmhpZ2hsaWdodEFsbCk7XG5cdFx0fVxuXHR9XG59XG5cbnJldHVybiBfc2VsZi5QcmlzbTtcblxufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gUHJpc207XG59XG5cbi8vIGhhY2sgZm9yIGNvbXBvbmVudHMgdG8gd29yayBjb3JyZWN0bHkgaW4gbm9kZS5qc1xuaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdGdsb2JhbC5QcmlzbSA9IFByaXNtO1xufVxuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tbWFya3VwLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5tYXJrdXAgPSB7XG5cdCdjb21tZW50JzogLzwhLS1bXFx3XFxXXSo/LS0+Lyxcblx0J3Byb2xvZyc6IC88XFw/W1xcd1xcV10rP1xcPz4vLFxuXHQnZG9jdHlwZSc6IC88IURPQ1RZUEVbXFx3XFxXXSs/Pi9pLFxuXHQnY2RhdGEnOiAvPCFcXFtDREFUQVxcW1tcXHdcXFddKj9dXT4vaSxcblx0J3RhZyc6IHtcblx0XHRwYXR0ZXJuOiAvPFxcLz8oPyFcXGQpW15cXHM+XFwvPSQ8XSsoPzpcXHMrW15cXHM+XFwvPV0rKD86PSg/OihcInwnKSg/OlxcXFxcXDF8XFxcXD8oPyFcXDEpW1xcd1xcV10pKlxcMXxbXlxccydcIj49XSspKT8pKlxccypcXC8/Pi9pLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J3RhZyc6IHtcblx0XHRcdFx0cGF0dGVybjogL148XFwvP1teXFxzPlxcL10rL2ksXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9ePFxcLz8vLFxuXHRcdFx0XHRcdCduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQnYXR0ci12YWx1ZSc6IHtcblx0XHRcdFx0cGF0dGVybjogLz0oPzooJ3xcIilbXFx3XFxXXSo/KFxcMSl8W15cXHM+XSspL2ksXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9bPT5cIiddL1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0J3B1bmN0dWF0aW9uJzogL1xcLz8+Lyxcblx0XHRcdCdhdHRyLW5hbWUnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9bXlxccz5cXC9dKy8sXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblx0fSxcblx0J2VudGl0eSc6IC8mIz9bXFxkYS16XXsxLDh9Oy9pXG59O1xuXG4vLyBQbHVnaW4gdG8gbWFrZSBlbnRpdHkgdGl0bGUgc2hvdyB0aGUgcmVhbCBlbnRpdHksIGlkZWEgYnkgUm9tYW4gS29tYXJvdlxuUHJpc20uaG9va3MuYWRkKCd3cmFwJywgZnVuY3Rpb24oZW52KSB7XG5cblx0aWYgKGVudi50eXBlID09PSAnZW50aXR5Jykge1xuXHRcdGVudi5hdHRyaWJ1dGVzWyd0aXRsZSddID0gZW52LmNvbnRlbnQucmVwbGFjZSgvJmFtcDsvLCAnJicpO1xuXHR9XG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLnhtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMuaHRtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMubWF0aG1sID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblByaXNtLmxhbmd1YWdlcy5zdmcgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY3NzLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5jc3MgPSB7XG5cdCdjb21tZW50JzogL1xcL1xcKltcXHdcXFddKj9cXCpcXC8vLFxuXHQnYXRydWxlJzoge1xuXHRcdHBhdHRlcm46IC9AW1xcdy1dKz8uKj8oO3woPz1cXHMqXFx7KSkvaSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdydWxlJzogL0BbXFx3LV0rL1xuXHRcdFx0Ly8gU2VlIHJlc3QgYmVsb3dcblx0XHR9XG5cdH0sXG5cdCd1cmwnOiAvdXJsXFwoKD86KFtcIiddKShcXFxcKD86XFxyXFxufFtcXHdcXFddKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxfC4qPylcXCkvaSxcblx0J3NlbGVjdG9yJzogL1teXFx7XFx9XFxzXVteXFx7XFx9O10qPyg/PVxccypcXHspLyxcblx0J3N0cmluZyc6IHtcblx0XHRwYXR0ZXJuOiAvKFwifCcpKFxcXFwoPzpcXHJcXG58W1xcd1xcV10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQncHJvcGVydHknOiAvKFxcYnxcXEIpW1xcdy1dKyg/PVxccyo6KS9pLFxuXHQnaW1wb3J0YW50JzogL1xcQiFpbXBvcnRhbnRcXGIvaSxcblx0J2Z1bmN0aW9uJzogL1stYS16MC05XSsoPz1cXCgpL2ksXG5cdCdwdW5jdHVhdGlvbic6IC9bKCl7fTs6XS9cbn07XG5cblByaXNtLmxhbmd1YWdlcy5jc3NbJ2F0cnVsZSddLmluc2lkZS5yZXN0ID0gUHJpc20udXRpbC5jbG9uZShQcmlzbS5sYW5ndWFnZXMuY3NzKTtcblxuaWYgKFByaXNtLmxhbmd1YWdlcy5tYXJrdXApIHtcblx0UHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ3RhZycsIHtcblx0XHQnc3R5bGUnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKDxzdHlsZVtcXHdcXFddKj8+KVtcXHdcXFddKj8oPz08XFwvc3R5bGU+KS9pLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmNzcyxcblx0XHRcdGFsaWFzOiAnbGFuZ3VhZ2UtY3NzJ1xuXHRcdH1cblx0fSk7XG5cdFxuXHRQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdpbnNpZGUnLCAnYXR0ci12YWx1ZScsIHtcblx0XHQnc3R5bGUtYXR0cic6IHtcblx0XHRcdHBhdHRlcm46IC9cXHMqc3R5bGU9KFwifCcpLio/XFwxL2ksXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J2F0dHItbmFtZSc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvXlxccypzdHlsZS9pLFxuXHRcdFx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9eXFxzKj1cXHMqWydcIl18WydcIl1cXHMqJC8sXG5cdFx0XHRcdCdhdHRyLXZhbHVlJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC8uKy9pLFxuXHRcdFx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmNzc1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YWxpYXM6ICdsYW5ndWFnZS1jc3MnXG5cdFx0fVxuXHR9LCBQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZyk7XG59XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY2xpa2UuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmNsaWtlID0ge1xuXHQnY29tbWVudCc6IFtcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXCpbXFx3XFxXXSo/XFwqXFwvLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXlxcXFw6XSlcXC9cXC8uKi8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fVxuXHRdLFxuXHQnc3RyaW5nJzoge1xuXHRcdHBhdHRlcm46IC8oW1wiJ10pKFxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQnY2xhc3MtbmFtZSc6IHtcblx0XHRwYXR0ZXJuOiAvKCg/OlxcYig/OmNsYXNzfGludGVyZmFjZXxleHRlbmRzfGltcGxlbWVudHN8dHJhaXR8aW5zdGFuY2VvZnxuZXcpXFxzKyl8KD86Y2F0Y2hcXHMrXFwoKSlbYS16MC05X1xcLlxcXFxdKy9pLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHRwdW5jdHVhdGlvbjogLyhcXC58XFxcXCkvXG5cdFx0fVxuXHR9LFxuXHQna2V5d29yZCc6IC9cXGIoaWZ8ZWxzZXx3aGlsZXxkb3xmb3J8cmV0dXJufGlufGluc3RhbmNlb2Z8ZnVuY3Rpb258bmV3fHRyeXx0aHJvd3xjYXRjaHxmaW5hbGx5fG51bGx8YnJlYWt8Y29udGludWUpXFxiLyxcblx0J2Jvb2xlYW4nOiAvXFxiKHRydWV8ZmFsc2UpXFxiLyxcblx0J2Z1bmN0aW9uJzogL1thLXowLTlfXSsoPz1cXCgpL2ksXG5cdCdudW1iZXInOiAvXFxiLT8oPzoweFtcXGRhLWZdK3xcXGQqXFwuP1xcZCsoPzplWystXT9cXGQrKT8pXFxiL2ksXG5cdCdvcGVyYXRvcic6IC8tLT98XFwrXFwrP3whPT89P3w8PT98Pj0/fD09Pz0/fCYmP3xcXHxcXHw/fFxcP3xcXCp8XFwvfH58XFxefCUvLFxuXHQncHVuY3R1YXRpb24nOiAvW3t9W1xcXTsoKSwuOl0vXG59O1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tamF2YXNjcmlwdC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuXHQna2V5d29yZCc6IC9cXGIoYXN8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseXxmb3J8ZnJvbXxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvLFxuXHQnbnVtYmVyJzogL1xcYi0/KDB4W1xcZEEtRmEtZl0rfDBiWzAxXSt8MG9bMC03XSt8XFxkKlxcLj9cXGQrKFtFZV1bKy1dP1xcZCspP3xOYU58SW5maW5pdHkpXFxiLyxcblx0Ly8gQWxsb3cgZm9yIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycyAoU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMDg0NDQpXG5cdCdmdW5jdGlvbic6IC9bXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKig/PVxcKCkvaSxcblx0J29wZXJhdG9yJzogLy0tP3xcXCtcXCs/fCE9Pz0/fDw9P3w+PT98PT0/PT98JiY/fFxcfFxcfD98XFw/fFxcKlxcKj98XFwvfH58XFxefCV8XFwuezN9L1xufSk7XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAna2V5d29yZCcsIHtcblx0J3JlZ2V4Jzoge1xuXHRcdHBhdHRlcm46IC8oXnxbXi9dKVxcLyg/IVxcLykoXFxbLis/XXxcXFxcLnxbXi9cXFxcXFxyXFxuXSkrXFwvW2dpbXl1XXswLDV9KD89XFxzKigkfFtcXHJcXG4sLjt9KV0pKS8sXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRncmVlZHk6IHRydWVcblx0fVxufSk7XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnc3RyaW5nJywge1xuXHQndGVtcGxhdGUtc3RyaW5nJzoge1xuXHRcdHBhdHRlcm46IC9gKD86XFxcXFxcXFx8XFxcXD9bXlxcXFxdKSo/YC8sXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J2ludGVycG9sYXRpb24nOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9cXCRcXHtbXn1dK1xcfS8sXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJzoge1xuXHRcdFx0XHRcdFx0cGF0dGVybjogL15cXCRcXHt8XFx9JC8sXG5cdFx0XHRcdFx0XHRhbGlhczogJ3B1bmN0dWF0aW9uJ1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVzdDogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdzdHJpbmcnOiAvW1xcc1xcU10rL1xuXHRcdH1cblx0fVxufSk7XG5cbmlmIChQcmlzbS5sYW5ndWFnZXMubWFya3VwKSB7XG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICd0YWcnLCB7XG5cdFx0J3NjcmlwdCc6IHtcblx0XHRcdHBhdHRlcm46IC8oPHNjcmlwdFtcXHdcXFddKj8+KVtcXHdcXFddKj8oPz08XFwvc2NyaXB0PikvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0LFxuXHRcdFx0YWxpYXM6ICdsYW5ndWFnZS1qYXZhc2NyaXB0J1xuXHRcdH1cblx0fSk7XG59XG5cblByaXNtLmxhbmd1YWdlcy5qcyA9IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0O1xuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWZpbGUtaGlnaGxpZ2h0LmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgfHwgIXNlbGYuUHJpc20gfHwgIXNlbGYuZG9jdW1lbnQgfHwgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRzZWxmLlByaXNtLmZpbGVIaWdobGlnaHQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBFeHRlbnNpb25zID0ge1xuXHRcdFx0J2pzJzogJ2phdmFzY3JpcHQnLFxuXHRcdFx0J3B5JzogJ3B5dGhvbicsXG5cdFx0XHQncmInOiAncnVieScsXG5cdFx0XHQncHMxJzogJ3Bvd2Vyc2hlbGwnLFxuXHRcdFx0J3BzbTEnOiAncG93ZXJzaGVsbCcsXG5cdFx0XHQnc2gnOiAnYmFzaCcsXG5cdFx0XHQnYmF0JzogJ2JhdGNoJyxcblx0XHRcdCdoJzogJ2MnLFxuXHRcdFx0J3RleCc6ICdsYXRleCdcblx0XHR9O1xuXG5cdFx0aWYoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpIHsgLy8gQ2hlY2sgdG8gcHJldmVudCBlcnJvciBpbiBJRThcblx0XHRcdEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3ByZVtkYXRhLXNyY10nKSkuZm9yRWFjaChmdW5jdGlvbiAocHJlKSB7XG5cdFx0XHRcdHZhciBzcmMgPSBwcmUuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpO1xuXG5cdFx0XHRcdHZhciBsYW5ndWFnZSwgcGFyZW50ID0gcHJlO1xuXHRcdFx0XHR2YXIgbGFuZyA9IC9cXGJsYW5nKD86dWFnZSk/LSg/IVxcKikoXFx3KylcXGIvaTtcblx0XHRcdFx0d2hpbGUgKHBhcmVudCAmJiAhbGFuZy50ZXN0KHBhcmVudC5jbGFzc05hbWUpKSB7XG5cdFx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRcdFx0bGFuZ3VhZ2UgPSAocHJlLmNsYXNzTmFtZS5tYXRjaChsYW5nKSB8fCBbLCAnJ10pWzFdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFsYW5ndWFnZSkge1xuXHRcdFx0XHRcdHZhciBleHRlbnNpb24gPSAoc3JjLm1hdGNoKC9cXC4oXFx3KykkLykgfHwgWywgJyddKVsxXTtcblx0XHRcdFx0XHRsYW5ndWFnZSA9IEV4dGVuc2lvbnNbZXh0ZW5zaW9uXSB8fCBleHRlbnNpb247XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgY29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvZGUnKTtcblx0XHRcdFx0Y29kZS5jbGFzc05hbWUgPSAnbGFuZ3VhZ2UtJyArIGxhbmd1YWdlO1xuXG5cdFx0XHRcdHByZS50ZXh0Q29udGVudCA9ICcnO1xuXG5cdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSAnTG9hZGluZ+KApic7XG5cblx0XHRcdFx0cHJlLmFwcGVuZENoaWxkKGNvZGUpO1xuXG5cdFx0XHRcdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuXHRcdFx0XHR4aHIub3BlbignR0VUJywgc3JjLCB0cnVlKTtcblxuXHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XG5cblx0XHRcdFx0XHRcdGlmICh4aHIuc3RhdHVzIDwgNDAwICYmIHhoci5yZXNwb25zZVRleHQpIHtcblx0XHRcdFx0XHRcdFx0Y29kZS50ZXh0Q29udGVudCA9IHhoci5yZXNwb25zZVRleHQ7XG5cblx0XHRcdFx0XHRcdFx0UHJpc20uaGlnaGxpZ2h0RWxlbWVudChjb2RlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKHhoci5zdGF0dXMgPj0gNDAwKSB7XG5cdFx0XHRcdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSAn4pyWIEVycm9yICcgKyB4aHIuc3RhdHVzICsgJyB3aGlsZSBmZXRjaGluZyBmaWxlOiAnICsgeGhyLnN0YXR1c1RleHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29kZS50ZXh0Q29udGVudCA9ICfinJYgRXJyb3I6IEZpbGUgZG9lcyBub3QgZXhpc3Qgb3IgaXMgZW1wdHknO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR4aHIuc2VuZChudWxsKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHR9O1xuXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBzZWxmLlByaXNtLmZpbGVIaWdobGlnaHQpO1xuXG59KSgpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByaXNtanMvcHJpc20uanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3ByaXNtLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJpc20uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9wcmlzbS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmlzbWpzL3RoZW1lcy9wcmlzbS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGRlZmF1bHQge1xuXG4gIC8qKlxuICAgKiBkZWZhdWx0IHNjYWxlIHRoYXQgd2lsbCBiZSBzZXQgb24gZWxlbWVudFxuICAgKiBAbWF4UGluY2gge051bWJlcn1cbiAgICovXG4gIGJhc2VTY2FsZTogMSxcblxuICAvKipcbiAgICogbWF4IHNjYWxlIGEgbm9kZSBjYW4gcmVhY2hcbiAgICogQG1heFBpbmNoIHtOdW1iZXJ9XG4gICAqL1xuICBtYXhTY2FsZTogMyxcblxuICAvKipcbiAgICogbWF4IHNjYWxlIGEgbm9kZSBjYW4gcmVhY2ggYmVmb3JlIGJvdW5jaW5nIGJhY2sgdG8gbWF4U2NhbGVcbiAgICogQG1heFNjYWxlVGltZXMge051bWJlcn1cbiAgICovXG4gIG1heFNjYWxlVGltZXM6IDQsXG5cbiAgLyoqXG4gICAqIG1pbiBzY2FsZSBhIG5vZGUgY2FuIHJlYWNoXG4gICAqIEBtaW5QaW5jaCB7TnVtYmVyfVxuICAgKi9cbiAgbWluU2NhbGU6IDEsXG5cbiAgLyoqXG4gICAqIG1pbiBzY2FsZSBhIG5vZGUgY2FuIHJlYWNoIGJlZm9yZSBib3VuY2luZyBiYWNrIHRvIG1pblNjYWxlXG4gICAqIEBtaW5TY2FsZVRpbWVzIHtOdW1iZXJ9XG4gICAqL1xuICBtaW5TY2FsZVRpbWVzOiAwLjgsXG5cbiAgLyoqXG4gICAqIHRpbWUgZm9yIHRoZSBzbmFwQmFjayBvZiB0aGUgcGluY2ggaWYgdGhlIG5vZGUgaGFzIHJlYWNoIGFib3ZlXG4gICAqIG9yIGJlbG93IGl0cyBwaW5jaCB2YWx1ZVxuICAgKiBAc25hcEJhY2tTcGVlZCB7TnVtYmVyfVxuICAgKi9cbiAgc25hcEJhY2tTcGVlZDogMjAwLFxuXG4gIC8qKlxuICAgKiBCYXNpYyBlYXNpbmcgZnVuY3Rpb25zOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kZS9kb2NzL1dlYi9DU1MvdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cbiAgICogY3ViaWMgYmV6aWVyIGVhc2luZyBmdW5jdGlvbnM6IGh0dHA6Ly9lYXNpbmdzLm5ldC9kZVxuICAgKiBAZWFzZSB7U3RyaW5nfVxuICAgKi9cbiAgZWFzZTogJ2Vhc2UnLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9kZWZhdWx0cy5qcyIsIi8vIEBmbG93XG4vL1xuaW1wb3J0IGV2ZW50RGlzcGF0Y2hlciBmcm9tICcuL3V0aWxzL2Rpc3BhdGNoLWV2ZW50JztcbmltcG9ydCB7IGNhbmNlbEV2ZW50LCBnZXRUb3VjaGVzLCBkZXRlY3REb3VibGVUYXAgfSBmcm9tICcuL3V0aWxzL2hhbmRsZS1ldmVudCc7XG5pbXBvcnQgc2NhbGVFbGVtZW50IGZyb20gJy4vdXRpbHMvaGFuZGxlLWVsZW1lbnQnO1xuaW1wb3J0IHsgaXNXaXRoaW4sIGNhbGNTY2FsZSwgY2FsY05ld1NjYWxlLCBhZGRPZmZzZXQsIGdldEluaXRpYWxTY2FsZSwgc2NhbGVGYWN0b3IsIGdldFRvdWNoQ2VudGVyIH0gZnJvbSAnLi91dGlscy9oYW5kbGUtcGluY2gnO1xuaW1wb3J0IHsgZHJhZywgc2FuaXRpemVPZmZzZXQgfSBmcm9tICcuL3V0aWxzL2hhbmRsZS1kcmFnJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuL2RlZmF1bHRzJztcblxuY29uc3QgZmlyc3QgPSAoaXRlbXM6IEFycmF5PE9iamVjdD4pID0+IGl0ZW1zWzBdO1xuXG5jb25zdCBwaW5jaEl0ID0gKHRhcmdldHM6IHN0cmluZyB8IE9iamVjdCwgb3B0aW9uczogT2JqZWN0ID0ge30pID0+IHtcbiAgLy8gcHJpdmF0ZSB2YXJpYWJsZSBjYWNoZVxuICBsZXQgZWxlbWVudHMgPSBbXTtcbiAgbGV0IG9wdHMgPSB7fTtcblxuICBsZXQgc2NhbGluZztcbiAgbGV0IGxhc3RTY2FsZSA9IDE7XG4gIGxldCBzdGFydFRvdWNoZXM7XG5cbiAgbGV0IHpvb21GYWN0b3IgPSAxO1xuXG4gIGxldCBvZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgbGV0IGxhc3Rab29tQ2VudGVyID0gZmFsc2U7XG4gIGxldCBsYXN0RHJhZ1Bvc2l0aW9uID0gZmFsc2U7XG5cbiAgY29uc3QgeyBvbiwgZGlzcGF0Y2ggfSA9IGV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gLyoqXG4gICogIGRpc3BhdGNoUGluY2hFdmVudCAtIFNob3J0aGFuZCBtZXRob2QgZm9yIGNyZWF0aW5nIGV2ZW50c1xuICAqXG4gICogIEBwYXJhbSB7IFN0cmluZyB9IHBoYXNlXG4gICogIEBwYXJhbSB7IFN0cmluZyB9IHR5cGVcbiAgKiAgQHBhcmFtIHsgT2JqZWN0IH0gZGV0YWlsc1xuICAqICBAcmV0dXJuIHsgVm9pZCB9XG4gICoqL1xuICBjb25zdCBkaXNwYXRjaFBpbmNoRXZlbnQgPSAoZXZlbnROYW1lOiBzdHJpbmcsIHBoYXNlOiBzdHJpbmcsIGRhdGE6IE9iamVjdCA9IHt9KTogdm9pZCA9PiB7XG4gICAgZGlzcGF0Y2goZXZlbnROYW1lLCBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgIHBoYXNlXG4gICAgfSkpO1xuICB9O1xuXG4gIGNvbnN0IHJlc2V0R2xvYmFscyA9ICgvKiBvcHRzICovKTogdm9pZCA9PiB7XG4gICAgc2NhbGluZyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0U2NhbGUgPSAxO1xuICAgIHN0YXJ0VG91Y2hlcyA9IG51bGw7XG4gICAgem9vbUZhY3RvciA9IDE7XG4gICAgbGFzdFpvb21DZW50ZXIgPSBmYWxzZTtcblxuICAgIGxhc3REcmFnUG9zaXRpb24gPSBmYWxzZTtcbiAgICBvZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgfTtcblxuICAvLyBldmVudCBoYW5kbGluZ1xuICAvKipcbiAgICogU2V0IHNjYWxpbmcgaWYgd2UgYXJlIHVzaW5nIG1vcmUgdGhlbiBvbmUgZmluZ2VyXG4gICAqIGFuZCBjYXB0dXJlcyBvdXIgZmlyc3QgcHVuY2ggcG9pbnRcbiAgICpcbiAgICogcHJpdmF0ZVxuICAgKiBAcGFyYW0geyBPYmplY3QgfSBlIHRoZSBldmVudCBmcm9tIG91ciBldmVudGxpc3RlbmVyXG4gICAqL1xuICBjb25zdCBvblRvdWNoc3RhcnQgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGRpc3BhdGNoUGluY2hFdmVudCgndG91Y2hzdGFydCcsICdiZWZvcmUnLCBlKTtcblxuXG4gICAgc2NhbGluZyA9IChlLnRvdWNoZXMubGVuZ3RoID09PSAyKTtcbiAgICBzdGFydFRvdWNoZXMgPSBBcnJheS5mcm9tKGUudG91Y2hlcyk7XG4gICAgbGFzdFNjYWxlID0gMTtcblxuICAgIGlmIChkZXRlY3REb3VibGVUYXAoZSkpIHtcbiAgICAgIHNjYWxlRWxlbWVudChlLnRhcmdldCwgMSwgeyB4OiAwLCB5OiAwIH0sIG9wdHMuc25hcEJhY2tTcGVlZCwgb3B0cy5lYXNlKTtcbiAgICAgIHJlc2V0R2xvYmFscygpO1xuICAgIH1cblxuICAgIGRpc3BhdGNoUGluY2hFdmVudCgndG91Y2hzdGFydCcsICdhZnRlcicsIGUpO1xuICB9O1xuXG4gIGNvbnN0IG9uVG91Y2htb3ZlID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ3RvdWNobW92ZScsICdiZWZvcmUnLCBlKTtcblxuICAgIGlmICgoIXNjYWxpbmcgfHwgIXN0YXJ0VG91Y2hlcykgJiYgem9vbUZhY3RvciA+IDEpIHtcbiAgICAgIGNhbmNlbEV2ZW50KGUpO1xuXG4gICAgICBjb25zdCB0b3VjaCA9IGZpcnN0KGdldFRvdWNoZXMoZS50YXJnZXQsIEFycmF5LmZyb20oZS50b3VjaGVzKSkpO1xuICAgICAgY29uc3QgZHJhZ09mZnNldCA9IGRyYWcodG91Y2gsIGxhc3REcmFnUG9zaXRpb24sIG9mZnNldCwgem9vbUZhY3Rvcik7XG5cbiAgICAgIG9mZnNldCA9IHNhbml0aXplT2Zmc2V0KGUudGFyZ2V0LCBkcmFnT2Zmc2V0LCB6b29tRmFjdG9yKTtcbiAgICAgIGxhc3REcmFnUG9zaXRpb24gPSB0b3VjaDtcbiAgICB9IGVsc2UgaWYgKHNjYWxpbmcgJiYgc3RhcnRUb3VjaGVzKSB7XG4gICAgICBjYW5jZWxFdmVudChlKTtcblxuICAgICAgLy8gYSByZWxhdGl2ZSBzY2FsZSBmYWN0b3IgaXMgdXNlZFxuICAgICAgY29uc3QgdG91Y2hDZW50ZXIgPSBnZXRUb3VjaENlbnRlcihnZXRUb3VjaGVzKGUudGFyZ2V0LCBBcnJheS5mcm9tKGUudG91Y2hlcykpKTtcbiAgICAgIGNvbnN0IG5ld1NjYWxlID0gY2FsY1NjYWxlKGUudGFyZ2V0LCBzdGFydFRvdWNoZXMsIEFycmF5LmZyb20oZS50b3VjaGVzKSk7XG4gICAgICBjb25zdCBzY2FsZSA9IGNhbGNOZXdTY2FsZShuZXdTY2FsZSwgbGFzdFNjYWxlKTtcblxuICAgICAgY29uc3QgZmFjdG9yID0gc2NhbGVGYWN0b3Ioc2NhbGUsIHpvb21GYWN0b3IsIG9wdHMpO1xuXG4gICAgICBvZmZzZXQgPSBhZGRPZmZzZXQob2Zmc2V0LCB7XG4gICAgICAgIHg6IChmYWN0b3Iuc2NhbGUgLSAxKSAqICh0b3VjaENlbnRlci54ICsgb2Zmc2V0LngpLFxuICAgICAgICB5OiAoZmFjdG9yLnNjYWxlIC0gMSkgKiAodG91Y2hDZW50ZXIueSArIG9mZnNldC55KVxuICAgICAgfSk7XG5cbiAgICAgIHpvb21GYWN0b3IgPSBmYWN0b3Iuem9vbUZhY3RvcjtcbiAgICAgIGxhc3RTY2FsZSA9IG5ld1NjYWxlO1xuICAgICAgb2Zmc2V0ID0gZHJhZyh0b3VjaENlbnRlciwgbGFzdFpvb21DZW50ZXIsIG9mZnNldCwgem9vbUZhY3Rvcik7XG4gICAgICBsYXN0Wm9vbUNlbnRlciA9IHRvdWNoQ2VudGVyO1xuICAgIH1cblxuICAgIHNjYWxlRWxlbWVudChlLnRhcmdldCwgem9vbUZhY3Rvciwgb2Zmc2V0LCAwLCBvcHRzLmVhc2UpO1xuXG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCd0b3VjaG1vdmUnLCAnYWZ0ZXInLCBlKTtcbiAgfTtcblxuICBjb25zdCBvblRvdWNoZW5kID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ3RvdWNoZW5kJywgJ2JlZm9yZScsIGUpO1xuXG4gICAgbGFzdERyYWdQb3NpdGlvbiA9IGZhbHNlO1xuICAgIGxhc3Rab29tQ2VudGVyID0gZmFsc2U7XG4gICAgbGFzdFNjYWxlID0gMTtcbiAgICBpZiAoem9vbUZhY3Rvcikge1xuICAgICAgaWYgKCFpc1dpdGhpbih6b29tRmFjdG9yLCBvcHRzKSkge1xuICAgICAgICBjb25zdCBpc0xlc3NUaGFuID0gKGdldEluaXRpYWxTY2FsZShlLnRhcmdldCkgKiB6b29tRmFjdG9yIDwgb3B0cy5taW5TY2FsZSk7XG4gICAgICAgIHpvb21GYWN0b3IgPSBpc0xlc3NUaGFuID8gb3B0cy5taW5TY2FsZSA6IG9wdHMubWF4U2NhbGU7XG4gICAgICAgIG9mZnNldCA9IHNhbml0aXplT2Zmc2V0KGUudGFyZ2V0LCBvZmZzZXQsIHpvb21GYWN0b3IpO1xuICAgICAgICBzY2FsZUVsZW1lbnQoZS50YXJnZXQsIHpvb21GYWN0b3IsIG9mZnNldCwgb3B0cy5zbmFwQmFja1NwZWVkLCBvcHRzLmVhc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRpc3BhdGNoUGluY2hFdmVudCgndG91Y2hlbmQnLCAnYWZ0ZXInLCBlKTtcbiAgfTtcblxuICBjb25zdCBhdHRhY2hFdmVudHMgPSAoZWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hzdGFydCk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaG1vdmUpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaGVuZCk7XG4gIH07XG5cbiAgY29uc3QgZGV0YWNoaEV2ZW50cyA9IChlbDogT2JqZWN0KSA9PiB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hzdGFydCk7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaG1vdmUpO1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaGVuZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHB1YmxpY1xuICAgKiByZXNldCBmdW5jdGlvbjpcbiAgICogQHBhcmFtIHsgTnVtYmVyIH0gZHVyYXRpb25cbiAgICogQHBhcmFtIHsgU3RyaW5nIH0gZWFzaW5nXG4gICAqIEByZXR1cm4geyBWb2lkIH1cbiAgICovXG4gIGNvbnN0IHJlc2V0ID0gKG9wdDogT2JqZWN0KSA9PiAoaXRlbTogP251bWJlcik6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHsgc25hcEJhY2tTcGVlZCwgZWFzaW5nIH0gPSB7Li4uZGVmYXVsdHMsIC4uLm9wdH07XG5cbiAgICBpZiAoaXRlbSAmJiAhaXNOYU4oaXRlbSkgJiYgZWxlbWVudHNbaXRlbV0pIHtcbiAgICAgIHNjYWxlRWxlbWVudChlbGVtZW50c1tpdGVtXSwgMSwgeyB4OiAwLCB5OiAwIH0sIHNuYXBCYWNrU3BlZWQsIGVhc2luZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEFycmF5LmZyb20oZWxlbWVudHMpLmZvckVhY2goZWwgPT4gKFxuICAgICAgICBzY2FsZUVsZW1lbnQoZWwsIDEsIHsgeDogMCwgeTogMCB9LCBzbmFwQmFja1NwZWVkLCBlYXNpbmcpKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXNldEdsb2JhbHMoKTtcbiAgfTtcblxuICAvKipcbiAgICogcHVibGljXG4gICAqIGRlc3Ryb3kgZnVuY3Rpb246IGNhbGxlZCB0byBncmFjZWZ1bGx5IGRlc3Ryb3kgdGhlIGxvcnkgaW5zdGFuY2VcbiAgICogQHJldHVybiB7IFZvaWQgfVxuICAgKi9cbiAgY29uc3QgZGVzdHJveSA9ICgpOiB2b2lkID0+IHtcbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ2Rlc3Ryb3knLCAnYmVmb3JlJywge30pO1xuICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgICBBcnJheS5mcm9tKGVsZW1lbnRzKS5mb3JFYWNoKGRldGFjaGhFdmVudHMpO1xuICAgIGVsZW1lbnRzID0gW107XG4gICAgcmVzZXRHbG9iYWxzKCk7XG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCdkZXN0cm95JywgJ2FmdGVyJywge30pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBzZXR1cCAtIEluaXQgZnVuY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHsgU3RyaW5nLCBPYmplY3QgfVxuICAgKiBAcmV0dXJuIHsgVm9pZCB9XG4gICAqKi9cblxuICB0eXBlIE9wdGlvbnMgPSB7XG4gICAgbWF4UGluY2g/OiBudW1iZXI7XG4gICAgbWluUGluY2g/OiBudW1iZXI7XG4gICAgc25hcEJhY2tTcGVlZD86IG51bWJlcjtcbiAgICBlYXNlPzogc3RyaW5nO1xuICB9O1xuXG4gIGNvbnN0IHNldHVwID0gKHRhcmdldDogc3RyaW5nIHwgT2JqZWN0LCBvcHQ6IE9wdGlvbnMpOiB2b2lkID0+IHtcbiAgICBpZiAoZWxlbWVudHMpIGRlc3Ryb3koKTtcbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ2luaXQnLCAnYmVmb3JlJywge30pO1xuXG4gICAgLy8gQmFzZSBjb25maWd1cmF0aW9uIGZvciB0aGUgcGluY2ggaW5zdGFuY2VcbiAgICBvcHRzID0gey4uLmRlZmF1bHRzLCAuLi5vcHR9O1xuXG4gICAgLy8gcmVzb2x2ZSB0YXJnZXRcbiAgICAvLyBwaW5jaGl0IGFsbG93cyBmb3IgYm90aCBhIG5vZGUgb3IgYSBzdHJpbmcgdG8gYmUgcGFzc2VkXG4gICAgc3dpdGNoICh0eXBlb2YgdGFyZ2V0KSB7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBlbGVtZW50cyA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldCA6IFt0YXJnZXRdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnRzID0gW107XG4gICAgICAgIGNvbnNvbGUud2FybignbWlzc2luZyB0YXJnZXQsIGVpdGhlciBwYXNzIGFuIG5vZGUgb3IgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBBcnJheS5mcm9tKGVsZW1lbnRzKS5mb3JFYWNoKGF0dGFjaEV2ZW50cyk7XG5cbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ2luaXQnLCAnYWZ0ZXInLCB7fSk7XG4gIH07XG5cbiAgLy8gdHJpZ2dlciBpbml0aWFsIHNldHVwXG4gIHNldHVwKHRhcmdldHMsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB7XG4gICAgc2V0dXAsXG4gICAgcmVzZXQ6IHJlc2V0KG9wdGlvbnMpLFxuICAgIGRlc3Ryb3ksXG4gICAgZWxlbWVudHMsXG4gICAgb24sXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwaW5jaEl0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3BpbmNoLWl0LmpzIiwiLyoqXG4gKiBEZXRlY3RpbmcgcHJlZml4ZXMgZm9yIHNhdmluZyB0aW1lIGFuZCBieXRlc1xuICovXG5leHBvcnQgZGVmYXVsdCAoKSA9PiB7XG4gIGxldCB0cmFuc2Zvcm07XG4gIGxldCB0cmFuc2l0aW9uO1xuICBsZXQgdHJhbnNpdGlvbkVuZDtcbiAgbGV0IGhhc1NjYWxlM2Q7XG5cbiAgKCgpID0+IHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ18nKTtcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xuXG4gICAgaWYgKHN0eWxlLndlYmtpdFRyYW5zaXRpb24gPT09ICcnKSB7XG4gICAgICB0cmFuc2l0aW9uRW5kID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICAgICAgdHJhbnNpdGlvbiA9ICd3ZWJraXRUcmFuc2l0aW9uJztcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUudHJhbnNpdGlvbiA9PT0gJycpIHtcbiAgICAgIHRyYW5zaXRpb25FbmQgPSAndHJhbnNpdGlvbmVuZCc7XG4gICAgICB0cmFuc2l0aW9uID0gJ3RyYW5zaXRpb24nO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPT09ICcnKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAnd2Via2l0VHJhbnNmb3JtJztcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUubXNUcmFuc2Zvcm0gPT09ICcnKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAnbXNUcmFuc2Zvcm0nO1xuICAgIH1cblxuICAgIGlmIChzdHlsZS50cmFuc2Zvcm0gPT09ICcnKSB7XG4gICAgICB0cmFuc2Zvcm0gPSAndHJhbnNmb3JtJztcbiAgICB9XG5cbiAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShlbCwgbnVsbCk7XG4gICAgc3R5bGVbdHJhbnNmb3JtXSA9ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSc7XG4gICAgaGFzU2NhbGUzZCA9ICEhZ2xvYmFsLmdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUodHJhbnNmb3JtKTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgfSkoKTtcblxuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybSxcbiAgICB0cmFuc2l0aW9uLFxuICAgIHRyYW5zaXRpb25FbmQsXG4gICAgaGFzU2NhbGUzZFxuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9kZXRlY3QtcHJlZml4ZXMuanMiLCIvLyBAZmxvd1xuXG4vKipcbiAqIGRpc3BhdGNoIGN1c3RvbSBldmVudHNcbiAqL1xuXG5jb25zdCBldmVudERpc3BhdGNoZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGV2ZW50cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGhhbmRsZXIgZm9yIGV2ZW50LCB0byBiZSBmaXJlZFxuICAgKiBmb3IgZXZlcnkgZXZlbnQuXG4gICAqL1xuICBjb25zdCBvbiA9IChldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogRnVuY3Rpb24pID0+IHtcbiAgICBldmVudHNbZXZlbnROYW1lXSA9IGV2ZW50c1tldmVudE5hbWVdIHx8IFtdO1xuICAgIGV2ZW50c1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYSBoYW5kbGVyIGZvciBldmVudC5cbiAgICovXG4gIGNvbnN0IG9mZiA9IChldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogRnVuY3Rpb24pID0+IHtcbiAgICBpZiAoZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzW2V2ZW50TmFtZV0ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGV2ZW50c1tldmVudE5hbWVdW2ldID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGRpc3BhdGNoID0gKGV2ZW50TmFtZTogc3RyaW5nLCBkYXRhOiBPYmplY3QpID0+IHtcbiAgICBpZiAoZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgIGV2ZW50c1tldmVudE5hbWVdLmZvckVhY2goKGZuKSA9PiB7XG4gICAgICAgIGZuKGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgb24sXG4gICAgb2ZmLFxuICAgIGRpc3BhdGNoLFxuICB9O1xufTtcblxuXG5leHBvcnQgZGVmYXVsdCBldmVudERpc3BhdGNoZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvZGlzcGF0Y2gtZXZlbnQuanMiLCIvLyBAZmxvd1xuXG5pbXBvcnQgeyBnZXRQYXJlbnRYLCBnZXRQYXJlbnRZLCBhZGRPZmZzZXQgfSBmcm9tICcuL2hhbmRsZS1waW5jaCc7XG5cbnR5cGUgQ2VudGVyID0ge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbn07XG5cbmNvbnN0IGNhbGNNYXggPSAoZWw6IEV2ZW50VGFyZ2V0LCBkaWZmZXI6IG51bWJlciwgem9vbUZhY3RvcjogbnVtYmVyKTogT2JqZWN0ID0+ICh7XG4gIG1heFg6ICh6b29tRmFjdG9yIC0gZGlmZmVyKSAqIGdldFBhcmVudFgoZWwpLFxuICBtYXhZOiAoem9vbUZhY3RvciAtIGRpZmZlcikgKiBnZXRQYXJlbnRZKGVsKSxcbn0pO1xuXG5leHBvcnQgY29uc3Qgc2FuaXRpemVPZmZzZXQgPSAoZWw6IEV2ZW50VGFyZ2V0LCBvZmZzZXQ6IENlbnRlciwgem9vbUZhY3RvcjogbnVtYmVyKTogT2JqZWN0ID0+IHtcbiAgY29uc3QgeyBtYXhYLCBtYXhZIH0gPSBjYWxjTWF4KGVsLCAxLCB6b29tRmFjdG9yKTtcbiAgY29uc3QgbWF4T2Zmc2V0WCA9IE1hdGgubWF4KG1heFgsIDApO1xuICBjb25zdCBtYXhPZmZzZXRZID0gTWF0aC5tYXgobWF4WSwgMCk7XG4gIGNvbnN0IG1pbk9mZnNldFggPSBNYXRoLm1pbihtYXhYLCAwKTtcbiAgY29uc3QgbWluT2Zmc2V0WSA9IE1hdGgubWluKG1heFksIDApO1xuXG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5taW4oTWF0aC5tYXgob2Zmc2V0LngsIG1pbk9mZnNldFgpLCBtYXhPZmZzZXRYKSxcbiAgICB5OiBNYXRoLm1pbihNYXRoLm1heChvZmZzZXQueSwgbWluT2Zmc2V0WSksIG1heE9mZnNldFkpXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZHJhZyA9IChjZW50ZXI6IENlbnRlciwgbGFzdENlbnRlcjogQ2VudGVyLCBsYXN0T2Zmc2V0OiBPYmplY3QsIHpvb21GYWN0b3I6IG51bWJlcik6IE9iamVjdCA9PiAoXG4gIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGFzdENlbnRlciwgJ3gnKSlcbiAgPyBhZGRPZmZzZXQobGFzdE9mZnNldCwge1xuICAgIHg6IC0oKChjZW50ZXIueCAtIGxhc3RDZW50ZXIueCkgKiB6b29tRmFjdG9yKSAvIHpvb21GYWN0b3IpLFxuICAgIHk6IC0oKChjZW50ZXIueSAtIGxhc3RDZW50ZXIueSkgKiB6b29tRmFjdG9yKSAvIHpvb21GYWN0b3IpLFxuICB9KVxuICA6IGxhc3RPZmZzZXRcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvaGFuZGxlLWRyYWcuanMiLCIvLyBAZmxvd1xuXG5pbXBvcnQgZGV0ZWN0UHJlZml4ZXMgZnJvbSAnLi9kZXRlY3QtcHJlZml4ZXMnO1xuaW1wb3J0IHsgZ2V0SW5pdGlhbFNjYWxlIH0gZnJvbSAnLi9oYW5kbGUtcGluY2gnO1xuXG5jb25zdCBwcmVmaXhlcyA9IGRldGVjdFByZWZpeGVzKCk7XG5cbmNvbnN0IGhhbmRsZUFuaW1hdGlvbiA9IChlbDogRXZlbnRUYXJnZXQsIHRyYW5zaXRpb246IHN0cmluZywgZHVyYXRpb246IG51bWJlciwgZWFzZTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIGNvbnN0IHsgc3R5bGUgfSA9IGVsO1xuICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCUgMCUnO1xuICBzdHlsZVtgJHt0cmFuc2l0aW9ufVRpbWluZ0Z1bmN0aW9uYF0gPSBlYXNlO1xuICBzdHlsZVtgJHt0cmFuc2l0aW9ufUR1cmF0aW9uYF0gPSBgJHtkdXJhdGlvbn1tc2A7XG59O1xuXG4vKipcbiAqIHNjYWxlRWxlbWVudCAtdHJhbnNkb3JtcyB0byBhIGdpdmVuIHBvc2l0aW9uIGluIGEgZ2l2ZW4gdGltZSBpbiBtaWxsaXNlY29uZHNcbiAqXG4gKiBAcGFyYW0geyBPYmplY3QgfSBlbCBlbGVtZW50IGZyb20gdGhlIGV2ZW50c1xuICogQHBhcmFtIHsgTnVtYmVyIH0gcGluY2ggbnVtYmVyIHdoZXJlIHRvIHNjYWxlIHRvXG4gKiBAcGFyYW0geyBPYmplY3QgfSBjb29yZHMgb2JqZWN0IHdoZXJlIHRvIHRyYW5zbGF0ZSB0b1xuICogQHBhcmFtIHsgTnVtYmVyIH0gZHVyYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2lzdGlvblxuICogQHBhcmFtIHsgU3RyaW5nIH0gZWFzZSBlYXNpbmcgY3NzIHByb3BlcnR5XG4gKiBAcmV0dXJuIHsgVm9pZCB9XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgKGVsOiBFdmVudFRhcmdldCwgcGluY2g6IG51bWJlciwgY29vcmRzOiBPYmplY3QsIGR1cmF0aW9uOiBudW1iZXIsIGVhc2U6IHN0cmluZyk6IHZvaWQgPT4ge1xuICBjb25zdCB7IHRyYW5zaXRpb24sIHRyYW5zZm9ybSwgaGFzU2NhbGUzZCB9ID0gcHJlZml4ZXM7XG4gIGNvbnN0IHsgc3R5bGUgfSA9IGVsO1xuXG4gIGNvbnN0IHpvb21GYWN0b3IgPSBnZXRJbml0aWFsU2NhbGUoZWwpICogcGluY2g7XG5cbiAgY29uc3Qgb2Zmc2V0WCA9IC1jb29yZHMueDtcbiAgY29uc3Qgb2Zmc2V0WSA9IC1jb29yZHMueTtcblxuICBoYW5kbGVBbmltYXRpb24oZWwsIHRyYW5zaXRpb24sIGR1cmF0aW9uLCBlYXNlKTtcbiAgY29uc3Qgc2NhbGVQcm9wID0gKGhhc1NjYWxlM2QpXG4gICAgPyBgc2NhbGUzZCgke3pvb21GYWN0b3J9LCAke3pvb21GYWN0b3J9LCAxKWBcbiAgICA6IGBzY2FsZSgke3pvb21GYWN0b3J9LCAke3pvb21GYWN0b3J9KWA7XG4gIGNvbnN0IHRyYW5zbGF0ZVByb3AgPSBgdHJhbnNsYXRlKCR7b2Zmc2V0WH1weCwgJHtvZmZzZXRZfXB4KWA7XG5cbiAgc3R5bGVbdHJhbnNmb3JtXSA9IGAke3RyYW5zbGF0ZVByb3B9ICR7c2NhbGVQcm9wfWA7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL2hhbmRsZS1lbGVtZW50LmpzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qKlxcbiAqIHByaXNtLmpzIGRlZmF1bHQgdGhlbWUgZm9yIEphdmFTY3JpcHQsIENTUyBhbmQgSFRNTFxcbiAqIEJhc2VkIG9uIGRhYmJsZXQgKGh0dHA6Ly9kYWJibGV0LmNvbSlcXG4gKiBAYXV0aG9yIExlYSBWZXJvdVxcbiAqL1xcblxcbmNvZGVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSxcXG5wcmVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSB7XFxuXFx0Y29sb3I6IGJsYWNrO1xcblxcdGJhY2tncm91bmQ6IG5vbmU7XFxuXFx0dGV4dC1zaGFkb3c6IDAgMXB4IHdoaXRlO1xcblxcdGZvbnQtZmFtaWx5OiBDb25zb2xhcywgTW9uYWNvLCAnQW5kYWxlIE1vbm8nLCAnVWJ1bnR1IE1vbm8nLCBtb25vc3BhY2U7XFxuXFx0dGV4dC1hbGlnbjogbGVmdDtcXG5cXHR3aGl0ZS1zcGFjZTogcHJlO1xcblxcdHdvcmQtc3BhY2luZzogbm9ybWFsO1xcblxcdHdvcmQtYnJlYWs6IG5vcm1hbDtcXG5cXHR3b3JkLXdyYXA6IG5vcm1hbDtcXG5cXHRsaW5lLWhlaWdodDogMS41O1xcblxcblxcdC1tb3otdGFiLXNpemU6IDQ7XFxuXFx0LW8tdGFiLXNpemU6IDQ7XFxuXFx0dGFiLXNpemU6IDQ7XFxuXFxuXFx0LXdlYmtpdC1oeXBoZW5zOiBub25lO1xcblxcdC1tb3otaHlwaGVuczogbm9uZTtcXG5cXHQtbXMtaHlwaGVuczogbm9uZTtcXG5cXHRoeXBoZW5zOiBub25lO1xcbn1cXG5cXG5wcmVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXTo6LW1vei1zZWxlY3Rpb24sIHByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIDo6LW1vei1zZWxlY3Rpb24sXFxuY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdOjotbW96LXNlbGVjdGlvbiwgY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIDo6LW1vei1zZWxlY3Rpb24ge1xcblxcdHRleHQtc2hhZG93OiBub25lO1xcblxcdGJhY2tncm91bmQ6ICNiM2Q0ZmM7XFxufVxcblxcbnByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdOjpzZWxlY3Rpb24sIHByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIDo6c2VsZWN0aW9uLFxcbmNvZGVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXTo6c2VsZWN0aW9uLCBjb2RlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0gOjpzZWxlY3Rpb24ge1xcblxcdHRleHQtc2hhZG93OiBub25lO1xcblxcdGJhY2tncm91bmQ6ICNiM2Q0ZmM7XFxufVxcblxcbkBtZWRpYSBwcmludCB7XFxuXFx0Y29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdLFxcblxcdHByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIHtcXG5cXHRcXHR0ZXh0LXNoYWRvdzogbm9uZTtcXG5cXHR9XFxufVxcblxcbi8qIENvZGUgYmxvY2tzICovXFxucHJlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0ge1xcblxcdHBhZGRpbmc6IDFlbTtcXG5cXHRtYXJnaW46IC41ZW0gMDtcXG5cXHRvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuOm5vdChwcmUpID4gY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdLFxcbnByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIHtcXG5cXHRiYWNrZ3JvdW5kOiAjZjVmMmYwO1xcbn1cXG5cXG4vKiBJbmxpbmUgY29kZSAqL1xcbjpub3QocHJlKSA+IGNvZGVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSB7XFxuXFx0cGFkZGluZzogLjFlbTtcXG5cXHRib3JkZXItcmFkaXVzOiAuM2VtO1xcblxcdHdoaXRlLXNwYWNlOiBub3JtYWw7XFxufVxcblxcbi50b2tlbi5jb21tZW50LFxcbi50b2tlbi5wcm9sb2csXFxuLnRva2VuLmRvY3R5cGUsXFxuLnRva2VuLmNkYXRhIHtcXG5cXHRjb2xvcjogc2xhdGVncmF5O1xcbn1cXG5cXG4udG9rZW4ucHVuY3R1YXRpb24ge1xcblxcdGNvbG9yOiAjOTk5O1xcbn1cXG5cXG4ubmFtZXNwYWNlIHtcXG5cXHRvcGFjaXR5OiAuNztcXG59XFxuXFxuLnRva2VuLnByb3BlcnR5LFxcbi50b2tlbi50YWcsXFxuLnRva2VuLmJvb2xlYW4sXFxuLnRva2VuLm51bWJlcixcXG4udG9rZW4uY29uc3RhbnQsXFxuLnRva2VuLnN5bWJvbCxcXG4udG9rZW4uZGVsZXRlZCB7XFxuXFx0Y29sb3I6ICM5MDU7XFxufVxcblxcbi50b2tlbi5zZWxlY3RvcixcXG4udG9rZW4uYXR0ci1uYW1lLFxcbi50b2tlbi5zdHJpbmcsXFxuLnRva2VuLmNoYXIsXFxuLnRva2VuLmJ1aWx0aW4sXFxuLnRva2VuLmluc2VydGVkIHtcXG5cXHRjb2xvcjogIzY5MDtcXG59XFxuXFxuLnRva2VuLm9wZXJhdG9yLFxcbi50b2tlbi5lbnRpdHksXFxuLnRva2VuLnVybCxcXG4ubGFuZ3VhZ2UtY3NzIC50b2tlbi5zdHJpbmcsXFxuLnN0eWxlIC50b2tlbi5zdHJpbmcge1xcblxcdGNvbG9yOiAjYTY3ZjU5O1xcblxcdGJhY2tncm91bmQ6IGhzbGEoMCwgMCUsIDEwMCUsIC41KTtcXG59XFxuXFxuLnRva2VuLmF0cnVsZSxcXG4udG9rZW4uYXR0ci12YWx1ZSxcXG4udG9rZW4ua2V5d29yZCB7XFxuXFx0Y29sb3I6ICMwN2E7XFxufVxcblxcbi50b2tlbi5mdW5jdGlvbiB7XFxuXFx0Y29sb3I6ICNERDRBNjg7XFxufVxcblxcbi50b2tlbi5yZWdleCxcXG4udG9rZW4uaW1wb3J0YW50LFxcbi50b2tlbi52YXJpYWJsZSB7XFxuXFx0Y29sb3I6ICNlOTA7XFxufVxcblxcbi50b2tlbi5pbXBvcnRhbnQsXFxuLnRva2VuLmJvbGQge1xcblxcdGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4udG9rZW4uaXRhbGljIHtcXG5cXHRmb250LXN0eWxlOiBpdGFsaWM7XFxufVxcblxcbi50b2tlbi5lbnRpdHkge1xcblxcdGN1cnNvcjogaGVscDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3ByaXNtanMvdGhlbWVzL3ByaXNtLmNzc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cclxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXHJcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xyXG5cdFx0XHRpZihpdGVtWzJdKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHByaXNtIGZyb20gJ3ByaXNtanMnO1xuaW1wb3J0ICdwcmlzbWpzL3RoZW1lcy9wcmlzbS5jc3MnO1xuXG5pbXBvcnQgaGFuZGxlRXZlbnQgZnJvbSAnLi9oYW5kbGUtZXZlbnQnO1xuaW1wb3J0IHBpbmNoSXQgZnJvbSAnLi4vc3JjLyc7XG5cbnBpbmNoSXQoJy5leGFtcGxlLW9uZSBpbWcnKTtcbnBpbmNoSXQoJy5leGFtcGxlLXR3byBpbWcnKTtcbnBpbmNoSXQoJy5leGFtcGxlLXRyZWUgaW1nJywge1xuICBtYXhTY2FsZTogNCxcbiAgbWluU2NhbGU6IDAuNSxcbiAgc25hcEJhY2tTcGVlZDogNTAwLFxufSk7XG5cbmNvbnN0IHBpbmNoSW1hZ2UgPSBwaW5jaEl0KCcuZXhhbXBsZS1mb3VyIGltZycsIHtcbiAgc25hcEJhY2tTcGVlZDogMTAwMCxcbn0pO1xuXG5kb2N1bWVudFxuICAucXVlcnlTZWxlY3RvcignLnJlc2V0LWJ1dHRvbicpXG4gIC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBwaW5jaEltYWdlLnJlc2V0KCk7XG4gIH0pO1xuXG5jb25zdCB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZXZlbnQtdGFyZ2V0Jyk7XG5jb25zdCBoYW5kbGVFdmVudEV4YW1wbGUgPSBoYW5kbGVFdmVudCh0YXJnZXQpO1xuY29uc3QgcGluY2hFdmVudCA9IHBpbmNoSXQoJy5leGFtcGxlLWZpdmUgaW1nJywge1xuICBzbmFwQmFja1NwZWVkOiAxMDAwLFxufSk7XG5cbnBpbmNoRXZlbnQub24oJ3RvdWNoc3RhcnQnLCBoYW5kbGVFdmVudEV4YW1wbGUpO1xucGluY2hFdmVudC5vbigndG91Y2htb3ZlJywgaGFuZGxlRXZlbnRFeGFtcGxlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2RvY3MvYXBwLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==