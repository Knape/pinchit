/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 16);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var sum = function sum(acc, next) {
  return acc + next;
};

/**
 * Calculates the average of multiple vectors (x, y values)
 */
var getVectorAvg = function getVectorAvg(vectors) {
  return {
    x: vectors.map(function (v) {
      return v.x;
    }).reduce(sum) / vectors.length,
    y: vectors.map(function (v) {
      return v.y;
    }).reduce(sum) / vectors.length
  };
};

var getElement = function getElement(type) {
  return function (el) {
    return el instanceof HTMLImageElement ? el[type] : 1;
  };
};

/**
 * isWithin - Check if value is between two values
 *
 * @param { Number } scale current scale value
 * @param { Object } minPinch, maxPinh
 * @return { Boolean }
 **/
var isWithin = exports.isWithin = function isWithin(scale, opts) {
  var maxScale = opts.maxScale,
      minScale = opts.minScale;

  return scale >= minScale && scale <= maxScale;
};

/**
 * addOffset - Combine current offset with old offset and returns a new offset
 *
 * @param { Object } lastOffset last offset
 * @param { Object } offset, new offset
 * @return { Object }
 **/
var addOffset = exports.addOffset = function addOffset(lastOffset, offset) {
  return {
    x: lastOffset.x + offset.x,
    y: lastOffset.y + offset.y
  };
};

var getX = exports.getX = getElement('offsetWidth');
var getY = exports.getY = getElement('offsetHeight');

/**
 * getScale - Check if value is between two values
 *
 * @param { Node } el current scale value
 * @return { Number }
 **/
var getInitialScale = exports.getInitialScale = function getInitialScale(el, image) {
  return el instanceof HTMLImageElement ? getX(el) / image.offsetWidth : 1;
};

/**
 * Scales the zoom factor relative to current state
 *
 * @param scale
 * @return the actual scale (can differ because of max min zoom factor)
 */
var getScaleFactor = exports.getScaleFactor = function getScaleFactor(scale, factor, opts) {
  var originalFactor = factor;
  var zoomFactor = factor * scale;
  var maxScaleTimes = opts.maxScaleTimes,
      minScaleTimes = opts.minScaleTimes;

  zoomFactor = Math.min(maxScaleTimes, Math.max(zoomFactor, minScaleTimes));
  return zoomFactor / originalFactor;
};

/**
 * Scales the zoom factor relative to current state
 *
 * @param scale
 * @return the actual scale (can differ because of max min zoom factor)
 */
var getZoomFactor = exports.getZoomFactor = function getZoomFactor(scale, factor, opts) {
  var zoomFactor = factor * scale;
  var maxScaleTimes = opts.maxScaleTimes,
      minScaleTimes = opts.minScaleTimes;

  return zoomFactor = Math.min(maxScaleTimes, Math.max(zoomFactor, minScaleTimes));
};

var getTouchCenter = exports.getTouchCenter = function getTouchCenter(touches) {
  return getVectorAvg(touches);
};

var calcNewScale = exports.calcNewScale = function calcNewScale(to) {
  var lastScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return to / lastScale;
};

/***/ }),
/* 1 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (target) {
  return function (e) {
    var newSpan = document.createElement('span');
    var time = new Date();
    time = time.getHours() + ':' + time.getMinutes() + ':' + time.getSeconds() + ',' + time.getMilliseconds();
    var newContent = document.createTextNode('[' + time + '] Event dispatched: "' + e.type + '"');
    newSpan.appendChild(newContent);
    target.appendChild(newSpan);
  };
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pinchIt = __webpack_require__(7);

var _pinchIt2 = _interopRequireDefault(_pinchIt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _pinchIt2.default;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/* **********************************************
     Begin prism-core.js
********************************************** */

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function(){

// Private helper vars
var lang = /\blang(?:uage)?-(\w+)\b/i;
var uniqueId = 0;

var _ = _self.Prism = {
	util: {
		encode: function (tokens) {
			if (tokens instanceof Token) {
				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
			} else if (_.util.type(tokens) === 'Array') {
				return tokens.map(_.util.encode);
			} else {
				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
			}
		},

		type: function (o) {
			return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
		},

		objId: function (obj) {
			if (!obj['__id']) {
				Object.defineProperty(obj, '__id', { value: ++uniqueId });
			}
			return obj['__id'];
		},

		// Deep clone a language definition (e.g. to extend it)
		clone: function (o) {
			var type = _.util.type(o);

			switch (type) {
				case 'Object':
					var clone = {};

					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = _.util.clone(o[key]);
						}
					}

					return clone;

				case 'Array':
					// Check for existence for IE8
					return o.map && o.map(function(v) { return _.util.clone(v); });
			}

			return o;
		}
	},

	languages: {
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);

			for (var key in redef) {
				lang[key] = redef[key];
			}

			return lang;
		},

		/**
		 * Insert a token before another token in a language literal
		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
		 * we cannot just provide an object, we need anobject and a key.
		 * @param inside The key (or language id) of the parent
		 * @param before The key to insert before. If not provided, the function appends instead.
		 * @param insert Object with the key/value pairs to insert
		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
		 */
		insertBefore: function (inside, before, insert, root) {
			root = root || _.languages;
			var grammar = root[inside];

			if (arguments.length == 2) {
				insert = arguments[1];

				for (var newToken in insert) {
					if (insert.hasOwnProperty(newToken)) {
						grammar[newToken] = insert[newToken];
					}
				}

				return grammar;
			}

			var ret = {};

			for (var token in grammar) {

				if (grammar.hasOwnProperty(token)) {

					if (token == before) {

						for (var newToken in insert) {

							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}

					ret[token] = grammar[token];
				}
			}

			// Update references in other language definitions
			_.languages.DFS(_.languages, function(key, value) {
				if (value === root[inside] && key != inside) {
					this[key] = ret;
				}
			});

			return root[inside] = ret;
		},

		// Traverse a language definition with Depth First Search
		DFS: function(o, callback, type, visited) {
			visited = visited || {};
			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					callback.call(o, i, o[i], type || i);

					if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, null, visited);
					}
					else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, i, visited);
					}
				}
			}
		}
	},
	plugins: {},

	highlightAll: function(async, callback) {
		var env = {
			callback: callback,
			selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
		};

		_.hooks.run("before-highlightall", env);

		var elements = env.elements || document.querySelectorAll(env.selector);

		for (var i=0, element; element = elements[i++];) {
			_.highlightElement(element, async === true, env.callback);
		}
	},

	highlightElement: function(element, async, callback) {
		// Find language
		var language, grammar, parent = element;

		while (parent && !lang.test(parent.className)) {
			parent = parent.parentNode;
		}

		if (parent) {
			language = (parent.className.match(lang) || [,''])[1].toLowerCase();
			grammar = _.languages[language];
		}

		// Set language on the element, if not present
		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

		// Set language on the parent, for styling
		parent = element.parentNode;

		if (/pre/i.test(parent.nodeName)) {
			parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
		}

		var code = element.textContent;

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};

		_.hooks.run('before-sanity-check', env);

		if (!env.code || !env.grammar) {
			if (env.code) {
				env.element.textContent = env.code;
			}
			_.hooks.run('complete', env);
			return;
		}

		_.hooks.run('before-highlight', env);

		if (async && _self.Worker) {
			var worker = new Worker(_.filename);

			worker.onmessage = function(evt) {
				env.highlightedCode = evt.data;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				callback && callback.call(env.element);
				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			};

			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code,
				immediateClose: true
			}));
		}
		else {
			env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

			_.hooks.run('before-insert', env);

			env.element.innerHTML = env.highlightedCode;

			callback && callback.call(element);

			_.hooks.run('after-highlight', env);
			_.hooks.run('complete', env);
		}
	},

	highlight: function (text, grammar, language) {
		var tokens = _.tokenize(text, grammar);
		return Token.stringify(_.util.encode(tokens), language);
	},

	tokenize: function(text, grammar, language) {
		var Token = _.Token;

		var strarr = [text];

		var rest = grammar.rest;

		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}

			delete grammar.rest;
		}

		tokenloop: for (var token in grammar) {
			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				var pattern = patterns[j],
					inside = pattern.inside,
					lookbehind = !!pattern.lookbehind,
					greedy = !!pattern.greedy,
					lookbehindLength = 0,
					alias = pattern.alias;

				if (greedy && !pattern.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
					pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
				}

				pattern = pattern.pattern || pattern;

				// Don’t cache length as it changes during the loop
				for (var i=0, pos = 0; i<strarr.length; pos += strarr[i].length, ++i) {

					var str = strarr[i];

					if (strarr.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						break tokenloop;
					}

					if (str instanceof Token) {
						continue;
					}

					pattern.lastIndex = 0;

					var match = pattern.exec(str),
					    delNum = 1;

					// Greedy patterns can override/remove up to two previously matched tokens
					if (!match && greedy && i != strarr.length - 1) {
						pattern.lastIndex = pos;
						match = pattern.exec(text);
						if (!match) {
							break;
						}

						var from = match.index + (lookbehind ? match[1].length : 0),
						    to = match.index + match[0].length,
						    k = i,
						    p = pos;

						for (var len = strarr.length; k < len && p < to; ++k) {
							p += strarr[k].length;
							// Move the index i to the element in strarr that is closest to from
							if (from >= p) {
								++i;
								pos = p;
							}
						}

						/*
						 * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
						 * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
						 */
						if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
							continue;
						}

						// Number of tokens to delete and replace with the new match
						delNum = k - i;
						str = text.slice(pos, p);
						match.index -= pos;
					}

					if (!match) {
						continue;
					}

					if(lookbehind) {
						lookbehindLength = match[1].length;
					}

					var from = match.index + lookbehindLength,
					    match = match[0].slice(lookbehindLength),
					    to = from + match.length,
					    before = str.slice(0, from),
					    after = str.slice(to);

					var args = [i, delNum];

					if (before) {
						args.push(before);
					}

					var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

					args.push(wrapped);

					if (after) {
						args.push(after);
					}

					Array.prototype.splice.apply(strarr, args);
				}
			}
		}

		return strarr;
	},

	hooks: {
		all: {},

		add: function (name, callback) {
			var hooks = _.hooks.all;

			hooks[name] = hooks[name] || [];

			hooks[name].push(callback);
		},

		run: function (name, env) {
			var callbacks = _.hooks.all[name];

			if (!callbacks || !callbacks.length) {
				return;
			}

			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	}
};

var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
	this.type = type;
	this.content = content;
	this.alias = alias;
	// Copy of the full string this token was created from
	this.length = (matchedStr || "").length|0;
	this.greedy = !!greedy;
};

Token.stringify = function(o, language, parent) {
	if (typeof o == 'string') {
		return o;
	}

	if (_.util.type(o) === 'Array') {
		return o.map(function(element) {
			return Token.stringify(element, language, o);
		}).join('');
	}

	var env = {
		type: o.type,
		content: Token.stringify(o.content, language, parent),
		tag: 'span',
		classes: ['token', o.type],
		attributes: {},
		language: language,
		parent: parent
	};

	if (env.type == 'comment') {
		env.attributes['spellcheck'] = 'true';
	}

	if (o.alias) {
		var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
		Array.prototype.push.apply(env.classes, aliases);
	}

	_.hooks.run('wrap', env);

	var attributes = Object.keys(env.attributes).map(function(name) {
		return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
	}).join(' ');

	return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';

};

if (!_self.document) {
	if (!_self.addEventListener) {
		// in Node.js
		return _self.Prism;
	}
 	// In worker
	_self.addEventListener('message', function(evt) {
		var message = JSON.parse(evt.data),
		    lang = message.language,
		    code = message.code,
		    immediateClose = message.immediateClose;

		_self.postMessage(_.highlight(code, _.languages[lang], lang));
		if (immediateClose) {
			_self.close();
		}
	}, false);

	return _self.Prism;
}

//Get current script and highlight
var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

if (script) {
	_.filename = script.src;

	if (document.addEventListener && !script.hasAttribute('data-manual')) {
		if(document.readyState !== "loading") {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(_.highlightAll);
			} else {
				window.setTimeout(_.highlightAll, 16);
			}
		}
		else {
			document.addEventListener('DOMContentLoaded', _.highlightAll);
		}
	}
}

return _self.Prism;

})();

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== 'undefined') {
	global.Prism = Prism;
}


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': /<!--[\w\W]*?-->/,
	'prolog': /<\?[\w\W]+?\?>/,
	'doctype': /<!DOCTYPE[\w\W]+?>/i,
	'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/i,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'attr-value': {
				pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
				inside: {
					'punctuation': /[=>"']/
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': /&#?[\da-z]{1,8};/i
};

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function(env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;


/* **********************************************
     Begin prism-css.js
********************************************** */

Prism.languages.css = {
	'comment': /\/\*[\w\W]*?\*\//,
	'atrule': {
		pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
		inside: {
			'rule': /@[\w-]+/
			// See rest below
		}
	},
	'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
	'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
	'string': {
		pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'property': /(\b|\B)[\w-]+(?=\s*:)/i,
	'important': /\B!important\b/i,
	'function': /[-a-z0-9]+(?=\()/i,
	'punctuation': /[(){};:]/
};

Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'style': {
			pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
			lookbehind: true,
			inside: Prism.languages.css,
			alias: 'language-css'
		}
	});
	
	Prism.languages.insertBefore('inside', 'attr-value', {
		'style-attr': {
			pattern: /\s*style=("|').*?\1/i,
			inside: {
				'attr-name': {
					pattern: /^\s*style/i,
					inside: Prism.languages.markup.tag.inside
				},
				'punctuation': /^\s*=\s*['"]|['"]\s*$/,
				'attr-value': {
					pattern: /.+/i,
					inside: Prism.languages.css
				}
			},
			alias: 'language-css'
		}
	}, Prism.languages.markup.tag);
}

/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
			lookbehind: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true
		}
	],
	'string': {
		pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
		lookbehind: true,
		inside: {
			punctuation: /(\.|\\)/
		}
	},
	'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(true|false)\b/,
	'function': /[a-z0-9_]+(?=\()/i,
	'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
	'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
});

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
		lookbehind: true,
		greedy: true
	}
});

Prism.languages.insertBefore('javascript', 'string', {
	'template-string': {
		pattern: /`(?:\\\\|\\?[^\\])*?`/,
		greedy: true,
		inside: {
			'interpolation': {
				pattern: /\$\{[^}]+\}/,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'script': {
			pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript,
			alias: 'language-javascript'
		}
	});
}

Prism.languages.js = Prism.languages.javascript;

/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
	if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
		return;
	}

	self.Prism.fileHighlight = function() {

		var Extensions = {
			'js': 'javascript',
			'py': 'python',
			'rb': 'ruby',
			'ps1': 'powershell',
			'psm1': 'powershell',
			'sh': 'bash',
			'bat': 'batch',
			'h': 'c',
			'tex': 'latex'
		};

		if(Array.prototype.forEach) { // Check to prevent error in IE8
			Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
				var src = pre.getAttribute('data-src');

				var language, parent = pre;
				var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
				while (parent && !lang.test(parent.className)) {
					parent = parent.parentNode;
				}

				if (parent) {
					language = (pre.className.match(lang) || [, ''])[1];
				}

				if (!language) {
					var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
					language = Extensions[extension] || extension;
				}

				var code = document.createElement('code');
				code.className = 'language-' + language;

				pre.textContent = '';

				code.textContent = 'Loading…';

				pre.appendChild(code);

				var xhr = new XMLHttpRequest();

				xhr.open('GET', src, true);

				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {

						if (xhr.status < 400 && xhr.responseText) {
							code.textContent = xhr.responseText;

							Prism.highlightElement(code);
						}
						else if (xhr.status >= 400) {
							code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
						}
						else {
							code.textContent = '✖ Error: File does not exist or is empty';
						}
					}
				};

				xhr.send(null);
			});
		}

	};

	document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(13);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(15)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!./../../css-loader/index.js!./prism.css", function() {
			var newContent = require("!!./../../css-loader/index.js!./prism.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {

  /**
   * default scale that will be set on element
   * @maxPinch {Number}
   */
  baseScale: 1,

  /**
   * max scale a node can reach
   * @maxPinch {Number}
   */
  maxScale: 3,

  /**
   * max scale a node can reach before bouncing back to maxScale
   * @maxScaleTimes {Number}
   */
  maxScaleTimes: 4,

  /**
   * min scale a node can reach
   * @minPinch {Number}
   */
  minScale: 1,

  /**
   * min scale a node can reach before bouncing back to minScale
   * @minScaleTimes {Number}
   */
  minScaleTimes: 0.8,

  /**
   * time for the snapBack of the pinch if the node has reach above
   * or below its pinch value
   * @snapBackSpeed {Number}
   */
  snapBackSpeed: 200,

  /**
   * Basic easing functions: https://developer.mozilla.org/de/docs/Web/CSS/transition-timing-function
   * cubic bezier easing functions: http://easings.net/de
   * @ease {String}
   */
  ease: 'ease'
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
//


var _dispatchEvent = __webpack_require__(9);

var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

var _handleEvent = __webpack_require__(12);

var _handleElement = __webpack_require__(11);

var _handleElement2 = _interopRequireDefault(_handleElement);

var _handlePinch = __webpack_require__(0);

var _handleDrag = __webpack_require__(10);

var _defaults = __webpack_require__(6);

var _defaults2 = _interopRequireDefault(_defaults);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var first = function first(items) {
  return items[0];
};

var pinchIt = function pinchIt(targets) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // private variable cache
  var element = null;

  var scaling = void 0;
  var lastScale = 1;
  var startTouches = void 0;

  var zoomFactor = 1;

  var offset = { x: 0, y: 0 };
  var lastZoomCenter = false;
  var lastDragPosition = false;

  // Base configuration for the pinch instance
  var opts = _extends({}, _defaults2.default, options);

  var _eventDispatcher = (0, _dispatchEvent2.default)(),
      on = _eventDispatcher.on,
      dispatch = _eventDispatcher.dispatch;

  /**
   *  dispatchPinchEvent - Shorthand method for creating events
   *
   *  @param { String } phase
   *  @param { String } type
   *  @param { Object } details
   *  @return { Void }
   **/


  var dispatchPinchEvent = function dispatchPinchEvent(eventName, phase) {
    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    dispatch(eventName, Object.assign(data, {
      phase: phase
    }));
  };

  var resetGlobals = function resetGlobals() {
    scaling = undefined;
    lastScale = 1;
    startTouches = null;
    zoomFactor = 1;
    lastZoomCenter = false;

    lastDragPosition = false;
    offset = { x: 0, y: 0 };
  };

  // event handling
  /**
   * Set scaling if we are using more then one finger
   * and captures our first punch point
   *
   * private
   * @param { Object } e the event from our eventlistener
   */
  var onTouchstart = function onTouchstart(e) {
    dispatchPinchEvent('touchstart', 'before', e);

    scaling = e.touches.length === 2;
    startTouches = Array.from(e.touches);
    lastScale = 1;

    if ((0, _handleEvent.detectDoubleTap)(e)) {
      var image = e.currentTarget.querySelector('img');
      (0, _handleElement2.default)(e.target, image, 1, { x: 0, y: 0 }, opts.snapBackSpeed, opts.ease);
      resetGlobals();
    }

    dispatchPinchEvent('touchstart', 'after', e);
  };

  var onTouchmove = function onTouchmove(e) {
    dispatchPinchEvent('touchmove', 'before', e);

    if ((!scaling || !startTouches) && zoomFactor > 1) {
      (0, _handleEvent.cancelEvent)(e);

      var touch = first((0, _handleEvent.getTouches)(e.currentTarget, Array.from(e.touches)));
      var dragOffset = (0, _handleDrag.drag)(touch, lastDragPosition, offset, zoomFactor);

      offset = (0, _handleDrag.sanitizeOffset)(e.target, dragOffset, zoomFactor);
      lastDragPosition = touch;
    } else if (scaling && startTouches) {
      (0, _handleEvent.cancelEvent)(e);

      // a relative scale factor is used
      var touchCenter = (0, _handlePinch.getTouchCenter)((0, _handleEvent.getTouches)(e.currentTarget, Array.from(e.touches)));
      var newScale = (0, _handleEvent.calcScale)(e.currentTarget, startTouches, Array.from(e.touches));
      var scaleValue = (0, _handlePinch.calcNewScale)(newScale, lastScale);

      var scale = (0, _handlePinch.getScaleFactor)(scaleValue, zoomFactor, opts);
      zoomFactor = (0, _handlePinch.getZoomFactor)(scaleValue, zoomFactor, opts);

      offset = (0, _handlePinch.addOffset)(offset, {
        x: (scale - 1) * (touchCenter.x + offset.x),
        y: (scale - 1) * (touchCenter.y + offset.y)
      });

      lastScale = newScale;
      offset = (0, _handleDrag.drag)(touchCenter, lastZoomCenter, offset, zoomFactor);
      lastZoomCenter = touchCenter;
    }

    var image = e.currentTarget.querySelector('img');
    (0, _handleElement2.default)(e.target, image, zoomFactor, offset, 0, opts.ease);

    dispatchPinchEvent('touchmove', 'after', e);
  };

  var onTouchend = function onTouchend(e) {
    dispatchPinchEvent('touchend', 'before', e);

    lastDragPosition = false;
    lastZoomCenter = false;
    lastScale = 1;
    if (zoomFactor) {
      if (!(0, _handlePinch.isWithin)(zoomFactor, opts)) {
        var image = e.currentTarget.querySelector('img');
        var isLessThan = (0, _handlePinch.getInitialScale)(e.target, image) * zoomFactor < opts.minScale;
        zoomFactor = isLessThan ? opts.minScale : opts.maxScale;
        offset = (0, _handleDrag.sanitizeOffset)(e.target, offset, zoomFactor);
        (0, _handleElement2.default)(e.target, image, zoomFactor, offset, opts.snapBackSpeed, opts.ease);
      }
    }

    dispatchPinchEvent('touchend', 'after', e);
  };

  var attachEvents = function attachEvents(el) {
    el.addEventListener('touchstart', onTouchstart);
    el.addEventListener('touchmove', onTouchmove);
    el.addEventListener('touchend', onTouchend);
  };

  var detachhEvents = function detachhEvents(el) {
    el.removeEventListener('touchstart', onTouchstart);
    el.removeEventListener('touchmove', onTouchmove);
    el.removeEventListener('touchend', onTouchend);
  };

  /**
   * public
   * reset function:
   * @param { Number } duration
   * @param { String } easing
   * @return { Void }
   */
  var reset = function reset() {
    if (!element) return;
    var snapBackSpeed = opts.snapBackSpeed,
        easing = opts.easing;

    console.log('reset?');
    var image = element.querySelector('img');
    console.log(image);
    (0, _handleElement2.default)(element, image, 1, { x: 0, y: 0 }, snapBackSpeed, easing);
    resetGlobals();
  };

  /**
   * public
   * destroy function: called to gracefully destroy the lory instance
   * @return { Void }
   */
  var destroy = function destroy() {
    dispatchPinchEvent('destroy', 'before', {});
    if (!element) return;
    reset();
    // remove event listeners
    detachhEvents(element);
    element = null;
    resetGlobals();
    dispatchPinchEvent('destroy', 'after', {});
  };

  /**
   * setup - Init function
   *
   * @param { String, Object }
   * @return { Void }
   **/
  var setup = function setup(target) {
    if (element) destroy();
    dispatchPinchEvent('init', 'before', {});
    // resolve target
    // pinchit allows for both a node or a string to be passed
    switch (typeof target === 'undefined' ? 'undefined' : _typeof(target)) {
      case 'object':
        element = target;
        break;
      case 'string':
        element = document.querySelector(target);
        break;
      default:
        element = null;
        console.warn('missing target, either pass an node or a string');
    }

    if (element) {
      console.log(element);
      attachEvents(element);
    }

    dispatchPinchEvent('init', 'after', {});
  };

  // trigger initial setup
  setup(targets);

  return {
    setup: setup,
    reset: reset,
    destroy: destroy,
    element: element,
    on: on
  };
};

exports.default = pinchIt;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

/**
 * Detecting prefixes for saving time and bytes
 */
exports.default = function () {
  var transform = void 0;
  var transition = void 0;
  var transitionEnd = void 0;
  var hasScale3d = void 0;

  (function () {
    var el = document.createElement('_');
    var style = el.style;

    if (style.webkitTransition === '') {
      transitionEnd = 'webkitTransitionEnd';
      transition = 'webkitTransition';
    }

    if (style.transition === '') {
      transitionEnd = 'transitionend';
      transition = 'transition';
    }

    if (style.webkitTransform === '') {
      transform = 'webkitTransform';
    }

    if (style.msTransform === '') {
      transform = 'msTransform';
    }

    if (style.transform === '') {
      transform = 'transform';
    }

    document.body.insertBefore(el, null);
    style[transform] = 'translate3d(0, 0, 0)';
    hasScale3d = !!global.getComputedStyle(el).getPropertyValue(transform);
    document.body.removeChild(el);
  })();

  return {
    transform: transform,
    transition: transition,
    transitionEnd: transitionEnd,
    hasScale3d: hasScale3d
  };
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});


/**
 * dispatch custom events
 */

var eventDispatcher = function eventDispatcher() {
  var events = {};

  /**
   * Register a handler for event, to be fired
   * for every event.
   */
  var on = function on(eventName, handler) {
    events[eventName] = events[eventName] || [];
    events[eventName].push(handler);
    return undefined;
  };

  /**
   * Deregister a handler for event.
   */
  var off = function off(eventName, handler) {
    if (events[eventName]) {
      for (var i = 0; i < events[eventName].length; i += 1) {
        if (events[eventName][i] === handler) {
          events[eventName].splice(i, 1);
          break;
        }
      }
    }
  };

  var dispatch = function dispatch(eventName, data) {
    if (events[eventName]) {
      events[eventName].forEach(function (fn) {
        fn(data);
      });
    }
  };

  return {
    on: on,
    off: off,
    dispatch: dispatch
  };
};

exports.default = eventDispatcher;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drag = exports.sanitizeOffset = undefined;

var _handlePinch = __webpack_require__(0);

var calcMax = function calcMax(el, differ, zoomFactor) {
  return {
    maxX: (zoomFactor - differ) * (0, _handlePinch.getX)(el),
    maxY: (zoomFactor - differ) * (0, _handlePinch.getY)(el)
  };
};

var sanitizeOffset = exports.sanitizeOffset = function sanitizeOffset(el, offset, zoomFactor) {
  var _calcMax = calcMax(el, 1, zoomFactor),
      maxX = _calcMax.maxX,
      maxY = _calcMax.maxY;

  var maxOffsetX = Math.max(maxX, 0);
  var maxOffsetY = Math.max(maxY, 0);
  var minOffsetX = Math.min(maxX, 0);
  var minOffsetY = Math.min(maxY, 0);

  return {
    x: Math.min(Math.max(offset.x, minOffsetX), maxOffsetX),
    y: Math.min(Math.max(offset.y, minOffsetY), maxOffsetY)
  };
};

var drag = exports.drag = function drag(center, lastCenter, lastOffset, zoomFactor) {
  return Object.prototype.hasOwnProperty.call(lastCenter, 'x') ? (0, _handlePinch.addOffset)(lastOffset, {
    x: -((center.x - lastCenter.x) * zoomFactor / zoomFactor),
    y: -((center.y - lastCenter.y) * zoomFactor / zoomFactor)
  }) : lastOffset;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _detectPrefixes = __webpack_require__(8);

var _detectPrefixes2 = _interopRequireDefault(_detectPrefixes);

var _handlePinch = __webpack_require__(0);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var prefixes = (0, _detectPrefixes2.default)();

var handleAnimation = function handleAnimation(el, transition, duration, ease) {
  var style = el.style;

  style.transformOrigin = '0% 0%';
  style[transition + 'TimingFunction'] = ease;
  style[transition + 'Duration'] = duration + 'ms';
};

/**
 * scaleElement -transdorms to a given position in a given time in milliseconds
 *
 * @param { Object } el element from the events
 * @param { Number } pinch number where to scale to
 * @param { Object } coords object where to translate to
 * @param { Number } duration time in milliseconds for the transistion
 * @param { String } ease easing css property
 * @return { Void }
 */

exports.default = function (el, image, pinch, coords, duration, ease) {
  var transition = prefixes.transition,
      transform = prefixes.transform,
      hasScale3d = prefixes.hasScale3d;
  var style = image.style;


  var zoomFactor = (0, _handlePinch.getInitialScale)(el, image) * pinch;

  var offsetX = -coords.x;
  var offsetY = -coords.y;

  handleAnimation(image, transition, duration, ease);
  var scaleProp = hasScale3d ? 'scale3d(' + zoomFactor + ', ' + zoomFactor + ', 1)' : 'scale(' + zoomFactor + ', ' + zoomFactor + ')';
  var translateProp = 'translate(' + offsetX + 'px, ' + offsetY + 'px)';

  style[transform] = translateProp + ' ' + scaleProp;
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var lastTouchStart = 0;

/**
 * cancelEvent - Cancel Events so we dont bubble up our events to the document
 *
 * @param { Object } event
 * @return { Void }
 **/
var cancelEvent = exports.cancelEvent = function cancelEvent(e) {
  e.stopPropagation();
  e.preventDefault();
};

/**
 * detectDoubleTap - Check if we are double tapping
 *
 * @param { Object } event
 * @return { Boolean }
 **/
var detectDoubleTap = exports.detectDoubleTap = function detectDoubleTap(e) {
  var time = new Date().getTime();

  if (e.touches.length > 1) {
    lastTouchStart = 0;
  }

  if (time - lastTouchStart < 300) {
    cancelEvent(event);
    return true;
  }

  if (e.touches.length === 1) {
    lastTouchStart = time;
  }
  return false;
};

/**
 * Returns the touches of an event relative to the container offset
 *
 * @param event
 * @return array touches
 */
var getTouches = exports.getTouches = function getTouches(el, touches) {
  var position = el.getBoundingClientRect();
  return touches.map(function (touch) {
    return {
      x: touch.pageX - (position.left + document.body.scrollLeft),
      y: touch.pageY - (position.top + document.body.scrollTop)
    };
  });
};

/**
 * getDistance - Calculate the distance between our fingers
 *
 * @param { Array } touches touches passas an array from TouchList
 * @return { Number } the calcualted distance between the fingers
 **/
var getDistance = exports.getDistance = function getDistance(touches) {
  var _touches = _slicedToArray(touches, 2),
      first = _touches[0],
      second = _touches[1];

  return Math.sqrt((first.x - second.x) * (first.x - second.x) + (first.y - second.y) * (first.y - second.y));
};

/**
 * calcScale - Calculate the distance between where we start our pinch
 * to where we end it
 *
 * @param { Array } startTouch The starting point of our touch
 * @param { Array } endTouch The current point of our touch
 * @return { Number }
 */
var calcScale = exports.calcScale = function calcScale(el, startTouch, endTouch) {
  return getDistance(getTouches(el, endTouch)) / getDistance(getTouches(el, startTouch));
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(14)();
// imports


// module
exports.push([module.i, "/**\n * prism.js default theme for JavaScript, CSS and HTML\n * Based on dabblet (http://dabblet.com)\n * @author Lea Verou\n */\n\ncode[class*=\"language-\"],\npre[class*=\"language-\"] {\n\tcolor: black;\n\tbackground: none;\n\ttext-shadow: 0 1px white;\n\tfont-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;\n\ttext-align: left;\n\twhite-space: pre;\n\tword-spacing: normal;\n\tword-break: normal;\n\tword-wrap: normal;\n\tline-height: 1.5;\n\n\t-moz-tab-size: 4;\n\t-o-tab-size: 4;\n\ttab-size: 4;\n\n\t-webkit-hyphens: none;\n\t-moz-hyphens: none;\n\t-ms-hyphens: none;\n\thyphens: none;\n}\n\npre[class*=\"language-\"]::-moz-selection, pre[class*=\"language-\"] ::-moz-selection,\ncode[class*=\"language-\"]::-moz-selection, code[class*=\"language-\"] ::-moz-selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\npre[class*=\"language-\"]::selection, pre[class*=\"language-\"] ::selection,\ncode[class*=\"language-\"]::selection, code[class*=\"language-\"] ::selection {\n\ttext-shadow: none;\n\tbackground: #b3d4fc;\n}\n\n@media print {\n\tcode[class*=\"language-\"],\n\tpre[class*=\"language-\"] {\n\t\ttext-shadow: none;\n\t}\n}\n\n/* Code blocks */\npre[class*=\"language-\"] {\n\tpadding: 1em;\n\tmargin: .5em 0;\n\toverflow: auto;\n}\n\n:not(pre) > code[class*=\"language-\"],\npre[class*=\"language-\"] {\n\tbackground: #f5f2f0;\n}\n\n/* Inline code */\n:not(pre) > code[class*=\"language-\"] {\n\tpadding: .1em;\n\tborder-radius: .3em;\n\twhite-space: normal;\n}\n\n.token.comment,\n.token.prolog,\n.token.doctype,\n.token.cdata {\n\tcolor: slategray;\n}\n\n.token.punctuation {\n\tcolor: #999;\n}\n\n.namespace {\n\topacity: .7;\n}\n\n.token.property,\n.token.tag,\n.token.boolean,\n.token.number,\n.token.constant,\n.token.symbol,\n.token.deleted {\n\tcolor: #905;\n}\n\n.token.selector,\n.token.attr-name,\n.token.string,\n.token.char,\n.token.builtin,\n.token.inserted {\n\tcolor: #690;\n}\n\n.token.operator,\n.token.entity,\n.token.url,\n.language-css .token.string,\n.style .token.string {\n\tcolor: #a67f59;\n\tbackground: hsla(0, 0%, 100%, .5);\n}\n\n.token.atrule,\n.token.attr-value,\n.token.keyword {\n\tcolor: #07a;\n}\n\n.token.function {\n\tcolor: #DD4A68;\n}\n\n.token.regex,\n.token.important,\n.token.variable {\n\tcolor: #e90;\n}\n\n.token.important,\n.token.bold {\n\tfont-weight: bold;\n}\n.token.italic {\n\tfont-style: italic;\n}\n\n.token.entity {\n\tcursor: help;\n}\n", ""]);

// exports


/***/ }),
/* 14 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function() {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		var result = [];
		for(var i = 0; i < this.length; i++) {
			var item = this[i];
			if(item[2]) {
				result.push("@media " + item[2] + "{" + item[1] + "}");
			} else {
				result.push(item[1]);
			}
		}
		return result.join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
	}),
	getHeadElement = memoize(function () {
		return document.head || document.getElementsByTagName("head")[0];
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [];

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the bottom of <head>.
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
}

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var head = getHeadElement();
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			head.insertBefore(styleElement, head.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			head.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		head.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	styleElement.type = "text/css";
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	linkElement.rel = "stylesheet";
	insertStyleElement(options, linkElement);
	return linkElement;
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _prismjs = __webpack_require__(4);

var _prismjs2 = _interopRequireDefault(_prismjs);

__webpack_require__(5);

var _handleEvent = __webpack_require__(2);

var _handleEvent2 = _interopRequireDefault(_handleEvent);

var _src = __webpack_require__(3);

var _src2 = _interopRequireDefault(_src);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _src2.default)('.example-one .img-wrapper');
(0, _src2.default)('.example-tree .img-wrapper', {
  maxScale: 4,
  minScale: 0.5,
  snapBackSpeed: 500
});

var pinchImage = (0, _src2.default)('.example-four .img-wrapper', {
  snapBackSpeed: 1000
});

document.querySelector('.reset-button').addEventListener('click', function () {
  pinchImage.reset();
});

var target = document.querySelector('.event-target');
var handleEventExample = (0, _handleEvent2.default)(target);
var pinchEvent = (0, _src2.default)('.example-five .img-wrapper', {
  target: 'img',
  snapBackSpeed: 1000
});

pinchEvent.on('touchstart', handleEventExample);
pinchEvent.on('touchmove', handleEventExample);

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzkyZTM3MTFlNzY3YzA0MWJjZjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2hhbmRsZS1waW5jaC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL2RvY3MvaGFuZGxlLWV2ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaXNtanMvcHJpc20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcmlzbWpzL3RoZW1lcy9wcmlzbS5jc3M/NjgwZCIsIndlYnBhY2s6Ly8vLi9zcmMvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BpbmNoLWl0LmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9kZXRlY3QtcHJlZml4ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2Rpc3BhdGNoLWV2ZW50LmpzIiwid2VicGFjazovLy8uL3NyYy91dGlscy9oYW5kbGUtZHJhZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvaGFuZGxlLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2hhbmRsZS1ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3ByaXNtanMvdGhlbWVzL3ByaXNtLmNzcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9kb2NzL2FwcC5qcyJdLCJuYW1lcyI6WyJzdW0iLCJhY2MiLCJuZXh0IiwiZ2V0VmVjdG9yQXZnIiwidmVjdG9ycyIsIngiLCJtYXAiLCJ2IiwicmVkdWNlIiwibGVuZ3RoIiwieSIsImdldEVsZW1lbnQiLCJ0eXBlIiwiZWwiLCJIVE1MSW1hZ2VFbGVtZW50IiwiaXNXaXRoaW4iLCJzY2FsZSIsIm9wdHMiLCJtYXhTY2FsZSIsIm1pblNjYWxlIiwiYWRkT2Zmc2V0IiwibGFzdE9mZnNldCIsIm9mZnNldCIsImdldFgiLCJnZXRZIiwiZ2V0SW5pdGlhbFNjYWxlIiwiaW1hZ2UiLCJvZmZzZXRXaWR0aCIsImdldFNjYWxlRmFjdG9yIiwiZmFjdG9yIiwib3JpZ2luYWxGYWN0b3IiLCJ6b29tRmFjdG9yIiwibWF4U2NhbGVUaW1lcyIsIm1pblNjYWxlVGltZXMiLCJNYXRoIiwibWluIiwibWF4IiwiZ2V0Wm9vbUZhY3RvciIsImdldFRvdWNoQ2VudGVyIiwidG91Y2hlcyIsImNhbGNOZXdTY2FsZSIsInRvIiwibGFzdFNjYWxlIiwiZSIsIm5ld1NwYW4iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ0aW1lIiwiRGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJuZXdDb250ZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJhcHBlbmRDaGlsZCIsInRhcmdldCIsImJhc2VTY2FsZSIsInNuYXBCYWNrU3BlZWQiLCJlYXNlIiwiZmlyc3QiLCJpdGVtcyIsInBpbmNoSXQiLCJ0YXJnZXRzIiwib3B0aW9ucyIsImVsZW1lbnQiLCJzY2FsaW5nIiwic3RhcnRUb3VjaGVzIiwibGFzdFpvb21DZW50ZXIiLCJsYXN0RHJhZ1Bvc2l0aW9uIiwib24iLCJkaXNwYXRjaCIsImRpc3BhdGNoUGluY2hFdmVudCIsImV2ZW50TmFtZSIsInBoYXNlIiwiZGF0YSIsIk9iamVjdCIsImFzc2lnbiIsInJlc2V0R2xvYmFscyIsInVuZGVmaW5lZCIsIm9uVG91Y2hzdGFydCIsIkFycmF5IiwiZnJvbSIsImN1cnJlbnRUYXJnZXQiLCJxdWVyeVNlbGVjdG9yIiwib25Ub3VjaG1vdmUiLCJ0b3VjaCIsImRyYWdPZmZzZXQiLCJ0b3VjaENlbnRlciIsIm5ld1NjYWxlIiwic2NhbGVWYWx1ZSIsIm9uVG91Y2hlbmQiLCJpc0xlc3NUaGFuIiwiYXR0YWNoRXZlbnRzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImRldGFjaGhFdmVudHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVzZXQiLCJlYXNpbmciLCJjb25zb2xlIiwibG9nIiwiZGVzdHJveSIsInNldHVwIiwid2FybiIsInRyYW5zZm9ybSIsInRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uRW5kIiwiaGFzU2NhbGUzZCIsInN0eWxlIiwid2Via2l0VHJhbnNpdGlvbiIsIndlYmtpdFRyYW5zZm9ybSIsIm1zVHJhbnNmb3JtIiwiYm9keSIsImluc2VydEJlZm9yZSIsImdsb2JhbCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicmVtb3ZlQ2hpbGQiLCJldmVudERpc3BhdGNoZXIiLCJldmVudHMiLCJoYW5kbGVyIiwicHVzaCIsIm9mZiIsImkiLCJzcGxpY2UiLCJmb3JFYWNoIiwiZm4iLCJjYWxjTWF4IiwiZGlmZmVyIiwibWF4WCIsIm1heFkiLCJzYW5pdGl6ZU9mZnNldCIsIm1heE9mZnNldFgiLCJtYXhPZmZzZXRZIiwibWluT2Zmc2V0WCIsIm1pbk9mZnNldFkiLCJkcmFnIiwiY2VudGVyIiwibGFzdENlbnRlciIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInByZWZpeGVzIiwiaGFuZGxlQW5pbWF0aW9uIiwiZHVyYXRpb24iLCJ0cmFuc2Zvcm1PcmlnaW4iLCJwaW5jaCIsImNvb3JkcyIsIm9mZnNldFgiLCJvZmZzZXRZIiwic2NhbGVQcm9wIiwidHJhbnNsYXRlUHJvcCIsImxhc3RUb3VjaFN0YXJ0IiwiY2FuY2VsRXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsImRldGVjdERvdWJsZVRhcCIsImdldFRpbWUiLCJldmVudCIsImdldFRvdWNoZXMiLCJwb3NpdGlvbiIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhZ2VYIiwibGVmdCIsInNjcm9sbExlZnQiLCJwYWdlWSIsInRvcCIsInNjcm9sbFRvcCIsImdldERpc3RhbmNlIiwic2Vjb25kIiwic3FydCIsImNhbGNTY2FsZSIsInN0YXJ0VG91Y2giLCJlbmRUb3VjaCIsInBpbmNoSW1hZ2UiLCJoYW5kbGVFdmVudEV4YW1wbGUiLCJwaW5jaEV2ZW50Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlEQSxJQUFNQSxNQUFNLFNBQU5BLEdBQU0sQ0FBQ0MsR0FBRCxFQUFNQyxJQUFOO0FBQUEsU0FBZUQsTUFBTUMsSUFBckI7QUFBQSxDQUFaOztBQUVBOzs7QUFHQSxJQUFNQyxlQUFlLFNBQWZBLFlBQWUsQ0FBQ0MsT0FBRDtBQUFBLFNBQXFDO0FBQ3hEQyxPQUFHRCxRQUFRRSxHQUFSLENBQVk7QUFBQSxhQUFNQyxFQUFFRixDQUFSO0FBQUEsS0FBWixFQUF3QkcsTUFBeEIsQ0FBK0JSLEdBQS9CLElBQXNDSSxRQUFRSyxNQURPO0FBRXhEQyxPQUFHTixRQUFRRSxHQUFSLENBQVk7QUFBQSxhQUFNQyxFQUFFRyxDQUFSO0FBQUEsS0FBWixFQUF3QkYsTUFBeEIsQ0FBK0JSLEdBQS9CLElBQXNDSSxRQUFRSztBQUZPLEdBQXJDO0FBQUEsQ0FBckI7O0FBS0EsSUFBTUUsYUFBYSxTQUFiQSxVQUFhLENBQUNDLElBQUQ7QUFBQSxTQUFrQixVQUFDQyxFQUFEO0FBQUEsV0FDbENBLGNBQWNDLGdCQUFmLEdBQ0VELEdBQUdE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QTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDclBBOzs7O0FBQ0E7O0FBRUE7Ozs7QUFDQTs7Ozs7O0FBRUEsbUJBQVEsMkJBQVI7QUFDQSxtQkFBUSw0QkFBUixFQUFzQztBQUNwQzFKLFlBQVUsQ0FEMEI7QUFFcENDLFlBQVUsR0FGMEI7QUFHcEN1QyxpQkFBZTtBQUhxQixDQUF0Qzs7QUFNQSxJQUFNb0gsYUFBYSxtQkFBUSw0QkFBUixFQUFzQztBQUN2RHBILGlCQUFlO0FBRHdDLENBQXRDLENBQW5COztBQUlBYixTQUNHdUMsYUFESCxDQUNpQixlQURqQixFQUVHVSxnQkFGSCxDQUVvQixPQUZwQixFQUU2QixZQUFNO0FBQy9CZ0YsYUFBVzdFLEtBQVg7QUFDRCxDQUpIOztBQU1BLElBQU16QyxTQUFTWCxTQUFTdUMsYUFBVCxDQUF1QixlQUF2QixDQUFmO0FBQ0EsSUFBTTJGLHFCQUFxQiwyQkFBWXZILE1BQVosQ0FBM0I7QUFDQSxJQUFNd0gsYUFBYSxtQkFBUSw0QkFBUixFQUFzQztBQUN2RHhILFVBQVEsS0FEK0M7QUFFdkRFLGlCQUFlO0FBRndDLENBQXRDLENBQW5COztBQUtBc0gsV0FBVzFHLEVBQVgsQ0FBYyxZQUFkLEVBQTRCeUcsa0JBQTVCO0FBQ0FDLFdBQVcxRyxFQUFYLENBQWMsV0FBZCxFQUEyQnlHLGtCQUEzQixFIiwiZmlsZSI6ImJ1bmRsZS5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvanMvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTYpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGM5MmUzNzExZTc2N2MwNDFiY2YyIiwiLy8gQGZsb3dcblxuY29uc3Qgc3VtID0gKGFjYywgbmV4dCkgPT4gYWNjICsgbmV4dDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhdmVyYWdlIG9mIG11bHRpcGxlIHZlY3RvcnMgKHgsIHkgdmFsdWVzKVxuICovXG5jb25zdCBnZXRWZWN0b3JBdmcgPSAodmVjdG9yczogQXJyYXk8T2JqZWN0Pik6IE9iamVjdCA9PiAoe1xuICB4OiB2ZWN0b3JzLm1hcCh2ID0+ICh2LngpKS5yZWR1Y2Uoc3VtKSAvIHZlY3RvcnMubGVuZ3RoLFxuICB5OiB2ZWN0b3JzLm1hcCh2ID0+ICh2LnkpKS5yZWR1Y2Uoc3VtKSAvIHZlY3RvcnMubGVuZ3RoLFxufSk7XG5cbmNvbnN0IGdldEVsZW1lbnQgPSAodHlwZTogc3RyaW5nKSA9PiAoZWw6IEV2ZW50VGFyZ2V0KTogbnVtYmVyID0+IChcbiAgKGVsIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudClcbiAgPyBlbFt0eXBlXVxuICA6IDFcbik7XG5cbi8qKlxuICogaXNXaXRoaW4gLSBDaGVjayBpZiB2YWx1ZSBpcyBiZXR3ZWVuIHR3byB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0geyBOdW1iZXIgfSBzY2FsZSBjdXJyZW50IHNjYWxlIHZhbHVlXG4gKiBAcGFyYW0geyBPYmplY3QgfSBtaW5QaW5jaCwgbWF4UGluaFxuICogQHJldHVybiB7IEJvb2xlYW4gfVxuICoqL1xuZXhwb3J0IGNvbnN0IGlzV2l0aGluID0gKHNjYWxlOiBudW1iZXIsIG9wdHM6IE9iamVjdCk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCB7IG1heFNjYWxlLCBtaW5TY2FsZSB9ID0gb3B0cztcbiAgcmV0dXJuIChzY2FsZSA+PSBtaW5TY2FsZSkgJiYgKHNjYWxlIDw9IG1heFNjYWxlKTtcbn07XG5cbi8qKlxuICogYWRkT2Zmc2V0IC0gQ29tYmluZSBjdXJyZW50IG9mZnNldCB3aXRoIG9sZCBvZmZzZXQgYW5kIHJldHVybnMgYSBuZXcgb2Zmc2V0XG4gKlxuICogQHBhcmFtIHsgT2JqZWN0IH0gbGFzdE9mZnNldCBsYXN0IG9mZnNldFxuICogQHBhcmFtIHsgT2JqZWN0IH0gb2Zmc2V0LCBuZXcgb2Zmc2V0XG4gKiBAcmV0dXJuIHsgT2JqZWN0IH1cbiAqKi9cbmV4cG9ydCBjb25zdCBhZGRPZmZzZXQgPSAobGFzdE9mZnNldDogT2JqZWN0LCBvZmZzZXQ6IE9iamVjdCk6IE9iamVjdCA9PiAoe1xuICB4OiBsYXN0T2Zmc2V0LnggKyBvZmZzZXQueCxcbiAgeTogbGFzdE9mZnNldC55ICsgb2Zmc2V0LnksXG59KTtcblxuZXhwb3J0IGNvbnN0IGdldFggPSBnZXRFbGVtZW50KCdvZmZzZXRXaWR0aCcpO1xuZXhwb3J0IGNvbnN0IGdldFkgPSBnZXRFbGVtZW50KCdvZmZzZXRIZWlnaHQnKTtcblxuLyoqXG4gKiBnZXRTY2FsZSAtIENoZWNrIGlmIHZhbHVlIGlzIGJldHdlZW4gdHdvIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7IE5vZGUgfSBlbCBjdXJyZW50IHNjYWxlIHZhbHVlXG4gKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAqKi9cbmV4cG9ydCBjb25zdCBnZXRJbml0aWFsU2NhbGUgPSAoZWw6IEV2ZW50VGFyZ2V0LCBpbWFnZTogSFRNTEVsZW1lbnQpOiBudW1iZXIgPT4gKFxuICAoZWwgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KVxuICA/IGdldFgoZWwpIC8gaW1hZ2Uub2Zmc2V0V2lkdGhcbiAgOiAxXG4pO1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgem9vbSBmYWN0b3IgcmVsYXRpdmUgdG8gY3VycmVudCBzdGF0ZVxuICpcbiAqIEBwYXJhbSBzY2FsZVxuICogQHJldHVybiB0aGUgYWN0dWFsIHNjYWxlIChjYW4gZGlmZmVyIGJlY2F1c2Ugb2YgbWF4IG1pbiB6b29tIGZhY3RvcilcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFNjYWxlRmFjdG9yID0gKHNjYWxlOiBudW1iZXIsIGZhY3RvcjogbnVtYmVyLCBvcHRzOiBPYmplY3QpOiBPYmplY3QgPT4ge1xuICBjb25zdCBvcmlnaW5hbEZhY3RvciA9IGZhY3RvcjtcbiAgbGV0IHpvb21GYWN0b3IgPSBmYWN0b3IgKiBzY2FsZTtcbiAgY29uc3QgeyBtYXhTY2FsZVRpbWVzLCBtaW5TY2FsZVRpbWVzIH0gPSBvcHRzO1xuICB6b29tRmFjdG9yID0gTWF0aC5taW4obWF4U2NhbGVUaW1lcywgTWF0aC5tYXgoem9vbUZhY3RvciwgbWluU2NhbGVUaW1lcykpO1xuICByZXR1cm4gem9vbUZhY3RvciAvIG9yaWdpbmFsRmFjdG9yO1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIHpvb20gZmFjdG9yIHJlbGF0aXZlIHRvIGN1cnJlbnQgc3RhdGVcbiAqXG4gKiBAcGFyYW0gc2NhbGVcbiAqIEByZXR1cm4gdGhlIGFjdHVhbCBzY2FsZSAoY2FuIGRpZmZlciBiZWNhdXNlIG9mIG1heCBtaW4gem9vbSBmYWN0b3IpXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRab29tRmFjdG9yID0gKHNjYWxlOiBudW1iZXIsIGZhY3RvcjogbnVtYmVyLCBvcHRzOiBPYmplY3QpOiBPYmplY3QgPT4ge1xuICBsZXQgem9vbUZhY3RvciA9IGZhY3RvciAqIHNjYWxlO1xuICBjb25zdCB7IG1heFNjYWxlVGltZXMsIG1pblNjYWxlVGltZXMgfSA9IG9wdHM7XG4gIHJldHVybiB6b29tRmFjdG9yID0gTWF0aC5taW4obWF4U2NhbGVUaW1lcywgTWF0aC5tYXgoem9vbUZhY3RvciwgbWluU2NhbGVUaW1lcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFRvdWNoQ2VudGVyID0gKHRvdWNoZXM6IEFycmF5PE9iamVjdD4pID0+IGdldFZlY3RvckF2Zyh0b3VjaGVzKTtcblxuZXhwb3J0IGNvbnN0IGNhbGNOZXdTY2FsZSA9ICh0bzogbnVtYmVyLCBsYXN0U2NhbGU6IG51bWJlciA9IDEpOiBudW1iZXIgPT4gKFxuICB0byAvIGxhc3RTY2FsZVxuKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9oYW5kbGUtcGluY2guanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGRlZmF1bHQgdGFyZ2V0ID0+IChlKSA9PiB7XG4gIGNvbnN0IG5ld1NwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGxldCB0aW1lID0gbmV3IERhdGUoKTtcbiAgdGltZSA9IHRpbWUuZ2V0SG91cnMoKSArICc6JyArIHRpbWUuZ2V0TWludXRlcygpICsgJzonICsgdGltZS5nZXRTZWNvbmRzKCkgKyAnLCcgKyB0aW1lLmdldE1pbGxpc2Vjb25kcygpO1xuICBjb25zdCBuZXdDb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1snICsgdGltZSArICddIEV2ZW50IGRpc3BhdGNoZWQ6IFwiJyArIGUudHlwZSArICdcIicpO1xuICBuZXdTcGFuLmFwcGVuZENoaWxkKG5ld0NvbnRlbnQpO1xuICB0YXJnZXQuYXBwZW5kQ2hpbGQobmV3U3Bhbik7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy9oYW5kbGUtZXZlbnQuanMiLCJpbXBvcnQgcGluY2hJdCBmcm9tICcuL3BpbmNoLWl0JztcblxuZXhwb3J0IGRlZmF1bHQgcGluY2hJdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyIsIlxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jb3JlLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbnZhciBfc2VsZiA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcblx0PyB3aW5kb3cgICAvLyBpZiBpbiBicm93c2VyXG5cdDogKFxuXHRcdCh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSlcblx0XHQ/IHNlbGYgLy8gaWYgaW4gd29ya2VyXG5cdFx0OiB7fSAgIC8vIGlmIGluIG5vZGUganNcblx0KTtcblxuLyoqXG4gKiBQcmlzbTogTGlnaHR3ZWlnaHQsIHJvYnVzdCwgZWxlZ2FudCBzeW50YXggaGlnaGxpZ2h0aW5nXG4gKiBNSVQgbGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC9cbiAqIEBhdXRob3IgTGVhIFZlcm91IGh0dHA6Ly9sZWEudmVyb3UubWVcbiAqL1xuXG52YXIgUHJpc20gPSAoZnVuY3Rpb24oKXtcblxuLy8gUHJpdmF0ZSBoZWxwZXIgdmFyc1xudmFyIGxhbmcgPSAvXFxibGFuZyg/OnVhZ2UpPy0oXFx3KylcXGIvaTtcbnZhciB1bmlxdWVJZCA9IDA7XG5cbnZhciBfID0gX3NlbGYuUHJpc20gPSB7XG5cdHV0aWw6IHtcblx0XHRlbmNvZGU6IGZ1bmN0aW9uICh0b2tlbnMpIHtcblx0XHRcdGlmICh0b2tlbnMgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFRva2VuKHRva2Vucy50eXBlLCBfLnV0aWwuZW5jb2RlKHRva2Vucy5jb250ZW50KSwgdG9rZW5zLmFsaWFzKTtcblx0XHRcdH0gZWxzZSBpZiAoXy51dGlsLnR5cGUodG9rZW5zKSA9PT0gJ0FycmF5Jykge1xuXHRcdFx0XHRyZXR1cm4gdG9rZW5zLm1hcChfLnV0aWwuZW5jb2RlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0b2tlbnMucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR0eXBlOiBmdW5jdGlvbiAobykge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5tYXRjaCgvXFxbb2JqZWN0IChcXHcrKVxcXS8pWzFdO1xuXHRcdH0sXG5cblx0XHRvYmpJZDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0aWYgKCFvYmpbJ19faWQnXSkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCAnX19pZCcsIHsgdmFsdWU6ICsrdW5pcXVlSWQgfSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqWydfX2lkJ107XG5cdFx0fSxcblxuXHRcdC8vIERlZXAgY2xvbmUgYSBsYW5ndWFnZSBkZWZpbml0aW9uIChlLmcuIHRvIGV4dGVuZCBpdClcblx0XHRjbG9uZTogZnVuY3Rpb24gKG8pIHtcblx0XHRcdHZhciB0eXBlID0gXy51dGlsLnR5cGUobyk7XG5cblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0XHRcdHZhciBjbG9uZSA9IHt9O1xuXG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG8pIHtcblx0XHRcdFx0XHRcdGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdFx0Y2xvbmVba2V5XSA9IF8udXRpbC5jbG9uZShvW2tleV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBjbG9uZTtcblxuXHRcdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGV4aXN0ZW5jZSBmb3IgSUU4XG5cdFx0XHRcdFx0cmV0dXJuIG8ubWFwICYmIG8ubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIF8udXRpbC5jbG9uZSh2KTsgfSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvO1xuXHRcdH1cblx0fSxcblxuXHRsYW5ndWFnZXM6IHtcblx0XHRleHRlbmQ6IGZ1bmN0aW9uIChpZCwgcmVkZWYpIHtcblx0XHRcdHZhciBsYW5nID0gXy51dGlsLmNsb25lKF8ubGFuZ3VhZ2VzW2lkXSk7XG5cblx0XHRcdGZvciAodmFyIGtleSBpbiByZWRlZikge1xuXHRcdFx0XHRsYW5nW2tleV0gPSByZWRlZltrZXldO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGFuZztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW5zZXJ0IGEgdG9rZW4gYmVmb3JlIGFub3RoZXIgdG9rZW4gaW4gYSBsYW5ndWFnZSBsaXRlcmFsXG5cdFx0ICogQXMgdGhpcyBuZWVkcyB0byByZWNyZWF0ZSB0aGUgb2JqZWN0ICh3ZSBjYW5ub3QgYWN0dWFsbHkgaW5zZXJ0IGJlZm9yZSBrZXlzIGluIG9iamVjdCBsaXRlcmFscyksXG5cdFx0ICogd2UgY2Fubm90IGp1c3QgcHJvdmlkZSBhbiBvYmplY3QsIHdlIG5lZWQgYW5vYmplY3QgYW5kIGEga2V5LlxuXHRcdCAqIEBwYXJhbSBpbnNpZGUgVGhlIGtleSAob3IgbGFuZ3VhZ2UgaWQpIG9mIHRoZSBwYXJlbnRcblx0XHQgKiBAcGFyYW0gYmVmb3JlIFRoZSBrZXkgdG8gaW5zZXJ0IGJlZm9yZS4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZnVuY3Rpb24gYXBwZW5kcyBpbnN0ZWFkLlxuXHRcdCAqIEBwYXJhbSBpbnNlcnQgT2JqZWN0IHdpdGggdGhlIGtleS92YWx1ZSBwYWlycyB0byBpbnNlcnRcblx0XHQgKiBAcGFyYW0gcm9vdCBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgYGluc2lkZWAuIElmIGVxdWFsIHRvIFByaXNtLmxhbmd1YWdlcywgaXQgY2FuIGJlIG9taXR0ZWQuXG5cdFx0ICovXG5cdFx0aW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAoaW5zaWRlLCBiZWZvcmUsIGluc2VydCwgcm9vdCkge1xuXHRcdFx0cm9vdCA9IHJvb3QgfHwgXy5sYW5ndWFnZXM7XG5cdFx0XHR2YXIgZ3JhbW1hciA9IHJvb3RbaW5zaWRlXTtcblxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuXHRcdFx0XHRpbnNlcnQgPSBhcmd1bWVudHNbMV07XG5cblx0XHRcdFx0Zm9yICh2YXIgbmV3VG9rZW4gaW4gaW5zZXJ0KSB7XG5cdFx0XHRcdFx0aWYgKGluc2VydC5oYXNPd25Qcm9wZXJ0eShuZXdUb2tlbikpIHtcblx0XHRcdFx0XHRcdGdyYW1tYXJbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZ3JhbW1hcjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJldCA9IHt9O1xuXG5cdFx0XHRmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG5cblx0XHRcdFx0aWYgKGdyYW1tYXIuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG5cblx0XHRcdFx0XHRpZiAodG9rZW4gPT0gYmVmb3JlKSB7XG5cblx0XHRcdFx0XHRcdGZvciAodmFyIG5ld1Rva2VuIGluIGluc2VydCkge1xuXG5cdFx0XHRcdFx0XHRcdGlmIChpbnNlcnQuaGFzT3duUHJvcGVydHkobmV3VG9rZW4pKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0W25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXRbdG9rZW5dID0gZ3JhbW1hclt0b2tlbl07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIHJlZmVyZW5jZXMgaW4gb3RoZXIgbGFuZ3VhZ2UgZGVmaW5pdGlvbnNcblx0XHRcdF8ubGFuZ3VhZ2VzLkRGUyhfLmxhbmd1YWdlcywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IHJvb3RbaW5zaWRlXSAmJiBrZXkgIT0gaW5zaWRlKSB7XG5cdFx0XHRcdFx0dGhpc1trZXldID0gcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHJvb3RbaW5zaWRlXSA9IHJldDtcblx0XHR9LFxuXG5cdFx0Ly8gVHJhdmVyc2UgYSBsYW5ndWFnZSBkZWZpbml0aW9uIHdpdGggRGVwdGggRmlyc3QgU2VhcmNoXG5cdFx0REZTOiBmdW5jdGlvbihvLCBjYWxsYmFjaywgdHlwZSwgdmlzaXRlZCkge1xuXHRcdFx0dmlzaXRlZCA9IHZpc2l0ZWQgfHwge307XG5cdFx0XHRmb3IgKHZhciBpIGluIG8pIHtcblx0XHRcdFx0aWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKG8sIGksIG9baV0sIHR5cGUgfHwgaSk7XG5cblx0XHRcdFx0XHRpZiAoXy51dGlsLnR5cGUob1tpXSkgPT09ICdPYmplY3QnICYmICF2aXNpdGVkW18udXRpbC5vYmpJZChvW2ldKV0pIHtcblx0XHRcdFx0XHRcdHZpc2l0ZWRbXy51dGlsLm9iaklkKG9baV0pXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRfLmxhbmd1YWdlcy5ERlMob1tpXSwgY2FsbGJhY2ssIG51bGwsIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChfLnV0aWwudHlwZShvW2ldKSA9PT0gJ0FycmF5JyAmJiAhdmlzaXRlZFtfLnV0aWwub2JqSWQob1tpXSldKSB7XG5cdFx0XHRcdFx0XHR2aXNpdGVkW18udXRpbC5vYmpJZChvW2ldKV0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0Xy5sYW5ndWFnZXMuREZTKG9baV0sIGNhbGxiYWNrLCBpLCB2aXNpdGVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdHBsdWdpbnM6IHt9LFxuXG5cdGhpZ2hsaWdodEFsbDogZnVuY3Rpb24oYXN5bmMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGVudiA9IHtcblx0XHRcdGNhbGxiYWNrOiBjYWxsYmFjayxcblx0XHRcdHNlbGVjdG9yOiAnY29kZVtjbGFzcyo9XCJsYW5ndWFnZS1cIl0sIFtjbGFzcyo9XCJsYW5ndWFnZS1cIl0gY29kZSwgY29kZVtjbGFzcyo9XCJsYW5nLVwiXSwgW2NsYXNzKj1cImxhbmctXCJdIGNvZGUnXG5cdFx0fTtcblxuXHRcdF8uaG9va3MucnVuKFwiYmVmb3JlLWhpZ2hsaWdodGFsbFwiLCBlbnYpO1xuXG5cdFx0dmFyIGVsZW1lbnRzID0gZW52LmVsZW1lbnRzIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZW52LnNlbGVjdG9yKTtcblxuXHRcdGZvciAodmFyIGk9MCwgZWxlbWVudDsgZWxlbWVudCA9IGVsZW1lbnRzW2krK107KSB7XG5cdFx0XHRfLmhpZ2hsaWdodEVsZW1lbnQoZWxlbWVudCwgYXN5bmMgPT09IHRydWUsIGVudi5jYWxsYmFjayk7XG5cdFx0fVxuXHR9LFxuXG5cdGhpZ2hsaWdodEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGFzeW5jLCBjYWxsYmFjaykge1xuXHRcdC8vIEZpbmQgbGFuZ3VhZ2Vcblx0XHR2YXIgbGFuZ3VhZ2UsIGdyYW1tYXIsIHBhcmVudCA9IGVsZW1lbnQ7XG5cblx0XHR3aGlsZSAocGFyZW50ICYmICFsYW5nLnRlc3QocGFyZW50LmNsYXNzTmFtZSkpIHtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdGxhbmd1YWdlID0gKHBhcmVudC5jbGFzc05hbWUubWF0Y2gobGFuZykgfHwgWywnJ10pWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRncmFtbWFyID0gXy5sYW5ndWFnZXNbbGFuZ3VhZ2VdO1xuXHRcdH1cblxuXHRcdC8vIFNldCBsYW5ndWFnZSBvbiB0aGUgZWxlbWVudCwgaWYgbm90IHByZXNlbnRcblx0XHRlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UobGFuZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKSArICcgbGFuZ3VhZ2UtJyArIGxhbmd1YWdlO1xuXG5cdFx0Ly8gU2V0IGxhbmd1YWdlIG9uIHRoZSBwYXJlbnQsIGZvciBzdHlsaW5nXG5cdFx0cGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXG5cdFx0aWYgKC9wcmUvaS50ZXN0KHBhcmVudC5ub2RlTmFtZSkpIHtcblx0XHRcdHBhcmVudC5jbGFzc05hbWUgPSBwYXJlbnQuY2xhc3NOYW1lLnJlcGxhY2UobGFuZywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKSArICcgbGFuZ3VhZ2UtJyArIGxhbmd1YWdlO1xuXHRcdH1cblxuXHRcdHZhciBjb2RlID0gZWxlbWVudC50ZXh0Q29udGVudDtcblxuXHRcdHZhciBlbnYgPSB7XG5cdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuXHRcdFx0bGFuZ3VhZ2U6IGxhbmd1YWdlLFxuXHRcdFx0Z3JhbW1hcjogZ3JhbW1hcixcblx0XHRcdGNvZGU6IGNvZGVcblx0XHR9O1xuXG5cdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1zYW5pdHktY2hlY2snLCBlbnYpO1xuXG5cdFx0aWYgKCFlbnYuY29kZSB8fCAhZW52LmdyYW1tYXIpIHtcblx0XHRcdGlmIChlbnYuY29kZSkge1xuXHRcdFx0XHRlbnYuZWxlbWVudC50ZXh0Q29udGVudCA9IGVudi5jb2RlO1xuXHRcdFx0fVxuXHRcdFx0Xy5ob29rcy5ydW4oJ2NvbXBsZXRlJywgZW52KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWhpZ2hsaWdodCcsIGVudik7XG5cblx0XHRpZiAoYXN5bmMgJiYgX3NlbGYuV29ya2VyKSB7XG5cdFx0XHR2YXIgd29ya2VyID0gbmV3IFdvcmtlcihfLmZpbGVuYW1lKTtcblxuXHRcdFx0d29ya2VyLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2dCkge1xuXHRcdFx0XHRlbnYuaGlnaGxpZ2h0ZWRDb2RlID0gZXZ0LmRhdGE7XG5cblx0XHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1pbnNlcnQnLCBlbnYpO1xuXG5cdFx0XHRcdGVudi5lbGVtZW50LmlubmVySFRNTCA9IGVudi5oaWdobGlnaHRlZENvZGU7XG5cblx0XHRcdFx0Y2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChlbnYuZWxlbWVudCk7XG5cdFx0XHRcdF8uaG9va3MucnVuKCdhZnRlci1oaWdobGlnaHQnLCBlbnYpO1xuXHRcdFx0XHRfLmhvb2tzLnJ1bignY29tcGxldGUnLCBlbnYpO1xuXHRcdFx0fTtcblxuXHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdFx0bGFuZ3VhZ2U6IGVudi5sYW5ndWFnZSxcblx0XHRcdFx0Y29kZTogZW52LmNvZGUsXG5cdFx0XHRcdGltbWVkaWF0ZUNsb3NlOiB0cnVlXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZW52LmhpZ2hsaWdodGVkQ29kZSA9IF8uaGlnaGxpZ2h0KGVudi5jb2RlLCBlbnYuZ3JhbW1hciwgZW52Lmxhbmd1YWdlKTtcblxuXHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1pbnNlcnQnLCBlbnYpO1xuXG5cdFx0XHRlbnYuZWxlbWVudC5pbm5lckhUTUwgPSBlbnYuaGlnaGxpZ2h0ZWRDb2RlO1xuXG5cdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVsZW1lbnQpO1xuXG5cdFx0XHRfLmhvb2tzLnJ1bignYWZ0ZXItaGlnaGxpZ2h0JywgZW52KTtcblx0XHRcdF8uaG9va3MucnVuKCdjb21wbGV0ZScsIGVudik7XG5cdFx0fVxuXHR9LFxuXG5cdGhpZ2hsaWdodDogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG5cdFx0dmFyIHRva2VucyA9IF8udG9rZW5pemUodGV4dCwgZ3JhbW1hcik7XG5cdFx0cmV0dXJuIFRva2VuLnN0cmluZ2lmeShfLnV0aWwuZW5jb2RlKHRva2VucyksIGxhbmd1YWdlKTtcblx0fSxcblxuXHR0b2tlbml6ZTogZnVuY3Rpb24odGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcblx0XHR2YXIgVG9rZW4gPSBfLlRva2VuO1xuXG5cdFx0dmFyIHN0cmFyciA9IFt0ZXh0XTtcblxuXHRcdHZhciByZXN0ID0gZ3JhbW1hci5yZXN0O1xuXG5cdFx0aWYgKHJlc3QpIHtcblx0XHRcdGZvciAodmFyIHRva2VuIGluIHJlc3QpIHtcblx0XHRcdFx0Z3JhbW1hclt0b2tlbl0gPSByZXN0W3Rva2VuXTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsZXRlIGdyYW1tYXIucmVzdDtcblx0XHR9XG5cblx0XHR0b2tlbmxvb3A6IGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcblx0XHRcdGlmKCFncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSB8fCAhZ3JhbW1hclt0b2tlbl0pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwYXR0ZXJucyA9IGdyYW1tYXJbdG9rZW5dO1xuXHRcdFx0cGF0dGVybnMgPSAoXy51dGlsLnR5cGUocGF0dGVybnMpID09PSBcIkFycmF5XCIpID8gcGF0dGVybnMgOiBbcGF0dGVybnNdO1xuXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHBhdHRlcm5zLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHZhciBwYXR0ZXJuID0gcGF0dGVybnNbal0sXG5cdFx0XHRcdFx0aW5zaWRlID0gcGF0dGVybi5pbnNpZGUsXG5cdFx0XHRcdFx0bG9va2JlaGluZCA9ICEhcGF0dGVybi5sb29rYmVoaW5kLFxuXHRcdFx0XHRcdGdyZWVkeSA9ICEhcGF0dGVybi5ncmVlZHksXG5cdFx0XHRcdFx0bG9va2JlaGluZExlbmd0aCA9IDAsXG5cdFx0XHRcdFx0YWxpYXMgPSBwYXR0ZXJuLmFsaWFzO1xuXG5cdFx0XHRcdGlmIChncmVlZHkgJiYgIXBhdHRlcm4ucGF0dGVybi5nbG9iYWwpIHtcblx0XHRcdFx0XHQvLyBXaXRob3V0IHRoZSBnbG9iYWwgZmxhZywgbGFzdEluZGV4IHdvbid0IHdvcmtcblx0XHRcdFx0XHR2YXIgZmxhZ3MgPSBwYXR0ZXJuLnBhdHRlcm4udG9TdHJpbmcoKS5tYXRjaCgvW2ltdXldKiQvKVswXTtcblx0XHRcdFx0XHRwYXR0ZXJuLnBhdHRlcm4gPSBSZWdFeHAocGF0dGVybi5wYXR0ZXJuLnNvdXJjZSwgZmxhZ3MgKyBcImdcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXR0ZXJuID0gcGF0dGVybi5wYXR0ZXJuIHx8IHBhdHRlcm47XG5cblx0XHRcdFx0Ly8gRG9u4oCZdCBjYWNoZSBsZW5ndGggYXMgaXQgY2hhbmdlcyBkdXJpbmcgdGhlIGxvb3Bcblx0XHRcdFx0Zm9yICh2YXIgaT0wLCBwb3MgPSAwOyBpPHN0cmFyci5sZW5ndGg7IHBvcyArPSBzdHJhcnJbaV0ubGVuZ3RoLCArK2kpIHtcblxuXHRcdFx0XHRcdHZhciBzdHIgPSBzdHJhcnJbaV07XG5cblx0XHRcdFx0XHRpZiAoc3RyYXJyLmxlbmd0aCA+IHRleHQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyBTb21ldGhpbmcgd2VudCB0ZXJyaWJseSB3cm9uZywgQUJPUlQsIEFCT1JUIVxuXHRcdFx0XHRcdFx0YnJlYWsgdG9rZW5sb29wO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChzdHIgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cGF0dGVybi5sYXN0SW5kZXggPSAwO1xuXG5cdFx0XHRcdFx0dmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHN0ciksXG5cdFx0XHRcdFx0ICAgIGRlbE51bSA9IDE7XG5cblx0XHRcdFx0XHQvLyBHcmVlZHkgcGF0dGVybnMgY2FuIG92ZXJyaWRlL3JlbW92ZSB1cCB0byB0d28gcHJldmlvdXNseSBtYXRjaGVkIHRva2Vuc1xuXHRcdFx0XHRcdGlmICghbWF0Y2ggJiYgZ3JlZWR5ICYmIGkgIT0gc3RyYXJyLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRcdHBhdHRlcm4ubGFzdEluZGV4ID0gcG9zO1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGV4dCk7XG5cdFx0XHRcdFx0XHRpZiAoIW1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgZnJvbSA9IG1hdGNoLmluZGV4ICsgKGxvb2tiZWhpbmQgPyBtYXRjaFsxXS5sZW5ndGggOiAwKSxcblx0XHRcdFx0XHRcdCAgICB0byA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoLFxuXHRcdFx0XHRcdFx0ICAgIGsgPSBpLFxuXHRcdFx0XHRcdFx0ICAgIHAgPSBwb3M7XG5cblx0XHRcdFx0XHRcdGZvciAodmFyIGxlbiA9IHN0cmFyci5sZW5ndGg7IGsgPCBsZW4gJiYgcCA8IHRvOyArK2spIHtcblx0XHRcdFx0XHRcdFx0cCArPSBzdHJhcnJba10ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHQvLyBNb3ZlIHRoZSBpbmRleCBpIHRvIHRoZSBlbGVtZW50IGluIHN0cmFyciB0aGF0IGlzIGNsb3Nlc3QgdG8gZnJvbVxuXHRcdFx0XHRcdFx0XHRpZiAoZnJvbSA+PSBwKSB7XG5cdFx0XHRcdFx0XHRcdFx0KytpO1xuXHRcdFx0XHRcdFx0XHRcdHBvcyA9IHA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Lypcblx0XHRcdFx0XHRcdCAqIElmIHN0cmFycltpXSBpcyBhIFRva2VuLCB0aGVuIHRoZSBtYXRjaCBzdGFydHMgaW5zaWRlIGFub3RoZXIgVG9rZW4sIHdoaWNoIGlzIGludmFsaWRcblx0XHRcdFx0XHRcdCAqIElmIHN0cmFycltrIC0gMV0gaXMgZ3JlZWR5IHdlIGFyZSBpbiBjb25mbGljdCB3aXRoIGFub3RoZXIgZ3JlZWR5IHBhdHRlcm5cblx0XHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdFx0aWYgKHN0cmFycltpXSBpbnN0YW5jZW9mIFRva2VuIHx8IHN0cmFycltrIC0gMV0uZ3JlZWR5KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBOdW1iZXIgb2YgdG9rZW5zIHRvIGRlbGV0ZSBhbmQgcmVwbGFjZSB3aXRoIHRoZSBuZXcgbWF0Y2hcblx0XHRcdFx0XHRcdGRlbE51bSA9IGsgLSBpO1xuXHRcdFx0XHRcdFx0c3RyID0gdGV4dC5zbGljZShwb3MsIHApO1xuXHRcdFx0XHRcdFx0bWF0Y2guaW5kZXggLT0gcG9zO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICghbWF0Y2gpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmKGxvb2tiZWhpbmQpIHtcblx0XHRcdFx0XHRcdGxvb2tiZWhpbmRMZW5ndGggPSBtYXRjaFsxXS5sZW5ndGg7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGZyb20gPSBtYXRjaC5pbmRleCArIGxvb2tiZWhpbmRMZW5ndGgsXG5cdFx0XHRcdFx0ICAgIG1hdGNoID0gbWF0Y2hbMF0uc2xpY2UobG9va2JlaGluZExlbmd0aCksXG5cdFx0XHRcdFx0ICAgIHRvID0gZnJvbSArIG1hdGNoLmxlbmd0aCxcblx0XHRcdFx0XHQgICAgYmVmb3JlID0gc3RyLnNsaWNlKDAsIGZyb20pLFxuXHRcdFx0XHRcdCAgICBhZnRlciA9IHN0ci5zbGljZSh0byk7XG5cblx0XHRcdFx0XHR2YXIgYXJncyA9IFtpLCBkZWxOdW1dO1xuXG5cdFx0XHRcdFx0aWYgKGJlZm9yZSkge1xuXHRcdFx0XHRcdFx0YXJncy5wdXNoKGJlZm9yZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHdyYXBwZWQgPSBuZXcgVG9rZW4odG9rZW4sIGluc2lkZT8gXy50b2tlbml6ZShtYXRjaCwgaW5zaWRlKSA6IG1hdGNoLCBhbGlhcywgbWF0Y2gsIGdyZWVkeSk7XG5cblx0XHRcdFx0XHRhcmdzLnB1c2god3JhcHBlZCk7XG5cblx0XHRcdFx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdFx0XHRcdGFyZ3MucHVzaChhZnRlcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShzdHJhcnIsIGFyZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0cmFycjtcblx0fSxcblxuXHRob29rczoge1xuXHRcdGFsbDoge30sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIGhvb2tzID0gXy5ob29rcy5hbGw7XG5cblx0XHRcdGhvb2tzW25hbWVdID0gaG9va3NbbmFtZV0gfHwgW107XG5cblx0XHRcdGhvb2tzW25hbWVdLnB1c2goY2FsbGJhY2spO1xuXHRcdH0sXG5cblx0XHRydW46IGZ1bmN0aW9uIChuYW1lLCBlbnYpIHtcblx0XHRcdHZhciBjYWxsYmFja3MgPSBfLmhvb2tzLmFsbFtuYW1lXTtcblxuXHRcdFx0aWYgKCFjYWxsYmFja3MgfHwgIWNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpPTAsIGNhbGxiYWNrOyBjYWxsYmFjayA9IGNhbGxiYWNrc1tpKytdOykge1xuXHRcdFx0XHRjYWxsYmFjayhlbnYpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxudmFyIFRva2VuID0gXy5Ub2tlbiA9IGZ1bmN0aW9uKHR5cGUsIGNvbnRlbnQsIGFsaWFzLCBtYXRjaGVkU3RyLCBncmVlZHkpIHtcblx0dGhpcy50eXBlID0gdHlwZTtcblx0dGhpcy5jb250ZW50ID0gY29udGVudDtcblx0dGhpcy5hbGlhcyA9IGFsaWFzO1xuXHQvLyBDb3B5IG9mIHRoZSBmdWxsIHN0cmluZyB0aGlzIHRva2VuIHdhcyBjcmVhdGVkIGZyb21cblx0dGhpcy5sZW5ndGggPSAobWF0Y2hlZFN0ciB8fCBcIlwiKS5sZW5ndGh8MDtcblx0dGhpcy5ncmVlZHkgPSAhIWdyZWVkeTtcbn07XG5cblRva2VuLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKG8sIGxhbmd1YWdlLCBwYXJlbnQpIHtcblx0aWYgKHR5cGVvZiBvID09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIG87XG5cdH1cblxuXHRpZiAoXy51dGlsLnR5cGUobykgPT09ICdBcnJheScpIHtcblx0XHRyZXR1cm4gby5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIFRva2VuLnN0cmluZ2lmeShlbGVtZW50LCBsYW5ndWFnZSwgbyk7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHR2YXIgZW52ID0ge1xuXHRcdHR5cGU6IG8udHlwZSxcblx0XHRjb250ZW50OiBUb2tlbi5zdHJpbmdpZnkoby5jb250ZW50LCBsYW5ndWFnZSwgcGFyZW50KSxcblx0XHR0YWc6ICdzcGFuJyxcblx0XHRjbGFzc2VzOiBbJ3Rva2VuJywgby50eXBlXSxcblx0XHRhdHRyaWJ1dGVzOiB7fSxcblx0XHRsYW5ndWFnZTogbGFuZ3VhZ2UsXG5cdFx0cGFyZW50OiBwYXJlbnRcblx0fTtcblxuXHRpZiAoZW52LnR5cGUgPT0gJ2NvbW1lbnQnKSB7XG5cdFx0ZW52LmF0dHJpYnV0ZXNbJ3NwZWxsY2hlY2snXSA9ICd0cnVlJztcblx0fVxuXG5cdGlmIChvLmFsaWFzKSB7XG5cdFx0dmFyIGFsaWFzZXMgPSBfLnV0aWwudHlwZShvLmFsaWFzKSA9PT0gJ0FycmF5JyA/IG8uYWxpYXMgOiBbby5hbGlhc107XG5cdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW52LmNsYXNzZXMsIGFsaWFzZXMpO1xuXHR9XG5cblx0Xy5ob29rcy5ydW4oJ3dyYXAnLCBlbnYpO1xuXG5cdHZhciBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoZW52LmF0dHJpYnV0ZXMpLm1hcChmdW5jdGlvbihuYW1lKSB7XG5cdFx0cmV0dXJuIG5hbWUgKyAnPVwiJyArIChlbnYuYXR0cmlidXRlc1tuYW1lXSB8fCAnJykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpICsgJ1wiJztcblx0fSkuam9pbignICcpO1xuXG5cdHJldHVybiAnPCcgKyBlbnYudGFnICsgJyBjbGFzcz1cIicgKyBlbnYuY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICsgKGF0dHJpYnV0ZXMgPyAnICcgKyBhdHRyaWJ1dGVzIDogJycpICsgJz4nICsgZW52LmNvbnRlbnQgKyAnPC8nICsgZW52LnRhZyArICc+JztcblxufTtcblxuaWYgKCFfc2VsZi5kb2N1bWVudCkge1xuXHRpZiAoIV9zZWxmLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHQvLyBpbiBOb2RlLmpzXG5cdFx0cmV0dXJuIF9zZWxmLlByaXNtO1xuXHR9XG4gXHQvLyBJbiB3b3JrZXJcblx0X3NlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGV2dCkge1xuXHRcdHZhciBtZXNzYWdlID0gSlNPTi5wYXJzZShldnQuZGF0YSksXG5cdFx0ICAgIGxhbmcgPSBtZXNzYWdlLmxhbmd1YWdlLFxuXHRcdCAgICBjb2RlID0gbWVzc2FnZS5jb2RlLFxuXHRcdCAgICBpbW1lZGlhdGVDbG9zZSA9IG1lc3NhZ2UuaW1tZWRpYXRlQ2xvc2U7XG5cblx0XHRfc2VsZi5wb3N0TWVzc2FnZShfLmhpZ2hsaWdodChjb2RlLCBfLmxhbmd1YWdlc1tsYW5nXSwgbGFuZykpO1xuXHRcdGlmIChpbW1lZGlhdGVDbG9zZSkge1xuXHRcdFx0X3NlbGYuY2xvc2UoKTtcblx0XHR9XG5cdH0sIGZhbHNlKTtcblxuXHRyZXR1cm4gX3NlbGYuUHJpc207XG59XG5cbi8vR2V0IGN1cnJlbnQgc2NyaXB0IGFuZCBoaWdobGlnaHRcbnZhciBzY3JpcHQgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0IHx8IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIikpLnBvcCgpO1xuXG5pZiAoc2NyaXB0KSB7XG5cdF8uZmlsZW5hbWUgPSBzY3JpcHQuc3JjO1xuXG5cdGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyICYmICFzY3JpcHQuaGFzQXR0cmlidXRlKCdkYXRhLW1hbnVhbCcpKSB7XG5cdFx0aWYoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpIHtcblx0XHRcdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXy5oaWdobGlnaHRBbGwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoXy5oaWdobGlnaHRBbGwsIDE2KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgXy5oaWdobGlnaHRBbGwpO1xuXHRcdH1cblx0fVxufVxuXG5yZXR1cm4gX3NlbGYuUHJpc207XG5cbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IFByaXNtO1xufVxuXG4vLyBoYWNrIGZvciBjb21wb25lbnRzIHRvIHdvcmsgY29ycmVjdGx5IGluIG5vZGUuanNcbmlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuXHRnbG9iYWwuUHJpc20gPSBQcmlzbTtcbn1cblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLW1hcmt1cC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuXHQnY29tbWVudCc6IC88IS0tW1xcd1xcV10qPy0tPi8sXG5cdCdwcm9sb2cnOiAvPFxcP1tcXHdcXFddKz9cXD8+Lyxcblx0J2RvY3R5cGUnOiAvPCFET0NUWVBFW1xcd1xcV10rPz4vaSxcblx0J2NkYXRhJzogLzwhXFxbQ0RBVEFcXFtbXFx3XFxXXSo/XV0+L2ksXG5cdCd0YWcnOiB7XG5cdFx0cGF0dGVybjogLzxcXC8/KD8hXFxkKVteXFxzPlxcLz0kPF0rKD86XFxzK1teXFxzPlxcLz1dKyg/Oj0oPzooXCJ8JykoPzpcXFxcXFwxfFxcXFw/KD8hXFwxKVtcXHdcXFddKSpcXDF8W15cXHMnXCI+PV0rKSk/KSpcXHMqXFwvPz4vaSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCd0YWcnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9ePFxcLz9bXlxccz5cXC9dKy9pLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXjxcXC8/Lyxcblx0XHRcdFx0XHQnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0J2F0dHItdmFsdWUnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC89KD86KCd8XCIpW1xcd1xcV10qPyhcXDEpfFteXFxzPl0rKS9pLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiAvWz0+XCInXS9cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdwdW5jdHVhdGlvbic6IC9cXC8/Pi8sXG5cdFx0XHQnYXR0ci1uYW1lJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvW15cXHM+XFwvXSsvLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdH0sXG5cdCdlbnRpdHknOiAvJiM/W1xcZGEtel17MSw4fTsvaVxufTtcblxuLy8gUGx1Z2luIHRvIG1ha2UgZW50aXR5IHRpdGxlIHNob3cgdGhlIHJlYWwgZW50aXR5LCBpZGVhIGJ5IFJvbWFuIEtvbWFyb3ZcblByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uKGVudikge1xuXG5cdGlmIChlbnYudHlwZSA9PT0gJ2VudGl0eScpIHtcblx0XHRlbnYuYXR0cmlidXRlc1sndGl0bGUnXSA9IGVudi5jb250ZW50LnJlcGxhY2UoLyZhbXA7LywgJyYnKTtcblx0fVxufSk7XG5cblByaXNtLmxhbmd1YWdlcy54bWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLmh0bWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLm1hdGhtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMuc3ZnID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNzcy5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuY3NzID0ge1xuXHQnY29tbWVudCc6IC9cXC9cXCpbXFx3XFxXXSo/XFwqXFwvLyxcblx0J2F0cnVsZSc6IHtcblx0XHRwYXR0ZXJuOiAvQFtcXHctXSs/Lio/KDt8KD89XFxzKlxceykpL2ksXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQncnVsZSc6IC9AW1xcdy1dKy9cblx0XHRcdC8vIFNlZSByZXN0IGJlbG93XG5cdFx0fVxuXHR9LFxuXHQndXJsJzogL3VybFxcKCg/OihbXCInXSkoXFxcXCg/OlxcclxcbnxbXFx3XFxXXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMXwuKj8pXFwpL2ksXG5cdCdzZWxlY3Rvcic6IC9bXlxce1xcfVxcc11bXlxce1xcfTtdKj8oPz1cXHMqXFx7KS8sXG5cdCdzdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogLyhcInwnKShcXFxcKD86XFxyXFxufFtcXHdcXFddKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J3Byb3BlcnR5JzogLyhcXGJ8XFxCKVtcXHctXSsoPz1cXHMqOikvaSxcblx0J2ltcG9ydGFudCc6IC9cXEIhaW1wb3J0YW50XFxiL2ksXG5cdCdmdW5jdGlvbic6IC9bLWEtejAtOV0rKD89XFwoKS9pLFxuXHQncHVuY3R1YXRpb24nOiAvWygpe307Ol0vXG59O1xuXG5QcmlzbS5sYW5ndWFnZXMuY3NzWydhdHJ1bGUnXS5pbnNpZGUucmVzdCA9IFByaXNtLnV0aWwuY2xvbmUoUHJpc20ubGFuZ3VhZ2VzLmNzcyk7XG5cbmlmIChQcmlzbS5sYW5ndWFnZXMubWFya3VwKSB7XG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICd0YWcnLCB7XG5cdFx0J3N0eWxlJzoge1xuXHRcdFx0cGF0dGVybjogLyg8c3R5bGVbXFx3XFxXXSo/PilbXFx3XFxXXSo/KD89PFxcL3N0eWxlPikvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jc3MsXG5cdFx0XHRhbGlhczogJ2xhbmd1YWdlLWNzcydcblx0XHR9XG5cdH0pO1xuXHRcblx0UHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnaW5zaWRlJywgJ2F0dHItdmFsdWUnLCB7XG5cdFx0J3N0eWxlLWF0dHInOiB7XG5cdFx0XHRwYXR0ZXJuOiAvXFxzKnN0eWxlPShcInwnKS4qP1xcMS9pLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdhdHRyLW5hbWUnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogL15cXHMqc3R5bGUvaSxcblx0XHRcdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmluc2lkZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXlxccyo9XFxzKlsnXCJdfFsnXCJdXFxzKiQvLFxuXHRcdFx0XHQnYXR0ci12YWx1ZSc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvLisvaSxcblx0XHRcdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jc3Ncblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGFsaWFzOiAnbGFuZ3VhZ2UtY3NzJ1xuXHRcdH1cblx0fSwgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcpO1xufVxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNsaWtlLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5jbGlrZSA9IHtcblx0J2NvbW1lbnQnOiBbXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteXFxcXF0pXFwvXFwqW1xcd1xcV10qP1xcKlxcLy8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W15cXFxcOl0pXFwvXFwvLiovLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH1cblx0XSxcblx0J3N0cmluZyc6IHtcblx0XHRwYXR0ZXJuOiAvKFtcIiddKShcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J2NsYXNzLW5hbWUnOiB7XG5cdFx0cGF0dGVybjogLygoPzpcXGIoPzpjbGFzc3xpbnRlcmZhY2V8ZXh0ZW5kc3xpbXBsZW1lbnRzfHRyYWl0fGluc3RhbmNlb2Z8bmV3KVxccyspfCg/OmNhdGNoXFxzK1xcKCkpW2EtejAtOV9cXC5cXFxcXSsvaSxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0cHVuY3R1YXRpb246IC8oXFwufFxcXFwpL1xuXHRcdH1cblx0fSxcblx0J2tleXdvcmQnOiAvXFxiKGlmfGVsc2V8d2hpbGV8ZG98Zm9yfHJldHVybnxpbnxpbnN0YW5jZW9mfGZ1bmN0aW9ufG5ld3x0cnl8dGhyb3d8Y2F0Y2h8ZmluYWxseXxudWxsfGJyZWFrfGNvbnRpbnVlKVxcYi8sXG5cdCdib29sZWFuJzogL1xcYih0cnVlfGZhbHNlKVxcYi8sXG5cdCdmdW5jdGlvbic6IC9bYS16MC05X10rKD89XFwoKS9pLFxuXHQnbnVtYmVyJzogL1xcYi0/KD86MHhbXFxkYS1mXSt8XFxkKlxcLj9cXGQrKD86ZVsrLV0/XFxkKyk/KVxcYi9pLFxuXHQnb3BlcmF0b3InOiAvLS0/fFxcK1xcKz98IT0/PT98PD0/fD49P3w9PT89P3wmJj98XFx8XFx8P3xcXD98XFwqfFxcL3x+fFxcXnwlLyxcblx0J3B1bmN0dWF0aW9uJzogL1t7fVtcXF07KCksLjpdL1xufTtcblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWphdmFzY3JpcHQuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcblx0J2tleXdvcmQnOiAvXFxiKGFzfGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2F0Y2h8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHl8Zm9yfGZyb218ZnVuY3Rpb258Z2V0fGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c2V0fHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpXFxiLyxcblx0J251bWJlcic6IC9cXGItPygweFtcXGRBLUZhLWZdK3wwYlswMV0rfDBvWzAtN10rfFxcZCpcXC4/XFxkKyhbRWVdWystXT9cXGQrKT98TmFOfEluZmluaXR5KVxcYi8sXG5cdC8vIEFsbG93IGZvciBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMgKFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDA4NDQ0KVxuXHQnZnVuY3Rpb24nOiAvW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSooPz1cXCgpL2ksXG5cdCdvcGVyYXRvcic6IC8tLT98XFwrXFwrP3whPT89P3w8PT98Pj0/fD09Pz0/fCYmP3xcXHxcXHw/fFxcP3xcXCpcXCo/fFxcL3x+fFxcXnwlfFxcLnszfS9cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2tleXdvcmQnLCB7XG5cdCdyZWdleCc6IHtcblx0XHRwYXR0ZXJuOiAvKF58W14vXSlcXC8oPyFcXC8pKFxcWy4rP118XFxcXC58W14vXFxcXFxcclxcbl0pK1xcL1tnaW15dV17MCw1fSg/PVxccyooJHxbXFxyXFxuLC47fSldKSkvLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH1cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ3N0cmluZycsIHtcblx0J3RlbXBsYXRlLXN0cmluZyc6IHtcblx0XHRwYXR0ZXJuOiAvYCg/OlxcXFxcXFxcfFxcXFw/W15cXFxcXSkqP2AvLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdpbnRlcnBvbGF0aW9uJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvXFwkXFx7W159XStcXH0vLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbic6IHtcblx0XHRcdFx0XHRcdHBhdHRlcm46IC9eXFwkXFx7fFxcfSQvLFxuXHRcdFx0XHRcdFx0YWxpYXM6ICdwdW5jdHVhdGlvbidcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHJlc3Q6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQnc3RyaW5nJzogL1tcXHNcXFNdKy9cblx0XHR9XG5cdH1cbn0pO1xuXG5pZiAoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCkge1xuXHRQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAndGFnJywge1xuXHRcdCdzY3JpcHQnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKDxzY3JpcHRbXFx3XFxXXSo/PilbXFx3XFxXXSo/KD89PFxcL3NjcmlwdD4pL2ksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCxcblx0XHRcdGFsaWFzOiAnbGFuZ3VhZ2UtamF2YXNjcmlwdCdcblx0XHR9XG5cdH0pO1xufVxuXG5QcmlzbS5sYW5ndWFnZXMuanMgPSBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdDtcblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1maWxlLWhpZ2hsaWdodC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnIHx8ICFzZWxmLlByaXNtIHx8ICFzZWxmLmRvY3VtZW50IHx8ICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0c2VsZi5QcmlzbS5maWxlSGlnaGxpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgRXh0ZW5zaW9ucyA9IHtcblx0XHRcdCdqcyc6ICdqYXZhc2NyaXB0Jyxcblx0XHRcdCdweSc6ICdweXRob24nLFxuXHRcdFx0J3JiJzogJ3J1YnknLFxuXHRcdFx0J3BzMSc6ICdwb3dlcnNoZWxsJyxcblx0XHRcdCdwc20xJzogJ3Bvd2Vyc2hlbGwnLFxuXHRcdFx0J3NoJzogJ2Jhc2gnLFxuXHRcdFx0J2JhdCc6ICdiYXRjaCcsXG5cdFx0XHQnaCc6ICdjJyxcblx0XHRcdCd0ZXgnOiAnbGF0ZXgnXG5cdFx0fTtcblxuXHRcdGlmKEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7IC8vIENoZWNrIHRvIHByZXZlbnQgZXJyb3IgaW4gSUU4XG5cdFx0XHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwcmVbZGF0YS1zcmNdJykpLmZvckVhY2goZnVuY3Rpb24gKHByZSkge1xuXHRcdFx0XHR2YXIgc3JjID0gcHJlLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKTtcblxuXHRcdFx0XHR2YXIgbGFuZ3VhZ2UsIHBhcmVudCA9IHByZTtcblx0XHRcdFx0dmFyIGxhbmcgPSAvXFxibGFuZyg/OnVhZ2UpPy0oPyFcXCopKFxcdyspXFxiL2k7XG5cdFx0XHRcdHdoaWxlIChwYXJlbnQgJiYgIWxhbmcudGVzdChwYXJlbnQuY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHRcdGxhbmd1YWdlID0gKHByZS5jbGFzc05hbWUubWF0Y2gobGFuZykgfHwgWywgJyddKVsxXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghbGFuZ3VhZ2UpIHtcblx0XHRcdFx0XHR2YXIgZXh0ZW5zaW9uID0gKHNyYy5tYXRjaCgvXFwuKFxcdyspJC8pIHx8IFssICcnXSlbMV07XG5cdFx0XHRcdFx0bGFuZ3VhZ2UgPSBFeHRlbnNpb25zW2V4dGVuc2lvbl0gfHwgZXh0ZW5zaW9uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNvZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJyk7XG5cdFx0XHRcdGNvZGUuY2xhc3NOYW1lID0gJ2xhbmd1YWdlLScgKyBsYW5ndWFnZTtcblxuXHRcdFx0XHRwcmUudGV4dENvbnRlbnQgPSAnJztcblxuXHRcdFx0XHRjb2RlLnRleHRDb250ZW50ID0gJ0xvYWRpbmfigKYnO1xuXG5cdFx0XHRcdHByZS5hcHBlbmRDaGlsZChjb2RlKTtcblxuXHRcdFx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oJ0dFVCcsIHNyYywgdHJ1ZSk7XG5cblx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuXG5cdFx0XHRcdFx0XHRpZiAoeGhyLnN0YXR1cyA8IDQwMCAmJiB4aHIucmVzcG9uc2VUZXh0KSB7XG5cdFx0XHRcdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSB4aHIucmVzcG9uc2VUZXh0O1xuXG5cdFx0XHRcdFx0XHRcdFByaXNtLmhpZ2hsaWdodEVsZW1lbnQoY29kZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICh4aHIuc3RhdHVzID49IDQwMCkge1xuXHRcdFx0XHRcdFx0XHRjb2RlLnRleHRDb250ZW50ID0gJ+KcliBFcnJvciAnICsgeGhyLnN0YXR1cyArICcgd2hpbGUgZmV0Y2hpbmcgZmlsZTogJyArIHhoci5zdGF0dXNUZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSAn4pyWIEVycm9yOiBGaWxlIGRvZXMgbm90IGV4aXN0IG9yIGlzIGVtcHR5Jztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0eGhyLnNlbmQobnVsbCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0fTtcblxuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgc2VsZi5QcmlzbS5maWxlSGlnaGxpZ2h0KTtcblxufSkoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcmlzbWpzL3ByaXNtLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9wcmlzbS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3ByaXNtLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcHJpc20uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJpc21qcy90aGVtZXMvcHJpc20uY3NzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcbiAgICogZGVmYXVsdCBzY2FsZSB0aGF0IHdpbGwgYmUgc2V0IG9uIGVsZW1lbnRcbiAgICogQG1heFBpbmNoIHtOdW1iZXJ9XG4gICAqL1xuICBiYXNlU2NhbGU6IDEsXG5cbiAgLyoqXG4gICAqIG1heCBzY2FsZSBhIG5vZGUgY2FuIHJlYWNoXG4gICAqIEBtYXhQaW5jaCB7TnVtYmVyfVxuICAgKi9cbiAgbWF4U2NhbGU6IDMsXG5cbiAgLyoqXG4gICAqIG1heCBzY2FsZSBhIG5vZGUgY2FuIHJlYWNoIGJlZm9yZSBib3VuY2luZyBiYWNrIHRvIG1heFNjYWxlXG4gICAqIEBtYXhTY2FsZVRpbWVzIHtOdW1iZXJ9XG4gICAqL1xuICBtYXhTY2FsZVRpbWVzOiA0LFxuXG4gIC8qKlxuICAgKiBtaW4gc2NhbGUgYSBub2RlIGNhbiByZWFjaFxuICAgKiBAbWluUGluY2gge051bWJlcn1cbiAgICovXG4gIG1pblNjYWxlOiAxLFxuXG4gIC8qKlxuICAgKiBtaW4gc2NhbGUgYSBub2RlIGNhbiByZWFjaCBiZWZvcmUgYm91bmNpbmcgYmFjayB0byBtaW5TY2FsZVxuICAgKiBAbWluU2NhbGVUaW1lcyB7TnVtYmVyfVxuICAgKi9cbiAgbWluU2NhbGVUaW1lczogMC44LFxuXG4gIC8qKlxuICAgKiB0aW1lIGZvciB0aGUgc25hcEJhY2sgb2YgdGhlIHBpbmNoIGlmIHRoZSBub2RlIGhhcyByZWFjaCBhYm92ZVxuICAgKiBvciBiZWxvdyBpdHMgcGluY2ggdmFsdWVcbiAgICogQHNuYXBCYWNrU3BlZWQge051bWJlcn1cbiAgICovXG4gIHNuYXBCYWNrU3BlZWQ6IDIwMCxcblxuICAvKipcbiAgICogQmFzaWMgZWFzaW5nIGZ1bmN0aW9uczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZGUvZG9jcy9XZWIvQ1NTL3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXG4gICAqIGN1YmljIGJlemllciBlYXNpbmcgZnVuY3Rpb25zOiBodHRwOi8vZWFzaW5ncy5uZXQvZGVcbiAgICogQGVhc2Uge1N0cmluZ31cbiAgICovXG4gIGVhc2U6ICdlYXNlJyxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZGVmYXVsdHMuanMiLCIvLyBAZmxvd1xuLy9cbmltcG9ydCBldmVudERpc3BhdGNoZXIgZnJvbSAnLi91dGlscy9kaXNwYXRjaC1ldmVudCc7XG5pbXBvcnQgeyBjYW5jZWxFdmVudCwgZ2V0VG91Y2hlcywgZGV0ZWN0RG91YmxlVGFwLCBjYWxjU2NhbGUgfSBmcm9tICcuL3V0aWxzL2hhbmRsZS1ldmVudCc7XG5pbXBvcnQgc2NhbGVFbGVtZW50IGZyb20gJy4vdXRpbHMvaGFuZGxlLWVsZW1lbnQnO1xuaW1wb3J0IHsgaXNXaXRoaW4sIGNhbGNOZXdTY2FsZSwgYWRkT2Zmc2V0LCBnZXRJbml0aWFsU2NhbGUsIGdldFNjYWxlRmFjdG9yLCBnZXRab29tRmFjdG9yLCBnZXRUb3VjaENlbnRlciB9IGZyb20gJy4vdXRpbHMvaGFuZGxlLXBpbmNoJztcbmltcG9ydCB7IGRyYWcsIHNhbml0aXplT2Zmc2V0IH0gZnJvbSAnLi91dGlscy9oYW5kbGUtZHJhZyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9kZWZhdWx0cyc7XG5cbmNvbnN0IGZpcnN0ID0gKGl0ZW1zOiBBcnJheTxPYmplY3Q+KSA9PiBpdGVtc1swXTtcblxuY29uc3QgcGluY2hJdCA9ICh0YXJnZXRzOiBzdHJpbmcgfCBPYmplY3QsIG9wdGlvbnM6IE9iamVjdCA9IHt9KSA9PiB7XG4gIC8vIHByaXZhdGUgdmFyaWFibGUgY2FjaGVcbiAgbGV0IGVsZW1lbnQgPSBudWxsO1xuXG4gIGxldCBzY2FsaW5nO1xuICBsZXQgbGFzdFNjYWxlID0gMTtcbiAgbGV0IHN0YXJ0VG91Y2hlcztcblxuICBsZXQgem9vbUZhY3RvciA9IDE7XG5cbiAgbGV0IG9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICBsZXQgbGFzdFpvb21DZW50ZXIgPSBmYWxzZTtcbiAgbGV0IGxhc3REcmFnUG9zaXRpb24gPSBmYWxzZTtcblxuICAvLyBCYXNlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBwaW5jaCBpbnN0YW5jZVxuICBjb25zdCBvcHRzID0gey4uLmRlZmF1bHRzLCAuLi5vcHRpb25zfTtcbiAgY29uc3QgeyBvbiwgZGlzcGF0Y2ggfSA9IGV2ZW50RGlzcGF0Y2hlcigpO1xuXG4gLyoqXG4gICogIGRpc3BhdGNoUGluY2hFdmVudCAtIFNob3J0aGFuZCBtZXRob2QgZm9yIGNyZWF0aW5nIGV2ZW50c1xuICAqXG4gICogIEBwYXJhbSB7IFN0cmluZyB9IHBoYXNlXG4gICogIEBwYXJhbSB7IFN0cmluZyB9IHR5cGVcbiAgKiAgQHBhcmFtIHsgT2JqZWN0IH0gZGV0YWlsc1xuICAqICBAcmV0dXJuIHsgVm9pZCB9XG4gICoqL1xuICBjb25zdCBkaXNwYXRjaFBpbmNoRXZlbnQgPSAoZXZlbnROYW1lOiBzdHJpbmcsIHBoYXNlOiBzdHJpbmcsIGRhdGE6IE9iamVjdCA9IHt9KTogdm9pZCA9PiB7XG4gICAgZGlzcGF0Y2goZXZlbnROYW1lLCBPYmplY3QuYXNzaWduKGRhdGEsIHtcbiAgICAgIHBoYXNlXG4gICAgfSkpO1xuICB9O1xuXG4gIGNvbnN0IHJlc2V0R2xvYmFscyA9ICgvKiBvcHRzICovKTogdm9pZCA9PiB7XG4gICAgc2NhbGluZyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0U2NhbGUgPSAxO1xuICAgIHN0YXJ0VG91Y2hlcyA9IG51bGw7XG4gICAgem9vbUZhY3RvciA9IDE7XG4gICAgbGFzdFpvb21DZW50ZXIgPSBmYWxzZTtcblxuICAgIGxhc3REcmFnUG9zaXRpb24gPSBmYWxzZTtcbiAgICBvZmZzZXQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgfTtcblxuICAvLyBldmVudCBoYW5kbGluZ1xuICAvKipcbiAgICogU2V0IHNjYWxpbmcgaWYgd2UgYXJlIHVzaW5nIG1vcmUgdGhlbiBvbmUgZmluZ2VyXG4gICAqIGFuZCBjYXB0dXJlcyBvdXIgZmlyc3QgcHVuY2ggcG9pbnRcbiAgICpcbiAgICogcHJpdmF0ZVxuICAgKiBAcGFyYW0geyBPYmplY3QgfSBlIHRoZSBldmVudCBmcm9tIG91ciBldmVudGxpc3RlbmVyXG4gICAqL1xuICBjb25zdCBvblRvdWNoc3RhcnQgPSAoZTogVG91Y2hFdmVudCkgPT4ge1xuICAgIGRpc3BhdGNoUGluY2hFdmVudCgndG91Y2hzdGFydCcsICdiZWZvcmUnLCBlKTtcblxuXG4gICAgc2NhbGluZyA9IChlLnRvdWNoZXMubGVuZ3RoID09PSAyKTtcbiAgICBzdGFydFRvdWNoZXMgPSBBcnJheS5mcm9tKGUudG91Y2hlcyk7XG4gICAgbGFzdFNjYWxlID0gMTtcblxuICAgIGlmIChkZXRlY3REb3VibGVUYXAoZSkpIHtcbiAgICAgIGNvbnN0IGltYWdlID0gZS5jdXJyZW50VGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICAgICAgc2NhbGVFbGVtZW50KGUudGFyZ2V0LCBpbWFnZSwgMSwgeyB4OiAwLCB5OiAwIH0sIG9wdHMuc25hcEJhY2tTcGVlZCwgb3B0cy5lYXNlKTtcbiAgICAgIHJlc2V0R2xvYmFscygpO1xuICAgIH1cblxuICAgIGRpc3BhdGNoUGluY2hFdmVudCgndG91Y2hzdGFydCcsICdhZnRlcicsIGUpO1xuICB9O1xuXG4gIGNvbnN0IG9uVG91Y2htb3ZlID0gKGU6IFRvdWNoRXZlbnQpID0+IHtcbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ3RvdWNobW92ZScsICdiZWZvcmUnLCBlKTtcblxuICAgIGlmICgoIXNjYWxpbmcgfHwgIXN0YXJ0VG91Y2hlcykgJiYgem9vbUZhY3RvciA+IDEpIHtcbiAgICAgIGNhbmNlbEV2ZW50KGUpO1xuXG4gICAgICBjb25zdCB0b3VjaCA9IGZpcnN0KGdldFRvdWNoZXMoZS5jdXJyZW50VGFyZ2V0LCBBcnJheS5mcm9tKGUudG91Y2hlcykpKTtcbiAgICAgIGNvbnN0IGRyYWdPZmZzZXQgPSBkcmFnKHRvdWNoLCBsYXN0RHJhZ1Bvc2l0aW9uLCBvZmZzZXQsIHpvb21GYWN0b3IpO1xuXG4gICAgICBvZmZzZXQgPSBzYW5pdGl6ZU9mZnNldChlLnRhcmdldCwgZHJhZ09mZnNldCwgem9vbUZhY3Rvcik7XG4gICAgICBsYXN0RHJhZ1Bvc2l0aW9uID0gdG91Y2g7XG4gICAgfSBlbHNlIGlmIChzY2FsaW5nICYmIHN0YXJ0VG91Y2hlcykge1xuICAgICAgY2FuY2VsRXZlbnQoZSk7XG5cbiAgICAgIC8vIGEgcmVsYXRpdmUgc2NhbGUgZmFjdG9yIGlzIHVzZWRcbiAgICAgIGNvbnN0IHRvdWNoQ2VudGVyID0gZ2V0VG91Y2hDZW50ZXIoZ2V0VG91Y2hlcyhlLmN1cnJlbnRUYXJnZXQsIEFycmF5LmZyb20oZS50b3VjaGVzKSkpO1xuICAgICAgY29uc3QgbmV3U2NhbGUgPSBjYWxjU2NhbGUoZS5jdXJyZW50VGFyZ2V0LCBzdGFydFRvdWNoZXMsIEFycmF5LmZyb20oZS50b3VjaGVzKSk7XG4gICAgICBjb25zdCBzY2FsZVZhbHVlID0gY2FsY05ld1NjYWxlKG5ld1NjYWxlLCBsYXN0U2NhbGUpO1xuXG4gICAgICBjb25zdCBzY2FsZSA9IGdldFNjYWxlRmFjdG9yKHNjYWxlVmFsdWUsIHpvb21GYWN0b3IsIG9wdHMpO1xuICAgICAgem9vbUZhY3RvciA9IGdldFpvb21GYWN0b3Ioc2NhbGVWYWx1ZSwgem9vbUZhY3Rvciwgb3B0cyk7XG5cbiAgICAgIG9mZnNldCA9IGFkZE9mZnNldChvZmZzZXQsIHtcbiAgICAgICAgeDogKHNjYWxlIC0gMSkgKiAodG91Y2hDZW50ZXIueCArIG9mZnNldC54KSxcbiAgICAgICAgeTogKHNjYWxlIC0gMSkgKiAodG91Y2hDZW50ZXIueSArIG9mZnNldC55KVxuICAgICAgfSk7XG5cbiAgICAgIGxhc3RTY2FsZSA9IG5ld1NjYWxlO1xuICAgICAgb2Zmc2V0ID0gZHJhZyh0b3VjaENlbnRlciwgbGFzdFpvb21DZW50ZXIsIG9mZnNldCwgem9vbUZhY3Rvcik7XG4gICAgICBsYXN0Wm9vbUNlbnRlciA9IHRvdWNoQ2VudGVyO1xuICAgIH1cblxuICAgIGNvbnN0IGltYWdlID0gZS5jdXJyZW50VGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICAgIHNjYWxlRWxlbWVudChlLnRhcmdldCwgaW1hZ2UsIHpvb21GYWN0b3IsIG9mZnNldCwgMCwgb3B0cy5lYXNlKTtcblxuICAgIGRpc3BhdGNoUGluY2hFdmVudCgndG91Y2htb3ZlJywgJ2FmdGVyJywgZSk7XG4gIH07XG5cbiAgY29uc3Qgb25Ub3VjaGVuZCA9IChlOiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCd0b3VjaGVuZCcsICdiZWZvcmUnLCBlKTtcblxuICAgIGxhc3REcmFnUG9zaXRpb24gPSBmYWxzZTtcbiAgICBsYXN0Wm9vbUNlbnRlciA9IGZhbHNlO1xuICAgIGxhc3RTY2FsZSA9IDE7XG4gICAgaWYgKHpvb21GYWN0b3IpIHtcbiAgICAgIGlmICghaXNXaXRoaW4oem9vbUZhY3Rvciwgb3B0cykpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBlLmN1cnJlbnRUYXJnZXQucXVlcnlTZWxlY3RvcignaW1nJyk7XG4gICAgICAgIGNvbnN0IGlzTGVzc1RoYW4gPSAoZ2V0SW5pdGlhbFNjYWxlKGUudGFyZ2V0LCBpbWFnZSkgKiB6b29tRmFjdG9yIDwgb3B0cy5taW5TY2FsZSk7XG4gICAgICAgIHpvb21GYWN0b3IgPSBpc0xlc3NUaGFuID8gb3B0cy5taW5TY2FsZSA6IG9wdHMubWF4U2NhbGU7XG4gICAgICAgIG9mZnNldCA9IHNhbml0aXplT2Zmc2V0KGUudGFyZ2V0LCBvZmZzZXQsIHpvb21GYWN0b3IpO1xuICAgICAgICBzY2FsZUVsZW1lbnQoZS50YXJnZXQsIGltYWdlLCB6b29tRmFjdG9yLCBvZmZzZXQsIG9wdHMuc25hcEJhY2tTcGVlZCwgb3B0cy5lYXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ3RvdWNoZW5kJywgJ2FmdGVyJywgZSk7XG4gIH07XG5cbiAgY29uc3QgYXR0YWNoRXZlbnRzID0gKGVsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoc3RhcnQpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2htb3ZlKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hlbmQpO1xuICB9O1xuXG4gIGNvbnN0IGRldGFjaGhFdmVudHMgPSAoZWw6IE9iamVjdCkgPT4ge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoc3RhcnQpO1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2htb3ZlKTtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hlbmQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBwdWJsaWNcbiAgICogcmVzZXQgZnVuY3Rpb246XG4gICAqIEBwYXJhbSB7IE51bWJlciB9IGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7IFN0cmluZyB9IGVhc2luZ1xuICAgKiBAcmV0dXJuIHsgVm9pZCB9XG4gICAqL1xuICBjb25zdCByZXNldCA9ICgpOiB2b2lkID0+IHtcbiAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcbiAgICBjb25zdCB7IHNuYXBCYWNrU3BlZWQsIGVhc2luZyB9ID0gb3B0cztcbiAgICBjb25zb2xlLmxvZygncmVzZXQ/Jyk7XG4gICAgY29uc3QgaW1hZ2UgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICAgIGNvbnNvbGUubG9nKGltYWdlKTtcbiAgICBzY2FsZUVsZW1lbnQoZWxlbWVudCwgaW1hZ2UsIDEsIHsgeDogMCwgeTogMCB9LCBzbmFwQmFja1NwZWVkLCBlYXNpbmcpO1xuICAgIHJlc2V0R2xvYmFscygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBwdWJsaWNcbiAgICogZGVzdHJveSBmdW5jdGlvbjogY2FsbGVkIHRvIGdyYWNlZnVsbHkgZGVzdHJveSB0aGUgbG9yeSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHsgVm9pZCB9XG4gICAqL1xuICBjb25zdCBkZXN0cm95ID0gKCk6IHZvaWQgPT4ge1xuICAgIGRpc3BhdGNoUGluY2hFdmVudCgnZGVzdHJveScsICdiZWZvcmUnLCB7fSk7XG4gICAgaWYgKCFlbGVtZW50KSByZXR1cm47XG4gICAgcmVzZXQoKTtcbiAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgZGV0YWNoaEV2ZW50cyhlbGVtZW50KTtcbiAgICBlbGVtZW50ID0gbnVsbDtcbiAgICByZXNldEdsb2JhbHMoKTtcbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ2Rlc3Ryb3knLCAnYWZ0ZXInLCB7fSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIHNldHVwIC0gSW5pdCBmdW5jdGlvblxuICAgKlxuICAgKiBAcGFyYW0geyBTdHJpbmcsIE9iamVjdCB9XG4gICAqIEByZXR1cm4geyBWb2lkIH1cbiAgICoqL1xuICBjb25zdCBzZXR1cCA9ICh0YXJnZXQ6IHN0cmluZyB8IE9iamVjdCk6IHZvaWQgPT4ge1xuICAgIGlmIChlbGVtZW50KSBkZXN0cm95KCk7XG4gICAgZGlzcGF0Y2hQaW5jaEV2ZW50KCdpbml0JywgJ2JlZm9yZScsIHt9KTtcbiAgICAvLyByZXNvbHZlIHRhcmdldFxuICAgIC8vIHBpbmNoaXQgYWxsb3dzIGZvciBib3RoIGEgbm9kZSBvciBhIHN0cmluZyB0byBiZSBwYXNzZWRcbiAgICBzd2l0Y2ggKHR5cGVvZiB0YXJnZXQpIHtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGVsZW1lbnQgPSB0YXJnZXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgICAgY29uc29sZS53YXJuKCdtaXNzaW5nIHRhcmdldCwgZWl0aGVyIHBhc3MgYW4gbm9kZSBvciBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBjb25zb2xlLmxvZyhlbGVtZW50KTtcbiAgICAgIGF0dGFjaEV2ZW50cyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICBkaXNwYXRjaFBpbmNoRXZlbnQoJ2luaXQnLCAnYWZ0ZXInLCB7fSk7XG4gIH07XG5cbiAgLy8gdHJpZ2dlciBpbml0aWFsIHNldHVwXG4gIHNldHVwKHRhcmdldHMpO1xuXG4gIHJldHVybiB7XG4gICAgc2V0dXAsXG4gICAgcmVzZXQsXG4gICAgZGVzdHJveSxcbiAgICBlbGVtZW50LFxuICAgIG9uLFxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgcGluY2hJdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9waW5jaC1pdC5qcyIsIi8qKlxuICogRGV0ZWN0aW5nIHByZWZpeGVzIGZvciBzYXZpbmcgdGltZSBhbmQgYnl0ZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgKCkgPT4ge1xuICBsZXQgdHJhbnNmb3JtO1xuICBsZXQgdHJhbnNpdGlvbjtcbiAgbGV0IHRyYW5zaXRpb25FbmQ7XG4gIGxldCBoYXNTY2FsZTNkO1xuXG4gICgoKSA9PiB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdfJyk7XG4gICAgY29uc3Qgc3R5bGUgPSBlbC5zdHlsZTtcblxuICAgIGlmIChzdHlsZS53ZWJraXRUcmFuc2l0aW9uID09PSAnJykge1xuICAgICAgdHJhbnNpdGlvbkVuZCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgICAgIHRyYW5zaXRpb24gPSAnd2Via2l0VHJhbnNpdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlLnRyYW5zaXRpb24gPT09ICcnKSB7XG4gICAgICB0cmFuc2l0aW9uRW5kID0gJ3RyYW5zaXRpb25lbmQnO1xuICAgICAgdHJhbnNpdGlvbiA9ICd0cmFuc2l0aW9uJztcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUud2Via2l0VHJhbnNmb3JtID09PSAnJykge1xuICAgICAgdHJhbnNmb3JtID0gJ3dlYmtpdFRyYW5zZm9ybSc7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlLm1zVHJhbnNmb3JtID09PSAnJykge1xuICAgICAgdHJhbnNmb3JtID0gJ21zVHJhbnNmb3JtJztcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUudHJhbnNmb3JtID09PSAnJykge1xuICAgICAgdHJhbnNmb3JtID0gJ3RyYW5zZm9ybSc7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUoZWwsIG51bGwpO1xuICAgIHN0eWxlW3RyYW5zZm9ybV0gPSAndHJhbnNsYXRlM2QoMCwgMCwgMCknO1xuICAgIGhhc1NjYWxlM2QgPSAhIWdsb2JhbC5nZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHRyYW5zZm9ybSk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gIH0pKCk7XG5cbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm0sXG4gICAgdHJhbnNpdGlvbixcbiAgICB0cmFuc2l0aW9uRW5kLFxuICAgIGhhc1NjYWxlM2RcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvdXRpbHMvZGV0ZWN0LXByZWZpeGVzLmpzIiwiLy8gQGZsb3dcblxuLyoqXG4gKiBkaXNwYXRjaCBjdXN0b20gZXZlbnRzXG4gKi9cblxuY29uc3QgZXZlbnREaXNwYXRjaGVyID0gKCkgPT4ge1xuICBjb25zdCBldmVudHMgPSB7fTtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBoYW5kbGVyIGZvciBldmVudCwgdG8gYmUgZmlyZWRcbiAgICogZm9yIGV2ZXJ5IGV2ZW50LlxuICAgKi9cbiAgY29uc3Qgb24gPSAoZXZlbnROYW1lOiBzdHJpbmcsIGhhbmRsZXI6IEZ1bmN0aW9uKSA9PiB7XG4gICAgZXZlbnRzW2V2ZW50TmFtZV0gPSBldmVudHNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICBldmVudHNbZXZlbnROYW1lXS5wdXNoKGhhbmRsZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgaGFuZGxlciBmb3IgZXZlbnQuXG4gICAqL1xuICBjb25zdCBvZmYgPSAoZXZlbnROYW1lOiBzdHJpbmcsIGhhbmRsZXI6IEZ1bmN0aW9uKSA9PiB7XG4gICAgaWYgKGV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50c1tldmVudE5hbWVdLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChldmVudHNbZXZlbnROYW1lXVtpXSA9PT0gaGFuZGxlcikge1xuICAgICAgICAgIGV2ZW50c1tldmVudE5hbWVdLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBkaXNwYXRjaCA9IChldmVudE5hbWU6IHN0cmluZywgZGF0YTogT2JqZWN0KSA9PiB7XG4gICAgaWYgKGV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICBldmVudHNbZXZlbnROYW1lXS5mb3JFYWNoKChmbikgPT4ge1xuICAgICAgICBmbihkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG9uLFxuICAgIG9mZixcbiAgICBkaXNwYXRjaCxcbiAgfTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgZXZlbnREaXNwYXRjaGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL2Rpc3BhdGNoLWV2ZW50LmpzIiwiLy8gQGZsb3dcblxuaW1wb3J0IHsgZ2V0WCwgZ2V0WSwgYWRkT2Zmc2V0IH0gZnJvbSAnLi9oYW5kbGUtcGluY2gnO1xuXG50eXBlIENlbnRlciA9IHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG59O1xuXG5jb25zdCBjYWxjTWF4ID0gKGVsOiBFdmVudFRhcmdldCwgZGlmZmVyOiBudW1iZXIsIHpvb21GYWN0b3I6IG51bWJlcik6IE9iamVjdCA9PiAoe1xuICBtYXhYOiAoem9vbUZhY3RvciAtIGRpZmZlcikgKiBnZXRYKGVsKSxcbiAgbWF4WTogKHpvb21GYWN0b3IgLSBkaWZmZXIpICogZ2V0WShlbCksXG59KTtcblxuZXhwb3J0IGNvbnN0IHNhbml0aXplT2Zmc2V0ID0gKGVsOiBFdmVudFRhcmdldCwgb2Zmc2V0OiBDZW50ZXIsIHpvb21GYWN0b3I6IG51bWJlcik6IE9iamVjdCA9PiB7XG4gIGNvbnN0IHsgbWF4WCwgbWF4WSB9ID0gY2FsY01heChlbCwgMSwgem9vbUZhY3Rvcik7XG4gIGNvbnN0IG1heE9mZnNldFggPSBNYXRoLm1heChtYXhYLCAwKTtcbiAgY29uc3QgbWF4T2Zmc2V0WSA9IE1hdGgubWF4KG1heFksIDApO1xuICBjb25zdCBtaW5PZmZzZXRYID0gTWF0aC5taW4obWF4WCwgMCk7XG4gIGNvbnN0IG1pbk9mZnNldFkgPSBNYXRoLm1pbihtYXhZLCAwKTtcblxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgubWluKE1hdGgubWF4KG9mZnNldC54LCBtaW5PZmZzZXRYKSwgbWF4T2Zmc2V0WCksXG4gICAgeTogTWF0aC5taW4oTWF0aC5tYXgob2Zmc2V0LnksIG1pbk9mZnNldFkpLCBtYXhPZmZzZXRZKVxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGRyYWcgPSAoY2VudGVyOiBDZW50ZXIsIGxhc3RDZW50ZXI6IENlbnRlciwgbGFzdE9mZnNldDogT2JqZWN0LCB6b29tRmFjdG9yOiBudW1iZXIpOiBPYmplY3QgPT4gKFxuICAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxhc3RDZW50ZXIsICd4JykpXG4gID8gYWRkT2Zmc2V0KGxhc3RPZmZzZXQsIHtcbiAgICB4OiAtKCgoY2VudGVyLnggLSBsYXN0Q2VudGVyLngpICogem9vbUZhY3RvcikgLyB6b29tRmFjdG9yKSxcbiAgICB5OiAtKCgoY2VudGVyLnkgLSBsYXN0Q2VudGVyLnkpICogem9vbUZhY3RvcikgLyB6b29tRmFjdG9yKSxcbiAgfSlcbiAgOiBsYXN0T2Zmc2V0XG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3V0aWxzL2hhbmRsZS1kcmFnLmpzIiwiLy8gQGZsb3dcblxuaW1wb3J0IGRldGVjdFByZWZpeGVzIGZyb20gJy4vZGV0ZWN0LXByZWZpeGVzJztcbmltcG9ydCB7IGdldEluaXRpYWxTY2FsZSB9IGZyb20gJy4vaGFuZGxlLXBpbmNoJztcblxuY29uc3QgcHJlZml4ZXMgPSBkZXRlY3RQcmVmaXhlcygpO1xuXG5jb25zdCBoYW5kbGVBbmltYXRpb24gPSAoZWw6IEhUTUxFbGVtZW50LCB0cmFuc2l0aW9uOiBzdHJpbmcsIGR1cmF0aW9uOiBudW1iZXIsIGVhc2U6IHN0cmluZyk6IHZvaWQgPT4ge1xuICBjb25zdCB7IHN0eWxlIH0gPSBlbDtcbiAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAlIDAlJztcbiAgc3R5bGVbYCR7dHJhbnNpdGlvbn1UaW1pbmdGdW5jdGlvbmBdID0gZWFzZTtcbiAgc3R5bGVbYCR7dHJhbnNpdGlvbn1EdXJhdGlvbmBdID0gYCR7ZHVyYXRpb259bXNgO1xufTtcblxuLyoqXG4gKiBzY2FsZUVsZW1lbnQgLXRyYW5zZG9ybXMgdG8gYSBnaXZlbiBwb3NpdGlvbiBpbiBhIGdpdmVuIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gKlxuICogQHBhcmFtIHsgT2JqZWN0IH0gZWwgZWxlbWVudCBmcm9tIHRoZSBldmVudHNcbiAqIEBwYXJhbSB7IE51bWJlciB9IHBpbmNoIG51bWJlciB3aGVyZSB0byBzY2FsZSB0b1xuICogQHBhcmFtIHsgT2JqZWN0IH0gY29vcmRzIG9iamVjdCB3aGVyZSB0byB0cmFuc2xhdGUgdG9cbiAqIEBwYXJhbSB7IE51bWJlciB9IGR1cmF0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpc3Rpb25cbiAqIEBwYXJhbSB7IFN0cmluZyB9IGVhc2UgZWFzaW5nIGNzcyBwcm9wZXJ0eVxuICogQHJldHVybiB7IFZvaWQgfVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IChlbDogSFRNTEVsZW1lbnQsIGltYWdlOiBIVE1MRWxlbWVudCwgcGluY2g6IG51bWJlciwgY29vcmRzOiBPYmplY3QsIGR1cmF0aW9uOiBudW1iZXIsIGVhc2U6IHN0cmluZyk6IHZvaWQgPT4ge1xuICBjb25zdCB7IHRyYW5zaXRpb24sIHRyYW5zZm9ybSwgaGFzU2NhbGUzZCB9ID0gcHJlZml4ZXM7XG4gIGNvbnN0IHsgc3R5bGUgfSA9IGltYWdlO1xuXG4gIGNvbnN0IHpvb21GYWN0b3IgPSBnZXRJbml0aWFsU2NhbGUoZWwsIGltYWdlKSAqIHBpbmNoO1xuXG4gIGNvbnN0IG9mZnNldFggPSAtY29vcmRzLng7XG4gIGNvbnN0IG9mZnNldFkgPSAtY29vcmRzLnk7XG5cbiAgaGFuZGxlQW5pbWF0aW9uKGltYWdlLCB0cmFuc2l0aW9uLCBkdXJhdGlvbiwgZWFzZSk7XG4gIGNvbnN0IHNjYWxlUHJvcCA9IChoYXNTY2FsZTNkKVxuICAgID8gYHNjYWxlM2QoJHt6b29tRmFjdG9yfSwgJHt6b29tRmFjdG9yfSwgMSlgXG4gICAgOiBgc2NhbGUoJHt6b29tRmFjdG9yfSwgJHt6b29tRmFjdG9yfSlgO1xuICBjb25zdCB0cmFuc2xhdGVQcm9wID0gYHRyYW5zbGF0ZSgke29mZnNldFh9cHgsICR7b2Zmc2V0WX1weClgO1xuXG4gIHN0eWxlW3RyYW5zZm9ybV0gPSBgJHt0cmFuc2xhdGVQcm9wfSAke3NjYWxlUHJvcH1gO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9oYW5kbGUtZWxlbWVudC5qcyIsIi8vIEBmbG93XG5sZXQgbGFzdFRvdWNoU3RhcnQgPSAwO1xuXG50eXBlIFRvY2hQYWdlID0ge1xuICBwYWdlWDogbnVtYmVyO1xuICBwYWdlWTogbnVtYmVyO1xufVxuXG50eXBlIFRvdWNoID0ge1xuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbn07XG5cbi8qKlxuICogY2FuY2VsRXZlbnQgLSBDYW5jZWwgRXZlbnRzIHNvIHdlIGRvbnQgYnViYmxlIHVwIG91ciBldmVudHMgdG8gdGhlIGRvY3VtZW50XG4gKlxuICogQHBhcmFtIHsgT2JqZWN0IH0gZXZlbnRcbiAqIEByZXR1cm4geyBWb2lkIH1cbiAqKi9cbmV4cG9ydCBjb25zdCBjYW5jZWxFdmVudCA9IChlOiBFdmVudCk6IHZvaWQgPT4ge1xuICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG59O1xuXG4vKipcbiAqIGRldGVjdERvdWJsZVRhcCAtIENoZWNrIGlmIHdlIGFyZSBkb3VibGUgdGFwcGluZ1xuICpcbiAqIEBwYXJhbSB7IE9iamVjdCB9IGV2ZW50XG4gKiBAcmV0dXJuIHsgQm9vbGVhbiB9XG4gKiovXG5leHBvcnQgY29uc3QgZGV0ZWN0RG91YmxlVGFwID0gKGU6IFRvdWNoRXZlbnQpOiBib29sZWFuID0+IHtcbiAgY29uc3QgdGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgbGFzdFRvdWNoU3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHRpbWUgLSBsYXN0VG91Y2hTdGFydCA8IDMwMCkge1xuICAgIGNhbmNlbEV2ZW50KGV2ZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgbGFzdFRvdWNoU3RhcnQgPSB0aW1lO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdG91Y2hlcyBvZiBhbiBldmVudCByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIG9mZnNldFxuICpcbiAqIEBwYXJhbSBldmVudFxuICogQHJldHVybiBhcnJheSB0b3VjaGVzXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUb3VjaGVzID0gKGVsOiBFdmVudFRhcmdldCwgdG91Y2hlczogQXJyYXk8VG9jaFBhZ2U+KTogQXJyYXk8VG91Y2g+ID0+IHtcbiAgY29uc3QgcG9zaXRpb24gPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHRvdWNoZXMubWFwKHRvdWNoID0+ICh7XG4gICAgeDogdG91Y2gucGFnZVggLSAocG9zaXRpb24ubGVmdCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCksXG4gICAgeTogdG91Y2gucGFnZVkgLSAocG9zaXRpb24udG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApLFxuICB9KSk7XG59O1xuXG4vKipcbiAqIGdldERpc3RhbmNlIC0gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIG91ciBmaW5nZXJzXG4gKlxuICogQHBhcmFtIHsgQXJyYXkgfSB0b3VjaGVzIHRvdWNoZXMgcGFzc2FzIGFuIGFycmF5IGZyb20gVG91Y2hMaXN0XG4gKiBAcmV0dXJuIHsgTnVtYmVyIH0gdGhlIGNhbGN1YWx0ZWQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZmluZ2Vyc1xuICoqL1xuZXhwb3J0IGNvbnN0IGdldERpc3RhbmNlID0gKHRvdWNoZXM6IEFycmF5PFRvdWNoPik6IG51bWJlciA9PiB7XG4gIGNvbnN0IFtmaXJzdCwgc2Vjb25kXSA9IHRvdWNoZXM7XG4gIHJldHVybiBNYXRoLnNxcnQoXG4gICAgKChmaXJzdC54IC0gc2Vjb25kLngpICogKGZpcnN0LnggLSBzZWNvbmQueCkpICtcbiAgICAoKGZpcnN0LnkgLSBzZWNvbmQueSkgKiAoZmlyc3QueSAtIHNlY29uZC55KSlcbiAgKTtcbn07XG5cbi8qKlxuICogY2FsY1NjYWxlIC0gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHdoZXJlIHdlIHN0YXJ0IG91ciBwaW5jaFxuICogdG8gd2hlcmUgd2UgZW5kIGl0XG4gKlxuICogQHBhcmFtIHsgQXJyYXkgfSBzdGFydFRvdWNoIFRoZSBzdGFydGluZyBwb2ludCBvZiBvdXIgdG91Y2hcbiAqIEBwYXJhbSB7IEFycmF5IH0gZW5kVG91Y2ggVGhlIGN1cnJlbnQgcG9pbnQgb2Ygb3VyIHRvdWNoXG4gKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGNTY2FsZSA9IChlbDogRXZlbnRUYXJnZXQsIHN0YXJ0VG91Y2g6IEFycmF5PE9iamVjdD4sIGVuZFRvdWNoOiBBcnJheTxPYmplY3Q+KTogbnVtYmVyID0+IChcbiAgZ2V0RGlzdGFuY2UoZ2V0VG91Y2hlcyhlbCwgZW5kVG91Y2gpKSAvIGdldERpc3RhbmNlKGdldFRvdWNoZXMoZWwsIHN0YXJ0VG91Y2gpKVxuKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy91dGlscy9oYW5kbGUtZXZlbnQuanMiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyoqXFxuICogcHJpc20uanMgZGVmYXVsdCB0aGVtZSBmb3IgSmF2YVNjcmlwdCwgQ1NTIGFuZCBIVE1MXFxuICogQmFzZWQgb24gZGFiYmxldCAoaHR0cDovL2RhYmJsZXQuY29tKVxcbiAqIEBhdXRob3IgTGVhIFZlcm91XFxuICovXFxuXFxuY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdLFxcbnByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIHtcXG5cXHRjb2xvcjogYmxhY2s7XFxuXFx0YmFja2dyb3VuZDogbm9uZTtcXG5cXHR0ZXh0LXNoYWRvdzogMCAxcHggd2hpdGU7XFxuXFx0Zm9udC1mYW1pbHk6IENvbnNvbGFzLCBNb25hY28sICdBbmRhbGUgTW9ubycsICdVYnVudHUgTW9ubycsIG1vbm9zcGFjZTtcXG5cXHR0ZXh0LWFsaWduOiBsZWZ0O1xcblxcdHdoaXRlLXNwYWNlOiBwcmU7XFxuXFx0d29yZC1zcGFjaW5nOiBub3JtYWw7XFxuXFx0d29yZC1icmVhazogbm9ybWFsO1xcblxcdHdvcmQtd3JhcDogbm9ybWFsO1xcblxcdGxpbmUtaGVpZ2h0OiAxLjU7XFxuXFxuXFx0LW1vei10YWItc2l6ZTogNDtcXG5cXHQtby10YWItc2l6ZTogNDtcXG5cXHR0YWItc2l6ZTogNDtcXG5cXG5cXHQtd2Via2l0LWh5cGhlbnM6IG5vbmU7XFxuXFx0LW1vei1oeXBoZW5zOiBub25lO1xcblxcdC1tcy1oeXBoZW5zOiBub25lO1xcblxcdGh5cGhlbnM6IG5vbmU7XFxufVxcblxcbnByZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdOjotbW96LXNlbGVjdGlvbiwgcHJlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0gOjotbW96LXNlbGVjdGlvbixcXG5jb2RlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl06Oi1tb3otc2VsZWN0aW9uLCBjb2RlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0gOjotbW96LXNlbGVjdGlvbiB7XFxuXFx0dGV4dC1zaGFkb3c6IG5vbmU7XFxuXFx0YmFja2dyb3VuZDogI2IzZDRmYztcXG59XFxuXFxucHJlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl06OnNlbGVjdGlvbiwgcHJlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0gOjpzZWxlY3Rpb24sXFxuY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdOjpzZWxlY3Rpb24sIGNvZGVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSA6OnNlbGVjdGlvbiB7XFxuXFx0dGV4dC1zaGFkb3c6IG5vbmU7XFxuXFx0YmFja2dyb3VuZDogI2IzZDRmYztcXG59XFxuXFxuQG1lZGlhIHByaW50IHtcXG5cXHRjb2RlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0sXFxuXFx0cHJlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0ge1xcblxcdFxcdHRleHQtc2hhZG93OiBub25lO1xcblxcdH1cXG59XFxuXFxuLyogQ29kZSBibG9ja3MgKi9cXG5wcmVbY2xhc3MqPVxcXCJsYW5ndWFnZS1cXFwiXSB7XFxuXFx0cGFkZGluZzogMWVtO1xcblxcdG1hcmdpbjogLjVlbSAwO1xcblxcdG92ZXJmbG93OiBhdXRvO1xcbn1cXG5cXG46bm90KHByZSkgPiBjb2RlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0sXFxucHJlW2NsYXNzKj1cXFwibGFuZ3VhZ2UtXFxcIl0ge1xcblxcdGJhY2tncm91bmQ6ICNmNWYyZjA7XFxufVxcblxcbi8qIElubGluZSBjb2RlICovXFxuOm5vdChwcmUpID4gY29kZVtjbGFzcyo9XFxcImxhbmd1YWdlLVxcXCJdIHtcXG5cXHRwYWRkaW5nOiAuMWVtO1xcblxcdGJvcmRlci1yYWRpdXM6IC4zZW07XFxuXFx0d2hpdGUtc3BhY2U6IG5vcm1hbDtcXG59XFxuXFxuLnRva2VuLmNvbW1lbnQsXFxuLnRva2VuLnByb2xvZyxcXG4udG9rZW4uZG9jdHlwZSxcXG4udG9rZW4uY2RhdGEge1xcblxcdGNvbG9yOiBzbGF0ZWdyYXk7XFxufVxcblxcbi50b2tlbi5wdW5jdHVhdGlvbiB7XFxuXFx0Y29sb3I6ICM5OTk7XFxufVxcblxcbi5uYW1lc3BhY2Uge1xcblxcdG9wYWNpdHk6IC43O1xcbn1cXG5cXG4udG9rZW4ucHJvcGVydHksXFxuLnRva2VuLnRhZyxcXG4udG9rZW4uYm9vbGVhbixcXG4udG9rZW4ubnVtYmVyLFxcbi50b2tlbi5jb25zdGFudCxcXG4udG9rZW4uc3ltYm9sLFxcbi50b2tlbi5kZWxldGVkIHtcXG5cXHRjb2xvcjogIzkwNTtcXG59XFxuXFxuLnRva2VuLnNlbGVjdG9yLFxcbi50b2tlbi5hdHRyLW5hbWUsXFxuLnRva2VuLnN0cmluZyxcXG4udG9rZW4uY2hhcixcXG4udG9rZW4uYnVpbHRpbixcXG4udG9rZW4uaW5zZXJ0ZWQge1xcblxcdGNvbG9yOiAjNjkwO1xcbn1cXG5cXG4udG9rZW4ub3BlcmF0b3IsXFxuLnRva2VuLmVudGl0eSxcXG4udG9rZW4udXJsLFxcbi5sYW5ndWFnZS1jc3MgLnRva2VuLnN0cmluZyxcXG4uc3R5bGUgLnRva2VuLnN0cmluZyB7XFxuXFx0Y29sb3I6ICNhNjdmNTk7XFxuXFx0YmFja2dyb3VuZDogaHNsYSgwLCAwJSwgMTAwJSwgLjUpO1xcbn1cXG5cXG4udG9rZW4uYXRydWxlLFxcbi50b2tlbi5hdHRyLXZhbHVlLFxcbi50b2tlbi5rZXl3b3JkIHtcXG5cXHRjb2xvcjogIzA3YTtcXG59XFxuXFxuLnRva2VuLmZ1bmN0aW9uIHtcXG5cXHRjb2xvcjogI0RENEE2ODtcXG59XFxuXFxuLnRva2VuLnJlZ2V4LFxcbi50b2tlbi5pbXBvcnRhbnQsXFxuLnRva2VuLnZhcmlhYmxlIHtcXG5cXHRjb2xvcjogI2U5MDtcXG59XFxuXFxuLnRva2VuLmltcG9ydGFudCxcXG4udG9rZW4uYm9sZCB7XFxuXFx0Zm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcbi50b2tlbi5pdGFsaWMge1xcblxcdGZvbnQtc3R5bGU6IGl0YWxpYztcXG59XFxuXFxuLnRva2VuLmVudGl0eSB7XFxuXFx0Y3Vyc29yOiBoZWxwO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vcHJpc21qcy90aGVtZXMvcHJpc20uY3NzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcclxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcclxuXHRcdHZhciBtZW1vO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0cmV0dXJuIG1lbW87XHJcblx0XHR9O1xyXG5cdH0sXHJcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XHJcblx0fSksXHJcblx0Z2V0SGVhZEVsZW1lbnQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuXHR9KSxcclxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcclxuXHRzaW5nbGV0b25Db3VudGVyID0gMCxcclxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XHJcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XHJcblx0XHRpZih0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcclxuXHR9XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxyXG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcclxuXHJcblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIDxoZWFkPi5cclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xyXG5cclxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xyXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xyXG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcclxuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYobmV3TGlzdCkge1xyXG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xyXG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XHJcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xyXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0aWYoZG9tU3R5bGUpIHtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XHJcblx0dmFyIHN0eWxlcyA9IFtdO1xyXG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xyXG5cdFx0dmFyIGlkID0gaXRlbVswXTtcclxuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xyXG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcclxuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xyXG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xyXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pXHJcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcclxuXHR9XHJcblx0cmV0dXJuIHN0eWxlcztcclxufVxyXG5cclxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xyXG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcclxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcclxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xyXG5cdFx0aWYoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcclxuXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xyXG5cdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcclxuXHRpZihpZHggPj0gMCkge1xyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XHJcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG5cdGxpbmtFbGVtZW50LnJlbCA9IFwic3R5bGVzaGVldFwiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XHJcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcclxuXHJcblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XHJcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcclxuXHRcdHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xyXG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XHJcblx0fSBlbHNlIGlmKG9iai5zb3VyY2VNYXAgJiZcclxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXHJcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR1cGRhdGUob2JqKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xyXG5cdFx0aWYobmV3T2JqKSB7XHJcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgdGV4dFN0b3JlID0gW107XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XHJcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcclxuXHJcblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcclxuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XHJcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cclxuXHRpZihtZWRpYSkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxyXG5cdH1cclxuXHJcblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcclxuXHJcblx0aWYoc291cmNlTWFwKSB7XHJcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxyXG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xyXG5cdH1cclxuXHJcblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XHJcblxyXG5cdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xyXG5cclxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHJcblx0aWYob2xkU3JjKVxyXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgcHJpc20gZnJvbSAncHJpc21qcyc7XG5pbXBvcnQgJ3ByaXNtanMvdGhlbWVzL3ByaXNtLmNzcyc7XG5cbmltcG9ydCBoYW5kbGVFdmVudCBmcm9tICcuL2hhbmRsZS1ldmVudCc7XG5pbXBvcnQgcGluY2hJdCBmcm9tICcuLi9zcmMvJztcblxucGluY2hJdCgnLmV4YW1wbGUtb25lIC5pbWctd3JhcHBlcicpO1xucGluY2hJdCgnLmV4YW1wbGUtdHJlZSAuaW1nLXdyYXBwZXInLCB7XG4gIG1heFNjYWxlOiA0LFxuICBtaW5TY2FsZTogMC41LFxuICBzbmFwQmFja1NwZWVkOiA1MDAsXG59KTtcblxuY29uc3QgcGluY2hJbWFnZSA9IHBpbmNoSXQoJy5leGFtcGxlLWZvdXIgLmltZy13cmFwcGVyJywge1xuICBzbmFwQmFja1NwZWVkOiAxMDAwLFxufSk7XG5cbmRvY3VtZW50XG4gIC5xdWVyeVNlbGVjdG9yKCcucmVzZXQtYnV0dG9uJylcbiAgLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIHBpbmNoSW1hZ2UucmVzZXQoKTtcbiAgfSk7XG5cbmNvbnN0IHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ldmVudC10YXJnZXQnKTtcbmNvbnN0IGhhbmRsZUV2ZW50RXhhbXBsZSA9IGhhbmRsZUV2ZW50KHRhcmdldCk7XG5jb25zdCBwaW5jaEV2ZW50ID0gcGluY2hJdCgnLmV4YW1wbGUtZml2ZSAuaW1nLXdyYXBwZXInLCB7XG4gIHRhcmdldDogJ2ltZycsXG4gIHNuYXBCYWNrU3BlZWQ6IDEwMDAsXG59KTtcblxucGluY2hFdmVudC5vbigndG91Y2hzdGFydCcsIGhhbmRsZUV2ZW50RXhhbXBsZSk7XG5waW5jaEV2ZW50Lm9uKCd0b3VjaG1vdmUnLCBoYW5kbGVFdmVudEV4YW1wbGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZG9jcy9hcHAuanMiXSwic291cmNlUm9vdCI6IiJ9